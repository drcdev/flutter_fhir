part 'element.g.dart';

@JsonSerializable(explicitToJson: true)
class Element {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

Element(
  {this.id,
    this.extension,
    });

  factory Element.fromJson(Map<String, dynamic> json) => _$ElementFromJson(json);
  Map<String, dynamic> toJson() => _$ElementToJson(this);
}

part 'extension.g.dart';

@JsonSerializable(explicitToJson: true)
class Extension {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  Source of the definition for the extension code - a logical name or a
// URL.
String url;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
bool valueBoolean; //  pattern: ^true|false$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueCanonical; //  pattern: ^\S*$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
int valuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
int valueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueUri; //  pattern: ^\S*$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueUrl; //  pattern: ^\S*$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
String valueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Address valueAddress;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Age valueAge;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Annotation valueAnnotation;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Attachment valueAttachment;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
CodeableConcept valueCodeableConcept;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Coding valueCoding;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
ContactPoint valueContactPoint;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Count valueCount;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Distance valueDistance;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Duration valueDuration;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
HumanName valueHumanName;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Identifier valueIdentifier;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Money valueMoney;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Period valuePeriod;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Quantity valueQuantity;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Range valueRange;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Ratio valueRatio;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Reference valueReference;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
SampledData valueSampledData;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Signature valueSignature;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Timing valueTiming;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
ContactDetail valueContactDetail;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Contributor valueContributor;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
DataRequirement valueDataRequirement;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Expression valueExpression;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
ParameterDefinition valueParameterDefinition;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
RelatedArtifact valueRelatedArtifact;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
TriggerDefinition valueTriggerDefinition;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
UsageContext valueUsageContext;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Dosage valueDosage;

//  Value of extension - must be one of a constrained set of the data
// types (see [Extensibility](extensibility.html) for a list).
Meta valueMeta;

Extension(
  {this.id,
    this.extension,
    this.url,
    this.valueBase64Binary,
    this.valueBoolean,
    this.valueCanonical,
    this.valueCode,
    this.valueDate,
    this.valueDateTime,
    this.valueDecimal,
    this.valueId,
    this.valueInstant,
    this.valueInteger,
    this.valueMarkdown,
    this.valueOid,
    this.valuePositiveInt,
    this.valueString,
    this.valueTime,
    this.valueUnsignedInt,
    this.valueUri,
    this.valueUrl,
    this.valueUuid,
    this.valueAddress,
    this.valueAge,
    this.valueAnnotation,
    this.valueAttachment,
    this.valueCodeableConcept,
    this.valueCoding,
    this.valueContactPoint,
    this.valueCount,
    this.valueDistance,
    this.valueDuration,
    this.valueHumanName,
    this.valueIdentifier,
    this.valueMoney,
    this.valuePeriod,
    this.valueQuantity,
    this.valueRange,
    this.valueRatio,
    this.valueReference,
    this.valueSampledData,
    this.valueSignature,
    this.valueTiming,
    this.valueContactDetail,
    this.valueContributor,
    this.valueDataRequirement,
    this.valueExpression,
    this.valueParameterDefinition,
    this.valueRelatedArtifact,
    this.valueTriggerDefinition,
    this.valueUsageContext,
    this.valueDosage,
    this.valueMeta,
    });

  factory Extension.fromJson(Map<String, dynamic> json) => _$ExtensionFromJson(json);
  Map<String, dynamic> toJson() => _$ExtensionToJson(this);
}

part 'narrative.g.dart';

@JsonSerializable(explicitToJson: true)
class Narrative {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The status of the narrative - whether it's entirely generated (from
// just the defined data or the extensions too), or whether a human
// authored it and it may contain additional data.
String status; // <code> enum: generated/extensions/additional/empty;

//  The actual narrative content, a stripped down version of XHTML.
xhtml div;

Narrative(
  {this.id,
    this.extension,
    this.status,
    this.div,
    });

  factory Narrative.fromJson(Map<String, dynamic> json) => _$NarrativeFromJson(json);
  Map<String, dynamic> toJson() => _$NarrativeToJson(this);
}

part 'annotation.g.dart';

@JsonSerializable(explicitToJson: true)
class Annotation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The individual responsible for making the annotation.
Reference authorReference;

//  The individual responsible for making the annotation.
String authorString; //  pattern: ^[ \r\n\t\S]+$

//  Indicates when this particular annotation was made.
DateTime time;

//  The text of the annotation in markdown format.
String text;

Annotation(
  {this.id,
    this.extension,
    this.authorReference,
    this.authorString,
    this.time,
    this.text,
    });

  factory Annotation.fromJson(Map<String, dynamic> json) => _$AnnotationFromJson(json);
  Map<String, dynamic> toJson() => _$AnnotationToJson(this);
}

part 'attachment.g.dart';

@JsonSerializable(explicitToJson: true)
class Attachment {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  Identifies the type of the data in the attachment and allows a method
// to be chosen to interpret or render the data. Includes mime type
// parameters such as charset where appropriate.
String contentType;

//  The human language of the content. The value can be any valid value
// according to BCP 47.
String language;

//  The actual data of the attachment - a sequence of bytes, base64
// encoded.
String data;

//  A location where the data can be accessed.
String url;

//  The number of bytes of data that make up this attachment (before
// base64 encoding, if that is done).
int size;

//  The calculated hash of the data using SHA-1. Represented using base64.
String hash;

//  A label or set of text to display in place of the data.
String title;

//  The date that the attachment was first created.
DateTime creation;

Attachment(
  {this.id,
    this.extension,
    this.contentType,
    this.language,
    this.data,
    this.url,
    this.size,
    this.hash,
    this.title,
    this.creation,
    });

  factory Attachment.fromJson(Map<String, dynamic> json) => _$AttachmentFromJson(json);
  Map<String, dynamic> toJson() => _$AttachmentToJson(this);
}

part 'identifier.g.dart';

@JsonSerializable(explicitToJson: true)
class Identifier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The purpose of this identifier.
String use; // <code> enum: usual/official/temp/secondary/old;

//  A coded type for the identifier that can be used to determine which
// identifier to use for a specific purpose.
CodeableConcept type;

//  Establishes the namespace for the value - that is, a URL that
// describes a set values that are unique.
String system;

//  The portion of the identifier typically relevant to the user and which
// is unique within the context of the system.
String value;

//  Time period during which identifier is/was valid for use.
Period period;

//  Organization that issued/manages the identifier.
Reference assigner;

Identifier(
  {this.id,
    this.extension,
    this.use,
    this.type,
    this.system,
    this.value,
    this.period,
    this.assigner,
    });

  factory Identifier.fromJson(Map<String, dynamic> json) => _$IdentifierFromJson(json);
  Map<String, dynamic> toJson() => _$IdentifierToJson(this);
}

part 'codeableConcept.g.dart';

@JsonSerializable(explicitToJson: true)
class CodeableConcept {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  A reference to a code defined by a terminology system.
List<Coding> coding;

//  A human language representation of the concept as
// seen/selected/uttered by the user who entered the data and/or which
// represents the intended meaning of the user.
String text;

CodeableConcept(
  {this.id,
    this.extension,
    this.coding,
    this.text,
    });

  factory CodeableConcept.fromJson(Map<String, dynamic> json) => _$CodeableConceptFromJson(json);
  Map<String, dynamic> toJson() => _$CodeableConceptToJson(this);
}

part 'coding.g.dart';

@JsonSerializable(explicitToJson: true)
class Coding {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The identification of the code system that defines the meaning of the
// symbol in the code.
String system;

//  The version of the code system which was used when choosing this code.
// Note that a well-maintained code system does not need the version
// reported, because the meaning of codes is consistent across versions.
// However this cannot consistently be assured, and when the meaning is
// not guaranteed to be consistent, the version SHOULD be exchanged.
String version;

//  A symbol in syntax defined by the system. The symbol may be a
// predefined code or an expression in a syntax defined by the coding
// system (e.g. post-coordination).
String code;

//  A representation of the meaning of the code in the system, following
// the rules of the system.
String display;

//  Indicates that this coding was chosen by a user directly - e.g. off a
// pick list of available items (codes or displays).
bool userSelected;

Coding(
  {this.id,
    this.extension,
    this.system,
    this.version,
    this.code,
    this.display,
    this.userSelected,
    });

  factory Coding.fromJson(Map<String, dynamic> json) => _$CodingFromJson(json);
  Map<String, dynamic> toJson() => _$CodingToJson(this);
}

part 'quantity.g.dart';

@JsonSerializable(explicitToJson: true)
class Quantity {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the measured amount. The value includes an implicit
// precision in the presentation of the value.
double value;

//  How the value should be understood and represented - whether the
// actual value is greater or less than the stated value due to
// measurement issues; e.g. if the comparator is "<" , then the real value
// is < stated value.
String comparator; // <code> enum: </<=/>=/>;

//  A human-readable form of the unit.
String unit;

//  The identification of the system that provides the coded form of the
// unit.
String system;

//  A computer processable form of the unit in some unit representation
// system.
String code;

Quantity(
  {this.id,
    this.extension,
    this.value,
    this.comparator,
    this.unit,
    this.system,
    this.code,
    });

  factory Quantity.fromJson(Map<String, dynamic> json) => _$QuantityFromJson(json);
  Map<String, dynamic> toJson() => _$QuantityToJson(this);
}

part 'duration.g.dart';

@JsonSerializable(explicitToJson: true)
class Duration {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the measured amount. The value includes an implicit
// precision in the presentation of the value.
double value;

//  How the value should be understood and represented - whether the
// actual value is greater or less than the stated value due to
// measurement issues; e.g. if the comparator is "<" , then the real value
// is < stated value.
String comparator; // <code> enum: </<=/>=/>;

//  A human-readable form of the unit.
String unit;

//  The identification of the system that provides the coded form of the
// unit.
String system;

//  A computer processable form of the unit in some unit representation
// system.
String code;

Duration(
  {this.id,
    this.extension,
    this.value,
    this.comparator,
    this.unit,
    this.system,
    this.code,
    });

  factory Duration.fromJson(Map<String, dynamic> json) => _$DurationFromJson(json);
  Map<String, dynamic> toJson() => _$DurationToJson(this);
}

part 'distance.g.dart';

@JsonSerializable(explicitToJson: true)
class Distance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the measured amount. The value includes an implicit
// precision in the presentation of the value.
double value;

//  How the value should be understood and represented - whether the
// actual value is greater or less than the stated value due to
// measurement issues; e.g. if the comparator is "<" , then the real value
// is < stated value.
String comparator; // <code> enum: </<=/>=/>;

//  A human-readable form of the unit.
String unit;

//  The identification of the system that provides the coded form of the
// unit.
String system;

//  A computer processable form of the unit in some unit representation
// system.
String code;

Distance(
  {this.id,
    this.extension,
    this.value,
    this.comparator,
    this.unit,
    this.system,
    this.code,
    });

  factory Distance.fromJson(Map<String, dynamic> json) => _$DistanceFromJson(json);
  Map<String, dynamic> toJson() => _$DistanceToJson(this);
}

part 'count.g.dart';

@JsonSerializable(explicitToJson: true)
class Count {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the measured amount. The value includes an implicit
// precision in the presentation of the value.
double value;

//  How the value should be understood and represented - whether the
// actual value is greater or less than the stated value due to
// measurement issues; e.g. if the comparator is "<" , then the real value
// is < stated value.
String comparator; // <code> enum: </<=/>=/>;

//  A human-readable form of the unit.
String unit;

//  The identification of the system that provides the coded form of the
// unit.
String system;

//  A computer processable form of the unit in some unit representation
// system.
String code;

Count(
  {this.id,
    this.extension,
    this.value,
    this.comparator,
    this.unit,
    this.system,
    this.code,
    });

  factory Count.fromJson(Map<String, dynamic> json) => _$CountFromJson(json);
  Map<String, dynamic> toJson() => _$CountToJson(this);
}

part 'money.g.dart';

@JsonSerializable(explicitToJson: true)
class Money {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  Numerical value (with implicit precision).
double value;

//  ISO 4217 Currency Code.
String currency;

Money(
  {this.id,
    this.extension,
    this.value,
    this.currency,
    });

  factory Money.fromJson(Map<String, dynamic> json) => _$MoneyFromJson(json);
  Map<String, dynamic> toJson() => _$MoneyToJson(this);
}

part 'age.g.dart';

@JsonSerializable(explicitToJson: true)
class Age {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the measured amount. The value includes an implicit
// precision in the presentation of the value.
double value;

//  How the value should be understood and represented - whether the
// actual value is greater or less than the stated value due to
// measurement issues; e.g. if the comparator is "<" , then the real value
// is < stated value.
String comparator; // <code> enum: </<=/>=/>;

//  A human-readable form of the unit.
String unit;

//  The identification of the system that provides the coded form of the
// unit.
String system;

//  A computer processable form of the unit in some unit representation
// system.
String code;

Age(
  {this.id,
    this.extension,
    this.value,
    this.comparator,
    this.unit,
    this.system,
    this.code,
    });

  factory Age.fromJson(Map<String, dynamic> json) => _$AgeFromJson(json);
  Map<String, dynamic> toJson() => _$AgeToJson(this);
}

part 'range.g.dart';

@JsonSerializable(explicitToJson: true)
class Range {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The low limit. The boundary is inclusive.
Quantity low;

//  The high limit. The boundary is inclusive.
Quantity high;

Range(
  {this.id,
    this.extension,
    this.low,
    this.high,
    });

  factory Range.fromJson(Map<String, dynamic> json) => _$RangeFromJson(json);
  Map<String, dynamic> toJson() => _$RangeToJson(this);
}

part 'period.g.dart';

@JsonSerializable(explicitToJson: true)
class Period {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The start of the period. The boundary is inclusive.
DateTime start;

//  The end of the period. If the end of the period is missing, it means
// no end was known or planned at the time the instance was created. The
// start may be in the past, and the end date in the future, which means
// that period is expected/planned to end at that time.
DateTime end;

Period(
  {this.id,
    this.extension,
    this.start,
    this.end,
    });

  factory Period.fromJson(Map<String, dynamic> json) => _$PeriodFromJson(json);
  Map<String, dynamic> toJson() => _$PeriodToJson(this);
}

part 'ratio.g.dart';

@JsonSerializable(explicitToJson: true)
class Ratio {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The value of the numerator.
Quantity numerator;

//  The value of the denominator.
Quantity denominator;

Ratio(
  {this.id,
    this.extension,
    this.numerator,
    this.denominator,
    });

  factory Ratio.fromJson(Map<String, dynamic> json) => _$RatioFromJson(json);
  Map<String, dynamic> toJson() => _$RatioToJson(this);
}

part 'reference.g.dart';

@JsonSerializable(explicitToJson: true)
class Reference {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  A reference to a location at which the other resource is found. The
// reference may be a relative reference, in which case it is relative to
// the service base URL, or an absolute URL that resolves to the location
// where the resource is found. The reference may be version specific or
// not. If the reference is not to a FHIR RESTful server, then it should
// be assumed to be version specific. Internal fragment references (start
// with '#') refer to contained resources.
String reference;

//  The expected type of the target of the reference. If both
// Reference.type and Reference.reference are populated and
// Reference.reference is a FHIR URL, both SHALL be consistent. The type
// is the Canonical URL of Resource Definition that is the type this
// reference refers to. References are URLs that are relative to
// http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference
// to http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are
// only allowed for logical models (and can only be used in references in
// logical models, not resources).
String type;

//  An identifier for the target resource. This is used when there is no
// way to reference the other resource directly, either because the entity
// it represents is not available through a FHIR server, or because there
// is no way for the author of the resource to convert a known identifier
// to an actual location. There is no requirement that a
// Reference.identifier point to something that is actually exposed as a
// FHIR instance, but it SHALL point to a business concept that would be
// expected to be exposed as a FHIR instance, and that instance would need
// to be of a FHIR resource type allowed by the reference.
Identifier identifier;

//  Plain text narrative that identifies the resource in addition to the
// resource reference.
String display;

Reference(
  {this.id,
    this.extension,
    this.reference,
    this.type,
    this.identifier,
    this.display,
    });

  factory Reference.fromJson(Map<String, dynamic> json) => _$ReferenceFromJson(json);
  Map<String, dynamic> toJson() => _$ReferenceToJson(this);
}

part 'sampledData.g.dart';

@JsonSerializable(explicitToJson: true)
class SampledData {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The base quantity that a measured value of zero represents. In
// addition, this provides the units of the entire measurement series.
Quantity origin;

//  The length of time between sampling times, measured in milliseconds.
double period;

//  A correction factor that is applied to the sampled data points before
// they are added to the origin.
double factor;

//  The lower limit of detection of the measured points. This is needed if
// any of the data points have the value "L" (lower than detection limit).
double lowerLimit;

//  The upper limit of detection of the measured points. This is needed if
// any of the data points have the value "U" (higher than detection
// limit).
double upperLimit;

//  The number of sample points at each time point. If this value is
// greater than one, then the dimensions will be interlaced - all the
// sample points for a point in time will be recorded at once.
int dimensions;

//  A series of data points which are decimal values separated by a single
// space (character u20). The special values "E" (error), "L" (below
// detection limit) and "U" (above detection limit) can also be used in
// place of a decimal value.
String data;

SampledData(
  {this.id,
    this.extension,
    this.origin,
    this.period,
    this.factor,
    this.lowerLimit,
    this.upperLimit,
    this.dimensions,
    this.data,
    });

  factory SampledData.fromJson(Map<String, dynamic> json) => _$SampledDataFromJson(json);
  Map<String, dynamic> toJson() => _$SampledDataToJson(this);
}

part 'signature.g.dart';

@JsonSerializable(explicitToJson: true)
class Signature {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  An indication of the reason that the entity signed this document. This
// may be explicitly included as part of the signature information and can
// be used when determining accountability for various actions concerning
// the document.
List<Coding> type;

//  When the digital signature was signed.
DateTime when;

//  A reference to an application-usable description of the identity that
// signed  (e.g. the signature used their private key).
Reference who;

//  A reference to an application-usable description of the identity that
// is represented by the signature.
Reference onBehalfOf;

//  A mime type that indicates the technical format of the target
// resources signed by the signature.
String targetFormat;

//  A mime type that indicates the technical format of the signature.
// Important mime types are application/signature+xml for X ML DigSig,
// application/jose for JWS, and image/* for a graphical image of a
// signature, etc.
String sigFormat;

//  The base64 encoding of the Signature content. When signature is not
// recorded electronically this element would be empty.
String data;

Signature(
  {this.id,
    this.extension,
    this.type,
    this.when,
    this.who,
    this.onBehalfOf,
    this.targetFormat,
    this.sigFormat,
    this.data,
    });

  factory Signature.fromJson(Map<String, dynamic> json) => _$SignatureFromJson(json);
  Map<String, dynamic> toJson() => _$SignatureToJson(this);
}

part 'humanName.g.dart';

@JsonSerializable(explicitToJson: true)
class HumanName {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  Identifies the purpose for this name.
String use; // <code> enum: usual/official/temp/nickname/anonymous/old/maiden;

//  Specifies the entire name as it should be displayed e.g. on an
// application UI. This may be provided instead of or as well as the
// specific parts.
String text;

//  The part of a name that links to the genealogy. In some cultures (e.g.
// Eritrea) the family name of a son is the first name of his father.
String family;

//  Given name.
List<String> given;

//  Part of the name that is acquired as a title due to academic, legal,
// employment or nobility status, etc. and that appears at the start of
// the name.
List<String> prefix;

//  Part of the name that is acquired as a title due to academic, legal,
// employment or nobility status, etc. and that appears at the end of the
// name.
List<String> suffix;

//  Indicates the period of time when this name was valid for the named
// person.
Period period;

HumanName(
  {this.id,
    this.extension,
    this.use,
    this.text,
    this.family,
    this.given,
    this.prefix,
    this.suffix,
    this.period,
    });

  factory HumanName.fromJson(Map<String, dynamic> json) => _$HumanNameFromJson(json);
  Map<String, dynamic> toJson() => _$HumanNameToJson(this);
}

part 'address.g.dart';

@JsonSerializable(explicitToJson: true)
class Address {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The purpose of this address.
String use; // <code> enum: home/work/temp/old/billing;

//  Distinguishes between physical addresses (those you can visit) and
// mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses
// are both.
String type; // <code> enum: postal/physical/both;

//  Specifies the entire address as it should be displayed e.g. on a
// postal label. This may be provided instead of or as well as the
// specific parts.
String text;

//  This component contains the house number, apartment number, street
// name, street direction,  P.O. Box number, delivery hints, and similar
// address information.
List<String> line;

//  The name of the city, town, suburb, village or other community or
// delivery center.
String city;

//  The name of the administrative area (county).
String district;

//  Sub-unit of a country with limited sovereignty in a federally
// organized country. A code may be used if codes are in common use (e.g.
// US 2 letter state codes).
String state;

//  A postal code designating a region defined by the postal service.
String postalCode;

//  Country - a nation as commonly understood or generally accepted.
String country;

//  Time period when address was/is in use.
Period period;

Address(
  {this.id,
    this.extension,
    this.use,
    this.type,
    this.text,
    this.line,
    this.city,
    this.district,
    this.state,
    this.postalCode,
    this.country,
    this.period,
    });

  factory Address.fromJson(Map<String, dynamic> json) => _$AddressFromJson(json);
  Map<String, dynamic> toJson() => _$AddressToJson(this);
}

part 'contactPoint.g.dart';

@JsonSerializable(explicitToJson: true)
class ContactPoint {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  Telecommunications form for contact point - what communications system
// is required to make use of the contact.
String system; // <code> enum: phone/fax/email/pager/url/sms/other;

//  The actual contact point details, in a form that is meaningful to the
// designated communication system (i.e. phone number or email address).
String value;

//  Identifies the purpose for the contact point.
String use; // <code> enum: home/work/temp/old/mobile;

//  Specifies a preferred order in which to use a set of contacts.
// ContactPoints with lower rank values are more preferred than those with
// higher rank values.
int rank;

//  Time period when the contact point was/is in use.
Period period;

ContactPoint(
  {this.id,
    this.extension,
    this.system,
    this.value,
    this.use,
    this.rank,
    this.period,
    });

  factory ContactPoint.fromJson(Map<String, dynamic> json) => _$ContactPointFromJson(json);
  Map<String, dynamic> toJson() => _$ContactPointToJson(this);
}

part 'timing.g.dart';

@JsonSerializable(explicitToJson: true)
class Timing {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies specific times when the event occurs.
List<DateTime> event;

//  A set of rules that describe when the event is scheduled.
Timing_Repeat repeat;

//  A code for the timing schedule (or just text in code.text). Some codes
// such as BID are ubiquitous, but many institutions define their own
// additional codes. If a code is provided, the code is understood to be a
// complete statement of whatever is specified in the structured timing
// data, and either the code or the data may be used to interpret the
// Timing, with the exception that .repeat.bounds still applies over the
// code (and is not contained in the code).
CodeableConcept code;

Timing(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.event,
    this.repeat,
    this.code,
    });

  factory Timing.fromJson(Map<String, dynamic> json) => _$TimingFromJson(json);
  Map<String, dynamic> toJson() => _$TimingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Timing_Repeat {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Either a duration for the length of the timing schedule, a range of
// possible length, or outer bounds for start and/or end limits of the
// timing schedule.
Duration boundsDuration;

//  Either a duration for the length of the timing schedule, a range of
// possible length, or outer bounds for start and/or end limits of the
// timing schedule.
Range boundsRange;

//  Either a duration for the length of the timing schedule, a range of
// possible length, or outer bounds for start and/or end limits of the
// timing schedule.
Period boundsPeriod;

//  A total count of the desired number of repetitions across the duration
// of the entire timing specification. If countMax is present, this
// element indicates the lower bound of the allowed range of count values.
int count;

//  If present, indicates that the count is a range - so to perform the
// action between [count] and [countMax] times.
int countMax;

//  How long this thing happens for when it happens. If durationMax is
// present, this element indicates the lower bound of the allowed range of
// the duration.
double duration;

//  If present, indicates that the duration is a range - so to perform the
// action between [duration] and [durationMax] time length.
double durationMax;

//  The units of time for the duration, in UCUM units.
String durationUnit; // <code> enum: s/min/h/d/wk/mo/a;

//  The number of times to repeat the action within the specified period.
// If frequencyMax is present, this element indicates the lower bound of
// the allowed range of the frequency.
int frequency;

//  If present, indicates that the frequency is a range - so to repeat
// between [frequency] and [frequencyMax] times within the period or
// period range.
int frequencyMax;

//  Indicates the duration of time over which repetitions are to occur;
// e.g. to express "3 times per day", 3 would be the frequency and "1 day"
// would be the period. If periodMax is present, this element indicates
// the lower bound of the allowed range of the period length.
double period;

//  If present, indicates that the period is a range from [period] to
// [periodMax], allowing expressing concepts such as "do this once every
// 3-5 days.
double periodMax;

//  The units of time for the period in UCUM units.
String periodUnit; // <code> enum: s/min/h/d/wk/mo/a;

//  If one or more days of week is provided, then the action happens only
// on the specified day(s).
List<String> dayOfWeek;

//  Specified time of day for action to take place.
List<String> timeOfDay;

//  An approximate time period during the day, potentially linked to an
// event of daily living that indicates when the action should occur.
List<String> when; // <code> enum: MORN/MORN.early/MORN.late/NOON/AFT/AFT.early/AFT.late/EVE/EVE.early/EVE.late/NIGHT/PHS/HS/WAKE/C/CM/CD/CV/AC/ACM/ACD/ACV/PC/PCM/PCD/PCV> when;

//  The number of minutes from the event. If the event code does not
// indicate whether the minutes is before or after the event, then the
// offset is assumed to be after the event.
int offset;

Timing_Repeat(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.boundsDuration,
    this.boundsRange,
    this.boundsPeriod,
    this.count,
    this.countMax,
    this.duration,
    this.durationMax,
    this.durationUnit,
    this.frequency,
    this.frequencyMax,
    this.period,
    this.periodMax,
    this.periodUnit,
    this.dayOfWeek,
    this.timeOfDay,
    this.when,
    this.offset,
    });

  factory Timing_Repeat.fromJson(Map<String, dynamic> json) => _$Timing_RepeatFromJson(json);
  Map<String, dynamic> toJson() => _$Timing_RepeatToJson(this);
}

part 'meta.g.dart';

@JsonSerializable(explicitToJson: true)
class Meta {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The version specific identifier, as it appears in the version portion
// of the URL. This value changes when the resource is created, updated,
// or deleted.
String versionId;

//  When the resource last changed - e.g. when the version changed.
DateTime lastUpdated;

//  A uri that identifies the source system of the resource. This provides
// a minimal amount of [[[Provenance]]] information that can be used to
// track or differentiate the source of information in the resource. The
// source may identify another FHIR server, document, message, database,
// etc.
String source;

//  A list of profiles (references to [[[StructureDefinition]]] resources)
// that this resource claims to conform to. The URL is a reference to
// [[[StructureDefinition.url]]].
List<String> profile;

//  Security labels applied to this resource. These tags connect specific
// resources to the overall security policy and infrastructure.
List<Coding> security;

//  Tags applied to this resource. Tags are intended to be used to
// identify and relate resources to process and workflow, and applications
// are not required to consider the tags when interpreting the meaning of
// a resource.
List<Coding> tag;

Meta(
  {this.id,
    this.extension,
    this.versionId,
    this.lastUpdated,
    this.source,
    this.profile,
    this.security,
    this.tag,
    });

  factory Meta.fromJson(Map<String, dynamic> json) => _$MetaFromJson(json);
  Map<String, dynamic> toJson() => _$MetaToJson(this);
}

part 'contactDetail.g.dart';

@JsonSerializable(explicitToJson: true)
class ContactDetail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The name of an individual to contact.
String name;

//  The contact details for the individual (if a name was provided) or the
// organization.
List<ContactPoint> telecom;

ContactDetail(
  {this.id,
    this.extension,
    this.name,
    this.telecom,
    });

  factory ContactDetail.fromJson(Map<String, dynamic> json) => _$ContactDetailFromJson(json);
  Map<String, dynamic> toJson() => _$ContactDetailToJson(this);
}

part 'contributor.g.dart';

@JsonSerializable(explicitToJson: true)
class Contributor {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The type of contributor.
String type; // <code> enum: author/editor/reviewer/endorser;

//  The name of the individual or organization responsible for the
// contribution.
String name;

//  Contact details to assist a user in finding and communicating with the
// contributor.
List<ContactDetail> contact;

Contributor(
  {this.id,
    this.extension,
    this.type,
    this.name,
    this.contact,
    });

  factory Contributor.fromJson(Map<String, dynamic> json) => _$ContributorFromJson(json);
  Map<String, dynamic> toJson() => _$ContributorToJson(this);
}

part 'dataRequirement.g.dart';

@JsonSerializable(explicitToJson: true)
class DataRequirement {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The type of the required data, specified as the type name of a
// resource. For profiles, this value is set to the type of the base
// resource of the profile.
String type;

//  The profile of the required data, specified as the uri of the profile
// definition.
List<String> profile;

//  The intended subjects of the data requirement. If this element is not
// provided, a Patient subject is assumed.
CodeableConcept subjectCodeableConcept;

//  The intended subjects of the data requirement. If this element is not
// provided, a Patient subject is assumed.
Reference subjectReference;

//  Indicates that specific elements of the type are referenced by the
// knowledge module and must be supported by the consumer in order to
// obtain an effective evaluation. This does not mean that a value is
// required for this element, only that the consuming system must
// understand the element and be able to provide values for it if they are
// available.  The value of mustSupport SHALL be a FHIRPath resolveable on
// the type of the DataRequirement. The path SHALL consist only of
// identifiers, constant indexers, and .resolve() (see the [Simple
// FHIRPath Profile](fhirpath.html#simple) for full details).
List<String> mustSupport;

//  Code filters specify additional constraints on the data, specifying
// the value set of interest for a particular element of the data. Each
// code filter defines an additional constraint on the data, i.e. code
// filters are AND'ed, not OR'ed.
List<DataRequirement_CodeFilter> codeFilter;

//  Date filters specify additional constraints on the data in terms of
// the applicable date range for specific elements. Each date filter
// specifies an additional constraint on the data, i.e. date filters are
// AND'ed, not OR'ed.
List<DataRequirement_DateFilter> dateFilter;

//  Specifies a maximum number of results that are required (uses the
// _count search parameter).
int limit;

//  Specifies the order of the results to be returned.
List<DataRequirement_Sort> sort;

DataRequirement(
  {this.id,
    this.extension,
    this.type,
    this.profile,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.mustSupport,
    this.codeFilter,
    this.dateFilter,
    this.limit,
    this.sort,
    });

  factory DataRequirement.fromJson(Map<String, dynamic> json) => _$DataRequirementFromJson(json);
  Map<String, dynamic> toJson() => _$DataRequirementToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DataRequirement_CodeFilter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The code-valued attribute of the filter. The specified path SHALL be a
// FHIRPath resolveable on the specified type of the DataRequirement, and
// SHALL consist only of identifiers, constant indexers, and .resolve().
// The path is allowed to contain qualifiers (.) to traverse sub-elements,
// as well as indexers ([x]) to traverse multiple-cardinality sub-elements
// (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full
// details). Note that the index must be an integer constant. The path
// must resolve to an element of type code, Coding, or CodeableConcept.
String path;

//  A token parameter that refers to a search parameter defined on the
// specified type of the DataRequirement, and which searches on elements
// of type code, Coding, or CodeableConcept.
String searchParam;

//  The valueset for the code filter. The valueSet and code elements are
// additive. If valueSet is specified, the filter will return only those
// data items for which the value of the code-valued element specified in
// the path is a member of the specified valueset.
String valueSet;

//  The codes for the code filter. If values are given, the filter will
// return only those data items for which the code-valued attribute
// specified by the path has a value that is one of the specified codes.
// If codes are specified in addition to a value set, the filter returns
// items matching a code in the value set or one of the specified codes.
List<Coding> code;

DataRequirement_CodeFilter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.searchParam,
    this.valueSet,
    this.code,
    });

  factory DataRequirement_CodeFilter.fromJson(Map<String, dynamic> json) => _$DataRequirement_CodeFilterFromJson(json);
  Map<String, dynamic> toJson() => _$DataRequirement_CodeFilterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DataRequirement_DateFilter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The date-valued attribute of the filter. The specified path SHALL be a
// FHIRPath resolveable on the specified type of the DataRequirement, and
// SHALL consist only of identifiers, constant indexers, and .resolve().
// The path is allowed to contain qualifiers (.) to traverse sub-elements,
// as well as indexers ([x]) to traverse multiple-cardinality sub-elements
// (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full
// details). Note that the index must be an integer constant. The path
// must resolve to an element of type date, dateTime, Period, Schedule, or
// Timing.
String path;

//  A date parameter that refers to a search parameter defined on the
// specified type of the DataRequirement, and which searches on elements
// of type date, dateTime, Period, Schedule, or Timing.
String searchParam;

//  The value of the filter. If period is specified, the filter will
// return only those data items that fall within the bounds determined by
// the Period, inclusive of the period boundaries. If dateTime is
// specified, the filter will return only those data items that are equal
// to the specified dateTime. If a Duration is specified, the filter will
// return only those data items that fall within Duration before now.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The value of the filter. If period is specified, the filter will
// return only those data items that fall within the bounds determined by
// the Period, inclusive of the period boundaries. If dateTime is
// specified, the filter will return only those data items that are equal
// to the specified dateTime. If a Duration is specified, the filter will
// return only those data items that fall within Duration before now.
Period valuePeriod;

//  The value of the filter. If period is specified, the filter will
// return only those data items that fall within the bounds determined by
// the Period, inclusive of the period boundaries. If dateTime is
// specified, the filter will return only those data items that are equal
// to the specified dateTime. If a Duration is specified, the filter will
// return only those data items that fall within Duration before now.
Duration valueDuration;

DataRequirement_DateFilter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.searchParam,
    this.valueDateTime,
    this.valuePeriod,
    this.valueDuration,
    });

  factory DataRequirement_DateFilter.fromJson(Map<String, dynamic> json) => _$DataRequirement_DateFilterFromJson(json);
  Map<String, dynamic> toJson() => _$DataRequirement_DateFilterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DataRequirement_Sort {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The attribute of the sort. The specified path must be resolvable from
// the type of the required data. The path is allowed to contain
// qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to
// traverse multiple-cardinality sub-elements. Note that the index must be
// an integer constant.
String path;

//  The direction of the sort, ascending or descending.
String direction; // <code> enum: ascending/descending;

DataRequirement_Sort(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.direction,
    });

  factory DataRequirement_Sort.fromJson(Map<String, dynamic> json) => _$DataRequirement_SortFromJson(json);
  Map<String, dynamic> toJson() => _$DataRequirement_SortToJson(this);
}

part 'parameterDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ParameterDefinition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The name of the parameter used to allow access to the value of the
// parameter in evaluation contexts.
String name;

//  Whether the parameter is input or output for the module.
String use;

//  The minimum number of times this parameter SHALL appear in the request
// or response.
int min;

//  The maximum number of times this element is permitted to appear in the
// request or response.
String max;

//  A brief discussion of what the parameter is for and how it is used by
// the module.
String documentation;

//  The type of the parameter.
String type;

//  If specified, this indicates a profile that the input data must
// conform to, or that the output data will conform to.
String profile;

ParameterDefinition(
  {this.id,
    this.extension,
    this.name,
    this.use,
    this.min,
    this.max,
    this.documentation,
    this.type,
    this.profile,
    });

  factory ParameterDefinition.fromJson(Map<String, dynamic> json) => _$ParameterDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ParameterDefinitionToJson(this);
}

part 'relatedArtifact.g.dart';

@JsonSerializable(explicitToJson: true)
class RelatedArtifact {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The type of relationship to the related artifact.
String type; // <code> enum: documentation/justification/citation/predecessor/successor/derived-from/depends-on/composed-of;

//  A short label that can be used to reference the citation from
// elsewhere in the containing artifact, such as a footnote index.
String label;

//  A brief description of the document or knowledge resource being
// referenced, suitable for display to a consumer.
String display;

//  A bibliographic citation for the related artifact. This text SHOULD be
// formatted according to an accepted citation format.
String citation;

//  A url for the artifact that can be followed to access the actual
// content.
String url;

//  The document being referenced, represented as an attachment. This is
// exclusive with the resource element.
Attachment document;

//  The related resource, such as a library, value set, profile, or other
// knowledge resource.
String resource;

RelatedArtifact(
  {this.id,
    this.extension,
    this.type,
    this.label,
    this.display,
    this.citation,
    this.url,
    this.document,
    this.resource,
    });

  factory RelatedArtifact.fromJson(Map<String, dynamic> json) => _$RelatedArtifactFromJson(json);
  Map<String, dynamic> toJson() => _$RelatedArtifactToJson(this);
}

part 'triggerDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class TriggerDefinition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  The type of triggering event.
String type; // <code> enum: named-event/periodic/data-changed/data-added/data-modified/data-removed/data-accessed/data-access-ended;

//  A formal name for the event. This may be an absolute URI that
// identifies the event formally (e.g. from a trigger registry), or a
// simple relative URI that identifies the event in a local context.
String name;

//  The timing of the event (if this is a periodic trigger).
Timing timingTiming;

//  The timing of the event (if this is a periodic trigger).
Reference timingReference;

//  The timing of the event (if this is a periodic trigger).
String timingDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The timing of the event (if this is a periodic trigger).
String timingDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The triggering data of the event (if this is a data trigger). If more
// than one data is requirement is specified, then all the data
// requirements must be true.
List<DataRequirement> data;

//  A boolean-valued expression that is evaluated in the context of the
// container of the trigger definition and returns whether or not the
// trigger fires.
Expression condition;

TriggerDefinition(
  {this.id,
    this.extension,
    this.type,
    this.name,
    this.timingTiming,
    this.timingReference,
    this.timingDate,
    this.timingDateTime,
    this.data,
    this.condition,
    });

  factory TriggerDefinition.fromJson(Map<String, dynamic> json) => _$TriggerDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$TriggerDefinitionToJson(this);
}

part 'usageContext.g.dart';

@JsonSerializable(explicitToJson: true)
class UsageContext {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  A code that identifies the type of context being specified by this
// usage context.
Coding code;

//  A value that defines the context specified in this context of use. The
// interpretation of the value is defined by the code.
CodeableConcept valueCodeableConcept;

//  A value that defines the context specified in this context of use. The
// interpretation of the value is defined by the code.
Quantity valueQuantity;

//  A value that defines the context specified in this context of use. The
// interpretation of the value is defined by the code.
Range valueRange;

//  A value that defines the context specified in this context of use. The
// interpretation of the value is defined by the code.
Reference valueReference;

UsageContext(
  {this.id,
    this.extension,
    this.code,
    this.valueCodeableConcept,
    this.valueQuantity,
    this.valueRange,
    this.valueReference,
    });

  factory UsageContext.fromJson(Map<String, dynamic> json) => _$UsageContextFromJson(json);
  Map<String, dynamic> toJson() => _$UsageContextToJson(this);
}

part 'dosage.g.dart';

@JsonSerializable(explicitToJson: true)
class Dosage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates the order in which the dosage instructions should be applied
// or interpreted.
int sequence;

//  Free text dosage instructions e.g. SIG.
String text;

//  Supplemental instructions to the patient on how to take the medication
//  (e.g. "with meals" or"take half to one hour before food") or warnings
// for the patient about the medication (e.g. "may cause drowsiness" or
// "avoid exposure of skin to direct sunlight or sunlamps").
List<CodeableConcept> additionalInstruction;

//  Instructions in terms that are understood by the patient or consumer.
String patientInstruction;

//  When medication should be administered.
Timing timing;

//  Indicates whether the Medication is only taken when needed within a
// specific dosing schedule (Boolean option), or it indicates the
// precondition for taking the Medication (CodeableConcept).
bool asNeededBoolean; //  pattern: ^true|false$

//  Indicates whether the Medication is only taken when needed within a
// specific dosing schedule (Boolean option), or it indicates the
// precondition for taking the Medication (CodeableConcept).
CodeableConcept asNeededCodeableConcept;

//  Body site to administer to.
CodeableConcept site;

//  How drug should enter body.
CodeableConcept route;

//  Technique for administering medication.
CodeableConcept method;

//  The amount of medication administered.
List<Dosage_DoseAndRate> doseAndRate;

//  Upper limit on medication per unit of time.
Ratio maxDosePerPeriod;

//  Upper limit on medication per administration.
Quantity maxDosePerAdministration;

//  Upper limit on medication per lifetime of the patient.
Quantity maxDosePerLifetime;

Dosage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.text,
    this.additionalInstruction,
    this.patientInstruction,
    this.timing,
    this.asNeededBoolean,
    this.asNeededCodeableConcept,
    this.site,
    this.route,
    this.method,
    this.doseAndRate,
    this.maxDosePerPeriod,
    this.maxDosePerAdministration,
    this.maxDosePerLifetime,
    });

  factory Dosage.fromJson(Map<String, dynamic> json) => _$DosageFromJson(json);
  Map<String, dynamic> toJson() => _$DosageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Dosage_DoseAndRate {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of dose or rate specified, for example, ordered or
// calculated.
CodeableConcept type;

//  Amount of medication per dose.
Range doseRange;

//  Amount of medication per dose.
Quantity doseQuantity;

//  Amount of medication per unit of time.
Ratio rateRatio;

//  Amount of medication per unit of time.
Range rateRange;

//  Amount of medication per unit of time.
Quantity rateQuantity;

Dosage_DoseAndRate(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.doseRange,
    this.doseQuantity,
    this.rateRatio,
    this.rateRange,
    this.rateQuantity,
    });

  factory Dosage_DoseAndRate.fromJson(Map<String, dynamic> json) => _$Dosage_DoseAndRateFromJson(json);
  Map<String, dynamic> toJson() => _$Dosage_DoseAndRateToJson(this);
}

part 'population.g.dart';

@JsonSerializable(explicitToJson: true)
class Population {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The age of the specific population.
Range ageRange;

//  The age of the specific population.
CodeableConcept ageCodeableConcept;

//  The gender of the specific population.
CodeableConcept gender;

//  Race of the specific population.
CodeableConcept race;

//  The existing physiological conditions of the specific population to
// which this applies.
CodeableConcept physiologicalCondition;

Population(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.ageRange,
    this.ageCodeableConcept,
    this.gender,
    this.race,
    this.physiologicalCondition,
    });

  factory Population.fromJson(Map<String, dynamic> json) => _$PopulationFromJson(json);
  Map<String, dynamic> toJson() => _$PopulationToJson(this);
}

part 'productShelfLife.g.dart';

@JsonSerializable(explicitToJson: true)
class ProductShelfLife {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for the packaged Medicinal Product.
Identifier identifier;

//  This describes the shelf life, taking into account various scenarios
// such as shelf life of the packaged Medicinal Product itself, shelf life
// after transformation where necessary and shelf life after the first
// opening of a bottle, etc. The shelf life type shall be specified using
// an appropriate controlled vocabulary The controlled term and the
// controlled term identifier shall be specified.
CodeableConcept type;

//  The shelf life time period can be specified using a numerical value
// for the period of time and its unit of time measurement The unit of
// measurement shall be specified in accordance with ISO 11240 and the
// resulting terminology The symbol and the symbol identifier shall be
// used.
Quantity period;

//  Special precautions for storage, if any, can be specified using an
// appropriate controlled vocabulary The controlled term and the
// controlled term identifier shall be specified.
List<CodeableConcept> specialPrecautionsForStorage;

ProductShelfLife(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.period,
    this.specialPrecautionsForStorage,
    });

  factory ProductShelfLife.fromJson(Map<String, dynamic> json) => _$ProductShelfLifeFromJson(json);
  Map<String, dynamic> toJson() => _$ProductShelfLifeToJson(this);
}

part 'prodCharacteristic.g.dart';

@JsonSerializable(explicitToJson: true)
class ProdCharacteristic {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Where applicable, the height can be specified using a numerical value
// and its unit of measurement The unit of measurement shall be specified
// in accordance with ISO 11240 and the resulting terminology The symbol
// and the symbol identifier shall be used.
Quantity height;

//  Where applicable, the width can be specified using a numerical value
// and its unit of measurement The unit of measurement shall be specified
// in accordance with ISO 11240 and the resulting terminology The symbol
// and the symbol identifier shall be used.
Quantity width;

//  Where applicable, the depth can be specified using a numerical value
// and its unit of measurement The unit of measurement shall be specified
// in accordance with ISO 11240 and the resulting terminology The symbol
// and the symbol identifier shall be used.
Quantity depth;

//  Where applicable, the weight can be specified using a numerical value
// and its unit of measurement The unit of measurement shall be specified
// in accordance with ISO 11240 and the resulting terminology The symbol
// and the symbol identifier shall be used.
Quantity weight;

//  Where applicable, the nominal volume can be specified using a
// numerical value and its unit of measurement The unit of measurement
// shall be specified in accordance with ISO 11240 and the resulting
// terminology The symbol and the symbol identifier shall be used.
Quantity nominalVolume;

//  Where applicable, the external diameter can be specified using a
// numerical value and its unit of measurement The unit of measurement
// shall be specified in accordance with ISO 11240 and the resulting
// terminology The symbol and the symbol identifier shall be used.
Quantity externalDiameter;

//  Where applicable, the shape can be specified An appropriate controlled
// vocabulary shall be used The term and the term identifier shall be
// used.
String shape;

//  Where applicable, the color can be specified An appropriate controlled
// vocabulary shall be used The term and the term identifier shall be
// used.
List<String> color;

//  Where applicable, the imprint can be specified as text.
List<String> imprint;

//  Where applicable, the image can be provided The format of the image
// attachment shall be specified by regional implementations.
List<Attachment> image;

//  Where applicable, the scoring can be specified An appropriate
// controlled vocabulary shall be used The term and the term identifier
// shall be used.
CodeableConcept scoring;

ProdCharacteristic(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.height,
    this.width,
    this.depth,
    this.weight,
    this.nominalVolume,
    this.externalDiameter,
    this.shape,
    this.color,
    this.imprint,
    this.image,
    this.scoring,
    });

  factory ProdCharacteristic.fromJson(Map<String, dynamic> json) => _$ProdCharacteristicFromJson(json);
  Map<String, dynamic> toJson() => _$ProdCharacteristicToJson(this);
}

part 'marketingStatus.g.dart';

@JsonSerializable(explicitToJson: true)
class MarketingStatus {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The country in which the marketing authorisation has been granted
// shall be specified It should be specified using the ISO 3166  1
// alpha-2 code elements.
CodeableConcept country;

//  Where a Medicines Regulatory Agency has granted a marketing
// authorisation for which specific provisions within a jurisdiction
// apply, the jurisdiction can be specified using an appropriate
// controlled terminology The controlled term and the controlled term
// identifier shall be specified.
CodeableConcept jurisdiction;

//  This attribute provides information on the status of the marketing of
// the medicinal product See ISO/TS 20443 for more information and
// examples.
CodeableConcept status;

//  The date when the Medicinal Product is placed on the market by the
// Marketing Authorisation Holder (or where applicable, the
// manufacturer/distributor) in a country and/or jurisdiction shall be
// provided A complete date consisting of day, month and year shall be
// specified using the ISO 8601 date format NOTE Placed on the market
// refers to the release of the Medicinal Product into the distribution
// chain.
Period dateRange;

//  The date when the Medicinal Product is placed on the market by the
// Marketing Authorisation Holder (or where applicable, the
// manufacturer/distributor) in a country and/or jurisdiction shall be
// provided A complete date consisting of day, month and year shall be
// specified using the ISO 8601 date format NOTE Placed on the market
// refers to the release of the Medicinal Product into the distribution
// chain.
DateTime restoreDate;

MarketingStatus(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.country,
    this.jurisdiction,
    this.status,
    this.dateRange,
    this.restoreDate,
    });

  factory MarketingStatus.fromJson(Map<String, dynamic> json) => _$MarketingStatusFromJson(json);
  Map<String, dynamic> toJson() => _$MarketingStatusToJson(this);
}

part 'substanceAmount.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceAmount {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Used to capture quantitative values for a variety of elements. If only
// limits are given, the arithmetic mean would be the average. If only a
// single definite value for a given element is given, it would be
// captured in this field.
Quantity amountQuantity;

//  Used to capture quantitative values for a variety of elements. If only
// limits are given, the arithmetic mean would be the average. If only a
// single definite value for a given element is given, it would be
// captured in this field.
Range amountRange;

//  Used to capture quantitative values for a variety of elements. If only
// limits are given, the arithmetic mean would be the average. If only a
// single definite value for a given element is given, it would be
// captured in this field.
String amountString; //  pattern: ^[ \r\n\t\S]+$

//  Most elements that require a quantitative value will also have a field
// called amount type. Amount type should always be specified because the
// actual value of the amount is often dependent on it. EXAMPLE: In
// capturing the actual relative amounts of substances or molecular
// fragments it is essential to indicate whether the amount refers to a
// mole ratio or weight ratio. For any given element an effort should be
// made to use same the amount type for all related definitional elements.
CodeableConcept amountType;

//  A textual comment on a numeric value.
String amountText;

//  Reference range of possible or expected values.
SubstanceAmount_ReferenceRange referenceRange;

SubstanceAmount(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.amountQuantity,
    this.amountRange,
    this.amountString,
    this.amountType,
    this.amountText,
    this.referenceRange,
    });

  factory SubstanceAmount.fromJson(Map<String, dynamic> json) => _$SubstanceAmountFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceAmountToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceAmount_ReferenceRange {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Lower limit possible or expected.
Quantity lowLimit;

//  Upper limit possible or expected.
Quantity highLimit;

SubstanceAmount_ReferenceRange(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.lowLimit,
    this.highLimit,
    });

  factory SubstanceAmount_ReferenceRange.fromJson(Map<String, dynamic> json) => _$SubstanceAmount_ReferenceRangeFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceAmount_ReferenceRangeToJson(this);
}

part 'expression.g.dart';

@JsonSerializable(explicitToJson: true)
class Expression {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  A brief, natural language description of the condition that
// effectively communicates the intended semantics.
String description;

//  A short name assigned to the expression to allow for multiple reuse of
// the expression in the context where it is defined.
String name;

//  The media type of the language for the expression.
String language; // <code> enum: text/cql/text/fhirpath/application/x-fhir-query;

//  An expression in the specified language that returns a value.
String expression;

//  A URI that defines where the expression is found.
String reference;

Expression(
  {this.id,
    this.extension,
    this.description,
    this.name,
    this.language,
    this.expression,
    this.reference,
    });

  factory Expression.fromJson(Map<String, dynamic> json) => _$ExpressionFromJson(json);
  Map<String, dynamic> toJson() => _$ExpressionToJson(this);
}

part 'elementDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ElementDefinition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The path identifies the element and is expressed as a "."-separated
// list of ancestor elements, beginning with the name of the resource or
// extension.
String path;

//  Codes that define how this element is represented in instances, when
// the deviation varies from the normal case.
List<String> representation; // <code> enum: xmlAttr/xmlText/typeAttr/cdaText/xhtml> representation;

//  The name of this element definition slice, when slicing is working.
// The name must be a token with no dots or spaces. This is a unique name
// referring to a specific set of constraints applied to this element,
// used to provide a name to different slices of the same element.
String sliceName;

//  If true, indicates that this slice definition is constraining a slice
// definition with the same name in an inherited profile. If false, the
// slice is not overriding any slice in an inherited profile. If missing,
// the slice might or might not be overriding a slice in an inherited
// profile, depending on the sliceName.
bool sliceIsConstraining;

//  A single preferred label which is the text to display beside the
// element indicating its meaning or to use to prompt for the element in a
// user display or form.
String label;

//  A code that has the same meaning as the element in a particular
// terminology.
List<Coding> code;

//  Indicates that the element is sliced into a set of alternative
// definitions (i.e. in a structure definition, there are multiple
// different constraints on a single element in the base resource).
// Slicing can be used in any resource that has cardinality ..* on the
// base resource, or any resource with a choice of types. The set of
// slices is any elements that come after this in the element sequence
// that have the same path, until a shorter path occurs (the shorter path
// terminates the set).
ElementDefinition_Slicing slicing;

//  A concise description of what this element means (e.g. for use in
// autogenerated summaries).
String short;

//  Provides a complete explanation of the meaning of the data element for
// human readability.  For the case of elements derived from existing
// elements (e.g. constraints), the definition SHALL be consistent with
// the base definition, but convey the meaning of the element in the
// particular context of use of the resource. (Note: The text you are
// reading is specified in ElementDefinition.definition).
String definition;

//  Explanatory notes and implementation guidance about the data element,
// including notes about how to use the data properly, exceptions to
// proper use, etc. (Note: The text you are reading is specified in
// ElementDefinition.comment).
String comment;

//  This element is for traceability of why the element was created and
// why the constraints exist as they do. This may be used to point to
// source materials or specifications that drove the structure of this
// element.
String requirements;

//  Identifies additional names by which this element might also be known.
List<String> alias;

//  The minimum number of times this element SHALL appear in the instance.
int min;

//  The maximum number of times this element is permitted to appear in the
// instance.
String max;

//  Information about the base definition of the element, provided to make
// it unnecessary for tools to trace the deviation of the element through
// the derived and related profiles. When the element definition is not
// the original definition of an element - i.g. either in a constraint on
// another type, or for elements from a super type in a snap shot - then
// the information in provided in the element definition may be different
// to the base definition. On the original definition of the element, it
// will be same.
ElementDefinition_Base base;

//  Identifies an element defined elsewhere in the definition whose
// content rules should be applied to the current element.
// ContentReferences bring across all the rules that are in the
// ElementDefinition for the element, including definitions, cardinality
// constraints, bindings, invariants etc.
String contentReference;

//  The data type or resource that the value of this element is permitted
// to be.
List<ElementDefinition_Type> type;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
bool defaultValueBoolean; //  pattern: ^true|false$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueCanonical; //  pattern: ^\S*$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
double defaultValueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
int defaultValueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
int defaultValuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueString; //  pattern: ^[ \r\n\t\S]+$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
int defaultValueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueUri; //  pattern: ^\S*$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueUrl; //  pattern: ^\S*$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
String defaultValueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Address defaultValueAddress;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Age defaultValueAge;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Annotation defaultValueAnnotation;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Attachment defaultValueAttachment;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
CodeableConcept defaultValueCodeableConcept;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Coding defaultValueCoding;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
ContactPoint defaultValueContactPoint;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Count defaultValueCount;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Distance defaultValueDistance;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Duration defaultValueDuration;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
HumanName defaultValueHumanName;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Identifier defaultValueIdentifier;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Money defaultValueMoney;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Period defaultValuePeriod;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Quantity defaultValueQuantity;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Range defaultValueRange;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Ratio defaultValueRatio;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Reference defaultValueReference;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
SampledData defaultValueSampledData;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Signature defaultValueSignature;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Timing defaultValueTiming;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
ContactDetail defaultValueContactDetail;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Contributor defaultValueContributor;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
DataRequirement defaultValueDataRequirement;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Expression defaultValueExpression;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
ParameterDefinition defaultValueParameterDefinition;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
RelatedArtifact defaultValueRelatedArtifact;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
TriggerDefinition defaultValueTriggerDefinition;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
UsageContext defaultValueUsageContext;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Dosage defaultValueDosage;

//  The value that should be used if there is no value stated in the
// instance (e.g. 'if not otherwise specified, the abstract is false').
Meta defaultValueMeta;

//  The Implicit meaning that is to be understood when this element is
// missing (e.g. 'when this element is missing, the period is ongoing').
String meaningWhenMissing;

//  If present, indicates that the order of the repeating element has
// meaning and describes what that meaning is.  If absent, it means that
// the order of the element has no meaning.
String orderMeaning;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
bool fixedBoolean; //  pattern: ^true|false$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedCanonical; //  pattern: ^\S*$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
double fixedDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
int fixedInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
int fixedPositiveInt; //  pattern: ^[1-9][0-9]*$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedString; //  pattern: ^[ \r\n\t\S]+$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
int fixedUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedUri; //  pattern: ^\S*$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedUrl; //  pattern: ^\S*$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
String fixedUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Address fixedAddress;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Age fixedAge;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Annotation fixedAnnotation;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Attachment fixedAttachment;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
CodeableConcept fixedCodeableConcept;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Coding fixedCoding;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
ContactPoint fixedContactPoint;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Count fixedCount;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Distance fixedDistance;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Duration fixedDuration;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
HumanName fixedHumanName;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Identifier fixedIdentifier;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Money fixedMoney;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Period fixedPeriod;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Quantity fixedQuantity;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Range fixedRange;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Ratio fixedRatio;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Reference fixedReference;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
SampledData fixedSampledData;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Signature fixedSignature;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Timing fixedTiming;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
ContactDetail fixedContactDetail;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Contributor fixedContributor;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
DataRequirement fixedDataRequirement;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Expression fixedExpression;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
ParameterDefinition fixedParameterDefinition;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
RelatedArtifact fixedRelatedArtifact;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
TriggerDefinition fixedTriggerDefinition;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
UsageContext fixedUsageContext;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Dosage fixedDosage;

//  Specifies a value that SHALL be exactly the value  for this element in
// the instance. For purposes of comparison, non-significant whitespace is
// ignored, and all values must be an exact match (case and accent
// sensitive). Missing elements/attributes must also be missing.
Meta fixedMeta;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
bool patternBoolean; //  pattern: ^true|false$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternCanonical; //  pattern: ^\S*$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
double patternDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
int patternInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
int patternPositiveInt; //  pattern: ^[1-9][0-9]*$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternString; //  pattern: ^[ \r\n\t\S]+$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
int patternUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternUri; //  pattern: ^\S*$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternUrl; //  pattern: ^\S*$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
String patternUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Address patternAddress;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Age patternAge;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Annotation patternAnnotation;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Attachment patternAttachment;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
CodeableConcept patternCodeableConcept;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Coding patternCoding;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
ContactPoint patternContactPoint;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Count patternCount;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Distance patternDistance;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Duration patternDuration;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
HumanName patternHumanName;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Identifier patternIdentifier;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Money patternMoney;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Period patternPeriod;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Quantity patternQuantity;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Range patternRange;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Ratio patternRatio;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Reference patternReference;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
SampledData patternSampledData;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Signature patternSignature;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Timing patternTiming;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
ContactDetail patternContactDetail;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Contributor patternContributor;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
DataRequirement patternDataRequirement;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Expression patternExpression;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
ParameterDefinition patternParameterDefinition;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
RelatedArtifact patternRelatedArtifact;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
TriggerDefinition patternTriggerDefinition;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
UsageContext patternUsageContext;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Dosage patternDosage;

//  Specifies a value that the value in the instance SHALL follow - that
// is, any value in the pattern must be found in the instance. Other
// additional values may be found too. This is effectively constraint by
// example.   When pattern[x] is used to constrain a primitive, it means
// that the value provided in the pattern[x] must match the instance value
// exactly. When pattern[x] is used to constrain an array, it means that
// each element provided in the pattern[x] array must (recursively) match
// at least one element from the instance array. When pattern[x] is used
// to constrain a complex object, it means that each property in the
// pattern must be present in the complex object, and its value must
// recursively match -- i.e., 1. If primitive: it must match exactly the
// pattern value 2. If a complex object: it must match (recursively) the
// pattern value 3. If an array: it must match (recursively) the pattern
// value.
Meta patternMeta;

//  A sample value for this element demonstrating the type of information
// that would typically be found in the element.
List<ElementDefinition_Example> example;

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String minValueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String minValueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String minValueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String minValueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
double minValueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int minValueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int minValuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int minValueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The minimum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
Quantity minValueQuantity;

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String maxValueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String maxValueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String maxValueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
String maxValueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
double maxValueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int maxValueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int maxValuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
int maxValueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The maximum allowed value for the element. The value is inclusive.
// This is allowed for the types date, dateTime, instant, time, decimal,
// integer, and Quantity.
Quantity maxValueQuantity;

//  Indicates the maximum length in characters that is permitted to be
// present in conformant instances and which is expected to be supported
// by conformant consumers that support the element.
int maxLength;

//  A reference to an invariant that may make additional statements about
// the cardinality or value in the instance.
List<String> condition;

//  Formal constraints such as co-occurrence and other constraints that
// can be computationally evaluated within the context of the instance.
List<ElementDefinition_Constraint> constraint;

//  If true, implementations that produce or consume resources SHALL
// provide "support" for the element in some meaningful way.  If false,
// the element may be ignored and not supported. If false, whether to
// populate or use the data element in any way is at the discretion of the
// implementation.
bool mustSupport;

//  If true, the value of this element affects the interpretation of the
// element or resource that contains it, and the value of the element
// cannot be ignored. Typically, this is used for status, negation and
// qualification codes. The effect of this is that the element cannot be
// ignored by systems: they SHALL either recognize the element and process
// it, and/or a pre-determination has been made that it is not relevant to
// their particular system.
bool isModifier;

//  Explains how that element affects the interpretation of the resource
// or element that contains it.
String isModifierReason;

//  Whether the element should be included if a client requests a search
// with the parameter _summary=true.
bool isSummary;

//  Binds to a value set if this element is coded (code, Coding,
// CodeableConcept, Quantity), or the data types (string, uri).
ElementDefinition_Binding binding;

//  Identifies a concept from an external specification that roughly
// corresponds to this element.
List<ElementDefinition_Mapping> mapping;

ElementDefinition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.representation,
    this.sliceName,
    this.sliceIsConstraining,
    this.label,
    this.code,
    this.slicing,
    this.short,
    this.definition,
    this.comment,
    this.requirements,
    this.alias,
    this.min,
    this.max,
    this.base,
    this.contentReference,
    this.type,
    this.defaultValueBase64Binary,
    this.defaultValueBoolean,
    this.defaultValueCanonical,
    this.defaultValueCode,
    this.defaultValueDate,
    this.defaultValueDateTime,
    this.defaultValueDecimal,
    this.defaultValueId,
    this.defaultValueInstant,
    this.defaultValueInteger,
    this.defaultValueMarkdown,
    this.defaultValueOid,
    this.defaultValuePositiveInt,
    this.defaultValueString,
    this.defaultValueTime,
    this.defaultValueUnsignedInt,
    this.defaultValueUri,
    this.defaultValueUrl,
    this.defaultValueUuid,
    this.defaultValueAddress,
    this.defaultValueAge,
    this.defaultValueAnnotation,
    this.defaultValueAttachment,
    this.defaultValueCodeableConcept,
    this.defaultValueCoding,
    this.defaultValueContactPoint,
    this.defaultValueCount,
    this.defaultValueDistance,
    this.defaultValueDuration,
    this.defaultValueHumanName,
    this.defaultValueIdentifier,
    this.defaultValueMoney,
    this.defaultValuePeriod,
    this.defaultValueQuantity,
    this.defaultValueRange,
    this.defaultValueRatio,
    this.defaultValueReference,
    this.defaultValueSampledData,
    this.defaultValueSignature,
    this.defaultValueTiming,
    this.defaultValueContactDetail,
    this.defaultValueContributor,
    this.defaultValueDataRequirement,
    this.defaultValueExpression,
    this.defaultValueParameterDefinition,
    this.defaultValueRelatedArtifact,
    this.defaultValueTriggerDefinition,
    this.defaultValueUsageContext,
    this.defaultValueDosage,
    this.defaultValueMeta,
    this.meaningWhenMissing,
    this.orderMeaning,
    this.fixedBase64Binary,
    this.fixedBoolean,
    this.fixedCanonical,
    this.fixedCode,
    this.fixedDate,
    this.fixedDateTime,
    this.fixedDecimal,
    this.fixedId,
    this.fixedInstant,
    this.fixedInteger,
    this.fixedMarkdown,
    this.fixedOid,
    this.fixedPositiveInt,
    this.fixedString,
    this.fixedTime,
    this.fixedUnsignedInt,
    this.fixedUri,
    this.fixedUrl,
    this.fixedUuid,
    this.fixedAddress,
    this.fixedAge,
    this.fixedAnnotation,
    this.fixedAttachment,
    this.fixedCodeableConcept,
    this.fixedCoding,
    this.fixedContactPoint,
    this.fixedCount,
    this.fixedDistance,
    this.fixedDuration,
    this.fixedHumanName,
    this.fixedIdentifier,
    this.fixedMoney,
    this.fixedPeriod,
    this.fixedQuantity,
    this.fixedRange,
    this.fixedRatio,
    this.fixedReference,
    this.fixedSampledData,
    this.fixedSignature,
    this.fixedTiming,
    this.fixedContactDetail,
    this.fixedContributor,
    this.fixedDataRequirement,
    this.fixedExpression,
    this.fixedParameterDefinition,
    this.fixedRelatedArtifact,
    this.fixedTriggerDefinition,
    this.fixedUsageContext,
    this.fixedDosage,
    this.fixedMeta,
    this.patternBase64Binary,
    this.patternBoolean,
    this.patternCanonical,
    this.patternCode,
    this.patternDate,
    this.patternDateTime,
    this.patternDecimal,
    this.patternId,
    this.patternInstant,
    this.patternInteger,
    this.patternMarkdown,
    this.patternOid,
    this.patternPositiveInt,
    this.patternString,
    this.patternTime,
    this.patternUnsignedInt,
    this.patternUri,
    this.patternUrl,
    this.patternUuid,
    this.patternAddress,
    this.patternAge,
    this.patternAnnotation,
    this.patternAttachment,
    this.patternCodeableConcept,
    this.patternCoding,
    this.patternContactPoint,
    this.patternCount,
    this.patternDistance,
    this.patternDuration,
    this.patternHumanName,
    this.patternIdentifier,
    this.patternMoney,
    this.patternPeriod,
    this.patternQuantity,
    this.patternRange,
    this.patternRatio,
    this.patternReference,
    this.patternSampledData,
    this.patternSignature,
    this.patternTiming,
    this.patternContactDetail,
    this.patternContributor,
    this.patternDataRequirement,
    this.patternExpression,
    this.patternParameterDefinition,
    this.patternRelatedArtifact,
    this.patternTriggerDefinition,
    this.patternUsageContext,
    this.patternDosage,
    this.patternMeta,
    this.example,
    this.minValueDate,
    this.minValueDateTime,
    this.minValueInstant,
    this.minValueTime,
    this.minValueDecimal,
    this.minValueInteger,
    this.minValuePositiveInt,
    this.minValueUnsignedInt,
    this.minValueQuantity,
    this.maxValueDate,
    this.maxValueDateTime,
    this.maxValueInstant,
    this.maxValueTime,
    this.maxValueDecimal,
    this.maxValueInteger,
    this.maxValuePositiveInt,
    this.maxValueUnsignedInt,
    this.maxValueQuantity,
    this.maxLength,
    this.condition,
    this.constraint,
    this.mustSupport,
    this.isModifier,
    this.isModifierReason,
    this.isSummary,
    this.binding,
    this.mapping,
    });

  factory ElementDefinition.fromJson(Map<String, dynamic> json) => _$ElementDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Slicing {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Designates which child elements are used to discriminate between the
// slices when processing an instance. If one or more discriminators are
// provided, the value of the child elements in the instance data SHALL
// completely distinguish which slice the element in the resource matches
// based on the allowed values for those elements in each of the slices.
List<ElementDefinition_Discriminator> discriminator;

//  A human-readable text description of how the slicing works. If there
// is no discriminator, this is required to be present to provide whatever
// information is possible about how the slices can be differentiated.
String description;

//  If the matching elements have to occur in the same order as defined in
// the profile.
bool ordered;

//  Whether additional slices are allowed or not. When the slices are
// ordered, profile authors can also say that additional slices are only
// allowed at the end.
String rules; // <code> enum: closed/open/openAtEnd;

ElementDefinition_Slicing(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.discriminator,
    this.description,
    this.ordered,
    this.rules,
    });

  factory ElementDefinition_Slicing.fromJson(Map<String, dynamic> json) => _$ElementDefinition_SlicingFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_SlicingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Discriminator {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  How the element value is interpreted when discrimination is evaluated.
String type; // <code> enum: value/exists/pattern/type/profile;

//  A FHIRPath expression, using [the simple subset of
// FHIRPath](fhirpath.html#simple), that is used to identify the element
// on which discrimination is based.
String path;

ElementDefinition_Discriminator(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.path,
    });

  factory ElementDefinition_Discriminator.fromJson(Map<String, dynamic> json) => _$ElementDefinition_DiscriminatorFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_DiscriminatorToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Base {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The Path that identifies the base element - this matches the
// ElementDefinition.path for that element. Across FHIR, there is only one
// base definition of any element - that is, an element definition on a
// [[[StructureDefinition]]] without a StructureDefinition.base.
String path;

//  Minimum cardinality of the base element identified by the path.
int min;

//  Maximum cardinality of the base element identified by the path.
String max;

ElementDefinition_Base(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.min,
    this.max,
    });

  factory ElementDefinition_Base.fromJson(Map<String, dynamic> json) => _$ElementDefinition_BaseFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_BaseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Type {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  URL of Data type or Resource that is a(or the) type used for this
// element. References are URLs that are relative to
// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only
// allowed in logical models.
String code;

//  Identifies a profile structure or implementation Guide that applies to
// the datatype this element refers to. If any profiles are specified,
// then the content must conform to at least one of them. The URL can be a
// local reference - to a contained StructureDefinition, or a reference to
// another StructureDefinition or Implementation Guide by a canonical URL.
// When an implementation guide is specified, the type SHALL conform to at
// least one profile defined in the implementation guide.
List<String> profile;

//  Used when the type is "Reference" or "canonical", and identifies a
// profile structure or implementation Guide that applies to the target of
// the reference this element refers to. If any profiles are specified,
// then the content must conform to at least one of them. The URL can be a
// local reference - to a contained StructureDefinition, or a reference to
// another StructureDefinition or Implementation Guide by a canonical URL.
// When an implementation guide is specified, the target resource SHALL
// conform to at least one profile defined in the implementation guide.
List<String> targetProfile;

//  If the type is a reference to another resource, how the resource is or
// can be aggregated - is it a contained resource, or a reference, and if
// the context is a bundle, is it included in the bundle.
List<String> aggregation; // <code> enum: contained/referenced/bundled> aggregation;

//  Whether this reference needs to be version specific or version
// independent, or whether either can be used.
String versioning; // <code> enum: either/independent/specific;

ElementDefinition_Type(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.profile,
    this.targetProfile,
    this.aggregation,
    this.versioning,
    });

  factory ElementDefinition_Type.fromJson(Map<String, dynamic> json) => _$ElementDefinition_TypeFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_TypeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Example {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the purpose of this example amoung the set of examples.
String label;

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  The actual value for the element, which must be one of the types
// allowed for this element.
bool valueBoolean; //  pattern: ^true|false$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueCanonical; //  pattern: ^\S*$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The actual value for the element, which must be one of the types
// allowed for this element.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The actual value for the element, which must be one of the types
// allowed for this element.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  The actual value for the element, which must be one of the types
// allowed for this element.
int valuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The actual value for the element, which must be one of the types
// allowed for this element.
int valueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueUri; //  pattern: ^\S*$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueUrl; //  pattern: ^\S*$

//  The actual value for the element, which must be one of the types
// allowed for this element.
String valueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  The actual value for the element, which must be one of the types
// allowed for this element.
Address valueAddress;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Age valueAge;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Annotation valueAnnotation;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Attachment valueAttachment;

//  The actual value for the element, which must be one of the types
// allowed for this element.
CodeableConcept valueCodeableConcept;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Coding valueCoding;

//  The actual value for the element, which must be one of the types
// allowed for this element.
ContactPoint valueContactPoint;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Count valueCount;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Distance valueDistance;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Duration valueDuration;

//  The actual value for the element, which must be one of the types
// allowed for this element.
HumanName valueHumanName;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Identifier valueIdentifier;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Money valueMoney;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Period valuePeriod;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Quantity valueQuantity;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Range valueRange;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Ratio valueRatio;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Reference valueReference;

//  The actual value for the element, which must be one of the types
// allowed for this element.
SampledData valueSampledData;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Signature valueSignature;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Timing valueTiming;

//  The actual value for the element, which must be one of the types
// allowed for this element.
ContactDetail valueContactDetail;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Contributor valueContributor;

//  The actual value for the element, which must be one of the types
// allowed for this element.
DataRequirement valueDataRequirement;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Expression valueExpression;

//  The actual value for the element, which must be one of the types
// allowed for this element.
ParameterDefinition valueParameterDefinition;

//  The actual value for the element, which must be one of the types
// allowed for this element.
RelatedArtifact valueRelatedArtifact;

//  The actual value for the element, which must be one of the types
// allowed for this element.
TriggerDefinition valueTriggerDefinition;

//  The actual value for the element, which must be one of the types
// allowed for this element.
UsageContext valueUsageContext;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Dosage valueDosage;

//  The actual value for the element, which must be one of the types
// allowed for this element.
Meta valueMeta;

ElementDefinition_Example(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.label,
    this.valueBase64Binary,
    this.valueBoolean,
    this.valueCanonical,
    this.valueCode,
    this.valueDate,
    this.valueDateTime,
    this.valueDecimal,
    this.valueId,
    this.valueInstant,
    this.valueInteger,
    this.valueMarkdown,
    this.valueOid,
    this.valuePositiveInt,
    this.valueString,
    this.valueTime,
    this.valueUnsignedInt,
    this.valueUri,
    this.valueUrl,
    this.valueUuid,
    this.valueAddress,
    this.valueAge,
    this.valueAnnotation,
    this.valueAttachment,
    this.valueCodeableConcept,
    this.valueCoding,
    this.valueContactPoint,
    this.valueCount,
    this.valueDistance,
    this.valueDuration,
    this.valueHumanName,
    this.valueIdentifier,
    this.valueMoney,
    this.valuePeriod,
    this.valueQuantity,
    this.valueRange,
    this.valueRatio,
    this.valueReference,
    this.valueSampledData,
    this.valueSignature,
    this.valueTiming,
    this.valueContactDetail,
    this.valueContributor,
    this.valueDataRequirement,
    this.valueExpression,
    this.valueParameterDefinition,
    this.valueRelatedArtifact,
    this.valueTriggerDefinition,
    this.valueUsageContext,
    this.valueDosage,
    this.valueMeta,
    });

  factory ElementDefinition_Example.fromJson(Map<String, dynamic> json) => _$ElementDefinition_ExampleFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_ExampleToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Constraint {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Allows identification of which elements have their cardinalities
// impacted by the constraint.  Will not be referenced for constraints
// that do not affect cardinality.
String key;

//  Description of why this constraint is necessary or appropriate.
String requirements;

//  Identifies the impact constraint violation has on the conformance of
// the instance.
String severity; // <code> enum: error/warning;

//  Text that can be used to describe the constraint in messages
// identifying that the constraint has been violated.
String human;

//  A [FHIRPath](fhirpath.html) expression of constraint that can be
// executed to see if this constraint is met.
String expression;

//  An XPath expression of constraint that can be executed to see if this
// constraint is met.
String xpath;

//  A reference to the original source of the constraint, for traceability
// purposes.
String source;

ElementDefinition_Constraint(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.key,
    this.requirements,
    this.severity,
    this.human,
    this.expression,
    this.xpath,
    this.source,
    });

  factory ElementDefinition_Constraint.fromJson(Map<String, dynamic> json) => _$ElementDefinition_ConstraintFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_ConstraintToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Binding {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates the degree of conformance expectations associated with this
// binding - that is, the degree to which the provided value set must be
// adhered to in the instances.
String strength; // <code> enum: required/extensible/preferred/example;

//  Describes the intended use of this particular set of codes.
String description;

//  Refers to the value set that identifies the set of codes the binding
// refers to.
String valueSet;

ElementDefinition_Binding(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.strength,
    this.description,
    this.valueSet,
    });

  factory ElementDefinition_Binding.fromJson(Map<String, dynamic> json) => _$ElementDefinition_BindingFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_BindingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ElementDefinition_Mapping {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An internal reference to the definition of a mapping.
String identity;

//  Identifies the computable language in which mapping.map is expressed.
String language;

//  Expresses what part of the target specification corresponds to this
// element.
String map;

//  Comments that provide information about the mapping or its use.
String comment;

ElementDefinition_Mapping(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identity,
    this.language,
    this.map,
    this.comment,
    });

  factory ElementDefinition_Mapping.fromJson(Map<String, dynamic> json) => _$ElementDefinition_MappingFromJson(json);
  Map<String, dynamic> toJson() => _$ElementDefinition_MappingToJson(this);
}

part 'account.g.dart';

@JsonSerializable(explicitToJson: true)
class Account {

//  This is a Account resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier used to reference the account.  Might or might not
// be intended for human use (e.g. credit card number).
List<Identifier> identifier;

//  Indicates whether the account is presently used/usable or not.
String status; // <code> enum: active/inactive/entered-in-error/on-hold/unknown;

//  Categorizes the account for reporting and searching purposes.
CodeableConcept type;

//  Name used for the account when displaying it to humans in reports,
// etc.
String name;

//  Identifies the entity which incurs the expenses. While the immediate
// recipients of services or goods might be entities related to the
// subject, the expenses were ultimately incurred by the subject of the
// Account.
List<Reference> subject;

//  The date range of services associated with this account.
Period servicePeriod;

//  The party(s) that are responsible for covering the payment of this
// account, and what order should they be applied to the account.
List<Account_Coverage> coverage;

//  Indicates the service area, hospital, department, etc. with
// responsibility for managing the Account.
Reference owner;

//  Provides additional information about what the account tracks and how
// it is used.
String description;

//  The parties responsible for balancing the account if other payment
// options fall short.
List<Account_Guarantor> guarantor;

//  Reference to a parent Account.
Reference partOf;

Account(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.name,
    this.subject,
    this.servicePeriod,
    this.coverage,
    this.owner,
    this.description,
    this.guarantor,
    this.partOf,
    });

  factory Account.fromJson(Map<String, dynamic> json) => _$AccountFromJson(json);
  Map<String, dynamic> toJson() => _$AccountToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Account_Coverage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The party(s) that contribute to payment (or part of) of the charges
// applied to this account (including self-pay). A coverage may only be
// responsible for specific types of charges, and the sequence of the
// coverages in the account could be important when processing billing.
Reference coverage;

//  The priority of the coverage in the context of this account.
int priority;

Account_Coverage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.coverage,
    this.priority,
    });

  factory Account_Coverage.fromJson(Map<String, dynamic> json) => _$Account_CoverageFromJson(json);
  Map<String, dynamic> toJson() => _$Account_CoverageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Account_Guarantor {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The entity who is responsible.
Reference party;

//  A guarantor may be placed on credit hold or otherwise have their role
// temporarily suspended.
bool onHold;

//  The timeframe during which the guarantor accepts responsibility for
// the account.
Period period;

Account_Guarantor(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.party,
    this.onHold,
    this.period,
    });

  factory Account_Guarantor.fromJson(Map<String, dynamic> json) => _$Account_GuarantorFromJson(json);
  Map<String, dynamic> toJson() => _$Account_GuarantorToJson(this);
}

part 'activityDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ActivityDefinition {

//  This is a ActivityDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this activity definition when
// it is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this activity definition is (or will be) published. This URL can be
// the target of a canonical reference. It SHALL remain the same when the
// activity definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this activity definition
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the activity
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the activity definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence. To provide a version consistent with the
// Decision Support Service specification, use the format
// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
// knowledge assets, refer to the Decision Support Service specification.
// Note that a version is required for non-experimental active assets.
String version;

//  A natural language name identifying the activity definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the activity definition.
String title;

//  An explanatory or alternate title for the activity definition giving
// additional information about its content.
String subtitle;

//  The status of this activity definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this activity definition is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  A code or group definition that describes the intended subject of the
// activity being defined.
CodeableConcept subjectCodeableConcept;

//  A code or group definition that describes the intended subject of the
// activity being defined.
Reference subjectReference;

//  The date  (and optionally time) when the activity definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the activity definition changes.
DateTime date;

//  The name of the organization or individual that published the activity
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the activity definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate activity definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the activity definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this activity definition is needed and why it has
// been designed as it has.
String purpose;

//  A detailed description of how the activity definition is used from a
// clinical perspective.
String usage;

//  A copyright statement relating to the activity definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the activity definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the activity definition content was or is
// planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the activity. Topics
// provide a high-level categorization of the activity that can be useful
// for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a Library resource containing any formal logic used by
// the activity definition.
List<String> library;

//  A description of the kind of resource the activity definition is
// representing. For example, a MedicationRequest, a ServiceRequest, or a
// CommunicationRequest. Typically, but not always, this is a Request
// resource.
String kind;

//  A profile to which the target of the activity definition is expected
// to conform.
String profile;

//  Detailed description of the type of activity; e.g. What lab test, what
// procedure, what kind of encounter.
CodeableConcept code;

//  Indicates the level of authority/intentionality associated with the
// activity and where the request should fit into the workflow chain.
String intent;

//  Indicates how quickly the activity  should be addressed with respect
// to other requests.
String priority;

//  Set this to true if the definition is to indicate that a particular
// activity should NOT be performed. If true, this element should be
// interpreted to reinforce a negative coding. For example NPO as a code
// with a doNotPerform of true would still indicate to NOT perform the
// action.
bool doNotPerform;

//  The period, timing or frequency upon which the described activity is
// to occur.
Timing timingTiming;

//  The period, timing or frequency upon which the described activity is
// to occur.
String timingDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The period, timing or frequency upon which the described activity is
// to occur.
Age timingAge;

//  The period, timing or frequency upon which the described activity is
// to occur.
Period timingPeriod;

//  The period, timing or frequency upon which the described activity is
// to occur.
Range timingRange;

//  The period, timing or frequency upon which the described activity is
// to occur.
Duration timingDuration;

//  Identifies the facility where the activity will occur; e.g. home,
// hospital, specific clinic, etc.
Reference location;

//  Indicates who should participate in performing the action described.
List<ActivityDefinition_Participant> participant;

//  Identifies the food, drug or other product being consumed or supplied
// in the activity.
Reference productReference;

//  Identifies the food, drug or other product being consumed or supplied
// in the activity.
CodeableConcept productCodeableConcept;

//  Identifies the quantity expected to be consumed at once (per dose, per
// meal, etc.).
Quantity quantity;

//  Provides detailed dosage instructions in the same way that they are
// described for MedicationRequest resources.
List<Dosage> dosage;

//  Indicates the sites on the subject's body where the procedure should
// be performed (I.e. the target sites).
List<CodeableConcept> bodySite;

//  Defines specimen requirements for the action to be performed, such as
// required specimens for a lab test.
List<Reference> specimenRequirement;

//  Defines observation requirements for the action to be performed, such
// as body weight or surface area.
List<Reference> observationRequirement;

//  Defines the observations that are expected to be produced by the
// action.
List<Reference> observationResultRequirement;

//  A reference to a StructureMap resource that defines a transform that
// can be executed to produce the intent resource using the
// ActivityDefinition instance as the input.
String transform;

//  Dynamic values that will be evaluated to produce values for elements
// of the resulting resource. For example, if the dosage of a medication
// must be computed based on the patient's weight, a dynamic value would
// be used to specify an expression that calculated the weight, and the
// path on the request resource that would contain the result.
List<ActivityDefinition_DynamicValue> dynamicValue;

ActivityDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.subtitle,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.library,
    this.kind,
    this.profile,
    this.code,
    this.intent,
    this.priority,
    this.doNotPerform,
    this.timingTiming,
    this.timingDateTime,
    this.timingAge,
    this.timingPeriod,
    this.timingRange,
    this.timingDuration,
    this.location,
    this.participant,
    this.productReference,
    this.productCodeableConcept,
    this.quantity,
    this.dosage,
    this.bodySite,
    this.specimenRequirement,
    this.observationRequirement,
    this.observationResultRequirement,
    this.transform,
    this.dynamicValue,
    });

  factory ActivityDefinition.fromJson(Map<String, dynamic> json) => _$ActivityDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ActivityDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ActivityDefinition_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of participant in the action.
String type;

//  The role the participant should play in performing the described
// action.
CodeableConcept role;

ActivityDefinition_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.role,
    });

  factory ActivityDefinition_Participant.fromJson(Map<String, dynamic> json) => _$ActivityDefinition_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$ActivityDefinition_ParticipantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ActivityDefinition_DynamicValue {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The path to the element to be customized. This is the path on the
// resource that will hold the result of the calculation defined by the
// expression. The specified path SHALL be a FHIRPath resolveable on the
// specified target type of the ActivityDefinition, and SHALL consist only
// of identifiers, constant indexers, and a restricted subset of
// functions. The path is allowed to contain qualifiers (.) to traverse
// sub-elements, as well as indexers ([x]) to traverse
// multiple-cardinality sub-elements (see the [Simple FHIRPath
// Profile](fhirpath.html#simple) for full details).
String path;

//  An expression specifying the value of the customized element.
Expression expression;

ActivityDefinition_DynamicValue(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.expression,
    });

  factory ActivityDefinition_DynamicValue.fromJson(Map<String, dynamic> json) => _$ActivityDefinition_DynamicValueFromJson(json);
  Map<String, dynamic> toJson() => _$ActivityDefinition_DynamicValueToJson(this);
}

part 'adverseEvent.g.dart';

@JsonSerializable(explicitToJson: true)
class AdverseEvent {

//  This is a AdverseEvent resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this adverse event by the performer
// or other systems which remain constant as the resource is updated and
// propagates from server to server.
Identifier identifier;

//  Whether the event actually happened, or just had the potential to.
// Note that this is independent of whether anyone was affected or harmed
// or how severely.
String actuality; // <code> enum: actual/potential;

//  The overall type of event, intended for search and filtering purposes.
List<CodeableConcept> category;

//  This element defines the specific type of event that occurred or that
// was prevented from occurring.
CodeableConcept event;

//  This subject or group impacted by the event.
Reference subject;

//  The Encounter during which AdverseEvent was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  The date (and perhaps time) when the adverse event occurred.
DateTime date;

//  Estimated or actual date the AdverseEvent began, in the opinion of the
// reporter.
DateTime detected;

//  The date on which the existence of the AdverseEvent was first
// recorded.
DateTime recordedDate;

//  Includes information about the reaction that occurred as a result of
// exposure to a substance (for example, a drug or a chemical).
List<Reference> resultingCondition;

//  The information about where the adverse event occurred.
Reference location;

//  Assessment whether this event was of real importance.
CodeableConcept seriousness;

//  Describes the severity of the adverse event, in relation to the
// subject. Contrast to AdverseEvent.seriousness - a severe rash might not
// be serious, but a mild heart problem is.
CodeableConcept severity;

//  Describes the type of outcome from the adverse event.
CodeableConcept outcome;

//  Information on who recorded the adverse event.  May be the patient or
// a practitioner.
Reference recorder;

//  Parties that may or should contribute or have contributed information
// to the adverse event, which can consist of one or more activities. 
// Such information includes information leading to the decision to
// perform the activity and how to perform the activity (e.g. consultant),
// information that the activity itself seeks to reveal (e.g. informant of
// clinical history), or information about what activity was performed
// (e.g. informant witness).
List<Reference> contributor;

//  Describes the entity that is suspected to have caused the adverse
// event.
List<AdverseEvent_SuspectEntity> suspectEntity;

//  AdverseEvent.subjectMedicalHistory.
List<Reference> subjectMedicalHistory;

//  AdverseEvent.referenceDocument.
List<Reference> referenceDocument;

//  AdverseEvent.study.
List<Reference> study;

AdverseEvent(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.actuality,
    this.category,
    this.event,
    this.subject,
    this.encounter,
    this.date,
    this.detected,
    this.recordedDate,
    this.resultingCondition,
    this.location,
    this.seriousness,
    this.severity,
    this.outcome,
    this.recorder,
    this.contributor,
    this.suspectEntity,
    this.subjectMedicalHistory,
    this.referenceDocument,
    this.study,
    });

  factory AdverseEvent.fromJson(Map<String, dynamic> json) => _$AdverseEventFromJson(json);
  Map<String, dynamic> toJson() => _$AdverseEventToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AdverseEvent_SuspectEntity {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies the actual instance of what caused the adverse event.  May
// be a substance, medication, medication administration, medication
// statement or a device.
Reference instance;

//  Information on the possible cause of the event.
List<AdverseEvent_Causality> causality;

AdverseEvent_SuspectEntity(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.instance,
    this.causality,
    });

  factory AdverseEvent_SuspectEntity.fromJson(Map<String, dynamic> json) => _$AdverseEvent_SuspectEntityFromJson(json);
  Map<String, dynamic> toJson() => _$AdverseEvent_SuspectEntityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AdverseEvent_Causality {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Assessment of if the entity caused the event.
CodeableConcept assessment;

//  AdverseEvent.suspectEntity.causalityProductRelatedness.
String productRelatedness;

//  AdverseEvent.suspectEntity.causalityAuthor.
Reference author;

//  ProbabilityScale | Bayesian | Checklist.
CodeableConcept method;

AdverseEvent_Causality(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.assessment,
    this.productRelatedness,
    this.author,
    this.method,
    });

  factory AdverseEvent_Causality.fromJson(Map<String, dynamic> json) => _$AdverseEvent_CausalityFromJson(json);
  Map<String, dynamic> toJson() => _$AdverseEvent_CausalityToJson(this);
}

part 'allergyIntolerance.g.dart';

@JsonSerializable(explicitToJson: true)
class AllergyIntolerance {

//  This is a AllergyIntolerance resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this AllergyIntolerance by the
// performer or other systems which remain constant as the resource is
// updated and propagates from server to server.
List<Identifier> identifier;

//  The clinical status of the allergy or intolerance.
CodeableConcept clinicalStatus;

//  Assertion about certainty associated with the propensity, or potential
// risk, of a reaction to the identified substance (including
// pharmaceutical product).
CodeableConcept verificationStatus;

//  Identification of the underlying physiological mechanism for the
// reaction risk.
String type; // <code> enum: allergy/intolerance;

//  Category of the identified substance.
List<String> category; // <code> enum: food/medication/environment/biologic> category;

//  Estimate of the potential clinical harm, or seriousness, of the
// reaction to the identified substance.
String criticality; // <code> enum: low/high/unable-to-assess;

//  Code for an allergy or intolerance statement (either a positive or a
// negated/excluded statement).  This may be a code for a substance or
// pharmaceutical product that is considered to be responsible for the
// adverse reaction risk (e.g., "Latex"), an allergy or intolerance
// condition (e.g., "Latex allergy"), or a negated/excluded code for a
// specific substance or class (e.g., "No latex allergy") or a general or
// categorical negated statement (e.g.,  "No known allergy", "No known
// drug allergies").  Note: the substance for a specific reaction may be
// different from the substance identified as the cause of the risk, but
// it must be consistent with it. For instance, it may be a more specific
// substance (e.g. a brand medication) or a composite product that
// includes the identified substance. It must be clinically safe to only
// process the 'code' and ignore the 'reaction.substance'.  If a receiving
// system is unable to confirm that AllergyIntolerance.reaction.substance
// falls within the semantic scope of AllergyIntolerance.code, then the
// receiving system should ignore AllergyIntolerance.reaction.substance.
CodeableConcept code;

//  The patient who has the allergy or intolerance.
Reference patient;

//  The encounter when the allergy or intolerance was asserted.
Reference encounter;

//  Estimated or actual date,  date-time, or age when allergy or
// intolerance was identified.
String onsetDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Estimated or actual date,  date-time, or age when allergy or
// intolerance was identified.
Age onsetAge;

//  Estimated or actual date,  date-time, or age when allergy or
// intolerance was identified.
Period onsetPeriod;

//  Estimated or actual date,  date-time, or age when allergy or
// intolerance was identified.
Range onsetRange;

//  Estimated or actual date,  date-time, or age when allergy or
// intolerance was identified.
String onsetString; //  pattern: ^[ \r\n\t\S]+$

//  The recordedDate represents when this particular AllergyIntolerance
// record was created in the system, which is often a system-generated
// date.
DateTime recordedDate;

//  Individual who recorded the record and takes responsibility for its
// content.
Reference recorder;

//  The source of the information about the allergy that is recorded.
Reference asserter;

//  Represents the date and/or time of the last known occurrence of a
// reaction event.
DateTime lastOccurrence;

//  Additional narrative about the propensity for the Adverse Reaction,
// not captured in other fields.
List<Annotation> note;

//  Details about each adverse reaction event linked to exposure to the
// identified substance.
List<AllergyIntolerance_Reaction> reaction;

AllergyIntolerance(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.clinicalStatus,
    this.verificationStatus,
    this.type,
    this.category,
    this.criticality,
    this.code,
    this.patient,
    this.encounter,
    this.onsetDateTime,
    this.onsetAge,
    this.onsetPeriod,
    this.onsetRange,
    this.onsetString,
    this.recordedDate,
    this.recorder,
    this.asserter,
    this.lastOccurrence,
    this.note,
    this.reaction,
    });

  factory AllergyIntolerance.fromJson(Map<String, dynamic> json) => _$AllergyIntoleranceFromJson(json);
  Map<String, dynamic> toJson() => _$AllergyIntoleranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AllergyIntolerance_Reaction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identification of the specific substance (or pharmaceutical product)
// considered to be responsible for the Adverse Reaction event. Note: the
// substance for a specific reaction may be different from the substance
// identified as the cause of the risk, but it must be consistent with it.
// For instance, it may be a more specific substance (e.g. a brand
// medication) or a composite product that includes the identified
// substance. It must be clinically safe to only process the 'code' and
// ignore the 'reaction.substance'.  If a receiving system is unable to
// confirm that AllergyIntolerance.reaction.substance falls within the
// semantic scope of AllergyIntolerance.code, then the receiving system
// should ignore AllergyIntolerance.reaction.substance.
CodeableConcept substance;

//  Clinical symptoms and/or signs that are observed or associated with
// the adverse reaction event.
List<CodeableConcept> manifestation;

//  Text description about the reaction as a whole, including details of
// the manifestation if required.
String description;

//  Record of the date and/or time of the onset of the Reaction.
DateTime onset;

//  Clinical assessment of the severity of the reaction event as a whole,
// potentially considering multiple different manifestations.
String severity; // <code> enum: mild/moderate/severe;

//  Identification of the route by which the subject was exposed to the
// substance.
CodeableConcept exposureRoute;

//  Additional text about the adverse reaction event not captured in other
// fields.
List<Annotation> note;

AllergyIntolerance_Reaction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.substance,
    this.manifestation,
    this.description,
    this.onset,
    this.severity,
    this.exposureRoute,
    this.note,
    });

  factory AllergyIntolerance_Reaction.fromJson(Map<String, dynamic> json) => _$AllergyIntolerance_ReactionFromJson(json);
  Map<String, dynamic> toJson() => _$AllergyIntolerance_ReactionToJson(this);
}

part 'appointment.g.dart';

@JsonSerializable(explicitToJson: true)
class Appointment {

//  This is a Appointment resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  This records identifiers associated with this appointment concern that
// are defined by business processes and/or used to refer to it when a
// direct URL reference to the resource itself is not appropriate (e.g. in
// CDA documents, or in written / printed documentation).
List<Identifier> identifier;

//  The overall status of the Appointment. Each of the participants has
// their own participation status which indicates their involvement in the
// process, however this status indicates the shared status.
String status; // <code> enum: proposed/pending/booked/arrived/fulfilled/cancelled/noshow/entered-in-error/checked-in/waitlist;

//  The coded reason for the appointment being cancelled. This is often
// used in reporting/billing/futher processing to determine if further
// actions are required, or specific fees apply.
CodeableConcept cancelationReason;

//  A broad categorization of the service that is to be performed during
// this appointment.
List<CodeableConcept> serviceCategory;

//  The specific service that is to be performed during this appointment.
List<CodeableConcept> serviceType;

//  The specialty of a practitioner that would be required to perform the
// service requested in this appointment.
List<CodeableConcept> specialty;

//  The style of appointment or patient that has been booked in the slot
// (not service type).
CodeableConcept appointmentType;

//  The coded reason that this appointment is being scheduled. This is
// more clinical than administrative.
List<CodeableConcept> reasonCode;

//  Reason the appointment has been scheduled to take place, as specified
// using information from another resource. When the patient arrives and
// the encounter begins it may be used as the admission diagnosis. The
// indication will typically be a Condition (with other resources
// referenced in the evidence.detail), or a Procedure.
List<Reference> reasonReference;

//  The priority of the appointment. Can be used to make informed
// decisions if needing to re-prioritize appointments. (The iCal Standard
// specifies 0 as undefined, 1 as highest, 9 as lowest priority).
int priority;

//  The brief description of the appointment as would be shown on a
// subject line in a meeting request, or appointment list. Detailed or
// expanded information should be put in the comment field.
String description;

//  Additional information to support the appointment provided when making
// the appointment.
List<Reference> supportingInformation;

//  Date/Time that the appointment is to take place.
DateTime start;

//  Date/Time that the appointment is to conclude.
DateTime end;

//  Number of minutes that the appointment is to take. This can be less
// than the duration between the start and end times.  For example, where
// the actual time of appointment is only an estimate or if a 30 minute
// appointment is being requested, but any time would work.  Also, if
// there is, for example, a planned 15 minute break in the middle of a
// long appointment, the duration may be 15 minutes less than the
// difference between the start and end.
int minutesDuration;

//  The slots from the participants' schedules that will be filled by the
// appointment.
List<Reference> slot;

//  The date that this appointment was initially created. This could be
// different to the meta.lastModified value on the initial entry, as this
// could have been before the resource was created on the FHIR server, and
// should remain unchanged over the lifespan of the appointment.
DateTime created;

//  Additional comments about the appointment.
String comment;

//  While Appointment.comment contains information for internal use,
// Appointment.patientInstructions is used to capture patient facing
// information about the Appointment (e.g. please bring your referral or
// fast from 8pm night before).
String patientInstruction;

//  The service request this appointment is allocated to assess (e.g.
// incoming referral or procedure request).
List<Reference> basedOn;

//  List of participants involved in the appointment.
List<Appointment_Participant> participant;

//  A set of date ranges (potentially including times) that the
// appointment is preferred to be scheduled within. The duration (usually
// in minutes) could also be provided to indicate the length of the
// appointment to fill and populate the start/end times for the actual
// allocated time. However, in other situations the duration may be
// calculated by the scheduling system.
List<Period> requestedPeriod;

Appointment(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.cancelationReason,
    this.serviceCategory,
    this.serviceType,
    this.specialty,
    this.appointmentType,
    this.reasonCode,
    this.reasonReference,
    this.priority,
    this.description,
    this.supportingInformation,
    this.start,
    this.end,
    this.minutesDuration,
    this.slot,
    this.created,
    this.comment,
    this.patientInstruction,
    this.basedOn,
    this.participant,
    this.requestedPeriod,
    });

  factory Appointment.fromJson(Map<String, dynamic> json) => _$AppointmentFromJson(json);
  Map<String, dynamic> toJson() => _$AppointmentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Appointment_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Role of participant in the appointment.
List<CodeableConcept> type;

//  A Person, Location/HealthcareService or Device that is participating
// in the appointment.
Reference actor;

//  Whether this participant is required to be present at the meeting.
// This covers a use-case where two doctors need to meet to discuss the
// results for a specific patient, and the patient is not required to be
// present.
String required; // <code> enum: required/optional/information-only;

//  Participation status of the actor.
String status; // <code> enum: accepted/declined/tentative/needs-action;

//  Participation period of the actor.
Period period;

Appointment_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.actor,
    this.required,
    this.status,
    this.period,
    });

  factory Appointment_Participant.fromJson(Map<String, dynamic> json) => _$Appointment_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$Appointment_ParticipantToJson(this);
}

part 'appointmentResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class AppointmentResponse {

//  This is a AppointmentResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  This records identifiers associated with this appointment response
// concern that are defined by business processes and/ or used to refer to
// it when a direct URL reference to the resource itself is not
// appropriate.
List<Identifier> identifier;

//  Appointment that this response is replying to.
Reference appointment;

//  Date/Time that the appointment is to take place, or requested new
// start time.
DateTime start;

//  This may be either the same as the appointment request to confirm the
// details of the appointment, or alternately a new time to request a
// re-negotiation of the end time.
DateTime end;

//  Role of participant in the appointment.
List<CodeableConcept> participantType;

//  A Person, Location, HealthcareService, or Device that is participating
// in the appointment.
Reference actor;

//  Participation status of the participant. When the status is declined
// or tentative if the start/end times are different to the appointment,
// then these times should be interpreted as a requested time change. When
// the status is accepted, the times can either be the time of the
// appointment (as a confirmation of the time) or can be empty.
String participantStatus;

//  Additional comments about the appointment.
String comment;

AppointmentResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.appointment,
    this.start,
    this.end,
    this.participantType,
    this.actor,
    this.participantStatus,
    this.comment,
    });

  factory AppointmentResponse.fromJson(Map<String, dynamic> json) => _$AppointmentResponseFromJson(json);
  Map<String, dynamic> toJson() => _$AppointmentResponseToJson(this);
}

part 'auditEvent.g.dart';

@JsonSerializable(explicitToJson: true)
class AuditEvent {

//  This is a AuditEvent resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for a family of the event.  For example, a menu item,
// program, rule, policy, function code, application name or URL. It
// identifies the performed function.
Coding type;

//  Identifier for the category of event.
List<Coding> subtype;

//  Indicator for type of action performed during the event that generated
// the audit.
String action; // <code> enum: C/R/U/D/E;

//  The period during which the activity occurred.
Period period;

//  The time when the event was recorded.
DateTime recorded;

//  Indicates whether the event succeeded or failed.
String outcome; // <code> enum: 0/4/8/12;

//  A free text description of the outcome of the event.
String outcomeDesc;

//  The purposeOfUse (reason) that was used during the event being
// recorded.
List<CodeableConcept> purposeOfEvent;

//  An actor taking an active role in the event or activity that is
// logged.
List<AuditEvent_Agent> agent;

//  The system that is reporting the event.
AuditEvent_Source source;

//  Specific instances of data or objects that have been accessed.
List<AuditEvent_Entity> entity;

AuditEvent(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.type,
    this.subtype,
    this.action,
    this.period,
    this.recorded,
    this.outcome,
    this.outcomeDesc,
    this.purposeOfEvent,
    this.agent,
    this.source,
    this.entity,
    });

  factory AuditEvent.fromJson(Map<String, dynamic> json) => _$AuditEventFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEventToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AuditEvent_Agent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specification of the participation type the user plays when performing
// the event.
CodeableConcept type;

//  The security role that the user was acting under, that come from local
// codes defined by the access control security system (e.g. RBAC, ABAC)
// used in the local context.
List<CodeableConcept> role;

//  Reference to who this agent is that was involved in the event.
Reference who;

//  Alternative agent Identifier. For a human, this should be a user
// identifier text string from authentication system. This identifier
// would be one known to a common authentication system (e.g. single
// sign-on), if available.
String altId;

//  Human-meaningful name for the agent.
String name;

//  Indicator that the user is or is not the requestor, or initiator, for
// the event being audited.
bool requestor;

//  Where the event occurred.
Reference location;

//  The policy or plan that authorized the activity being recorded.
// Typically, a single activity may have multiple applicable policies,
// such as patient consent, guarantor funding, etc. The policy would also
// indicate the security token used.
List<String> policy;

//  Type of media involved. Used when the event is about
// exporting/importing onto media.
Coding media;

//  Logical network location for application activity, if the activity has
// a network location.
AuditEvent_Network network;

//  The reason (purpose of use), specific to this agent, that was used
// during the event being recorded.
List<CodeableConcept> purposeOfUse;

AuditEvent_Agent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.role,
    this.who,
    this.altId,
    this.name,
    this.requestor,
    this.location,
    this.policy,
    this.media,
    this.network,
    this.purposeOfUse,
    });

  factory AuditEvent_Agent.fromJson(Map<String, dynamic> json) => _$AuditEvent_AgentFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEvent_AgentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AuditEvent_Network {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier for the network access point of the user device for the
// audit event.
String address;

//  An identifier for the type of network access point that originated the
// audit event.
String type; // <code> enum: 1/2/3/4/5;

AuditEvent_Network(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.address,
    this.type,
    });

  factory AuditEvent_Network.fromJson(Map<String, dynamic> json) => _$AuditEvent_NetworkFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEvent_NetworkToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AuditEvent_Source {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Logical source location within the healthcare enterprise network.  For
// example, a hospital or other provider location within a multi-entity
// provider group.
String site;

//  Identifier of the source where the event was detected.
Reference observer;

//  Code specifying the type of source where event originated.
List<Coding> type;

AuditEvent_Source(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.site,
    this.observer,
    this.type,
    });

  factory AuditEvent_Source.fromJson(Map<String, dynamic> json) => _$AuditEvent_SourceFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEvent_SourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AuditEvent_Entity {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies a specific instance of the entity. The reference should be
// version specific.
Reference what;

//  The type of the object that was involved in this audit event.
Coding type;

//  Code representing the role the entity played in the event being
// audited.
Coding role;

//  Identifier for the data life-cycle stage for the entity.
Coding lifecycle;

//  Security labels for the identified entity.
List<Coding> securityLabel;

//  A name of the entity in the audit event.
String name;

//  Text that describes the entity in more detail.
String description;

//  The query parameters for a query-type entities.
String query;

//  Tagged value pairs for conveying additional information about the
// entity.
List<AuditEvent_Detail> detail;

AuditEvent_Entity(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.what,
    this.type,
    this.role,
    this.lifecycle,
    this.securityLabel,
    this.name,
    this.description,
    this.query,
    this.detail,
    });

  factory AuditEvent_Entity.fromJson(Map<String, dynamic> json) => _$AuditEvent_EntityFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEvent_EntityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class AuditEvent_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of extra detail provided in the value.
String type;

//  The  value of the extra detail.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The  value of the extra detail.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

AuditEvent_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueString,
    this.valueBase64Binary,
    });

  factory AuditEvent_Detail.fromJson(Map<String, dynamic> json) => _$AuditEvent_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$AuditEvent_DetailToJson(this);
}

part 'basic.g.dart';

@JsonSerializable(explicitToJson: true)
class Basic {

//  This is a Basic resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier assigned to the resource for business purposes, outside the
// context of FHIR.
List<Identifier> identifier;

//  Identifies the 'type' of resource - equivalent to the resource name
// for other resources.
CodeableConcept code;

//  Identifies the patient, practitioner, device or any other resource
// that is the "focus" of this resource.
Reference subject;

//  Identifies when the resource was first created.
String created;

//  Indicates who was responsible for creating the resource instance.
Reference author;

Basic(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.code,
    this.subject,
    this.created,
    this.author,
    });

  factory Basic.fromJson(Map<String, dynamic> json) => _$BasicFromJson(json);
  Map<String, dynamic> toJson() => _$BasicToJson(this);
}

part 'binary.g.dart';

@JsonSerializable(explicitToJson: true)
class Binary {

//  This is a Binary resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  MimeType of the binary content represented as a standard MimeType (BCP
// 13).
String contentType;

//  This element identifies another resource that can be used as a proxy
// of the security sensitivity to use when deciding and enforcing access
// control rules for the Binary resource. Given that the Binary resource
// contains very few elements that can be used to determine the
// sensitivity of the data and relationships to individuals, the
// referenced resource stands in as a proxy equivalent for this purpose.
// This referenced resource may be related to the Binary (e.g. Media,
// DocumentReference), or may be some non-related Resource purely as a
// security proxy. E.g. to identify that the binary resource relates to a
// patient, and access should only be granted to applications that have
// access to the patient.
Reference securityContext;

//  The actual content, base64 encoded.
String data;

Binary(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.contentType,
    this.securityContext,
    this.data,
    });

  factory Binary.fromJson(Map<String, dynamic> json) => _$BinaryFromJson(json);
  Map<String, dynamic> toJson() => _$BinaryToJson(this);
}

part 'biologicallyDerivedProduct.g.dart';

@JsonSerializable(explicitToJson: true)
class BiologicallyDerivedProduct {

//  This is a BiologicallyDerivedProduct resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  This records identifiers associated with this biologically derived
// product instance that are defined by business processes and/or used to
// refer to it when a direct URL reference to the resource itself is not
// appropriate (e.g. in CDA documents, or in written / printed
// documentation).
List<Identifier> identifier;

//  Broad category of this product.
String productCategory; // <code> enum: organ/tissue/fluid/cells/biologicalAgent;

//  A code that identifies the kind of this biologically derived product
// (SNOMED Ctcode).
CodeableConcept productCode;

//  Whether the product is currently available.
String status; // <code> enum: available/unavailable;

//  Procedure request to obtain this biologically derived product.
List<Reference> request;

//  Number of discrete units within this product.
int quantity;

//  Parent product (if any).
List<Reference> parent;

//  How this product was collected.
BiologicallyDerivedProduct_Collection collection;

//  Any processing of the product during collection that does not change
// the fundamental nature of the product. For example adding
// anti-coagulants during the collection of Peripheral Blood Stem Cells.
List<BiologicallyDerivedProduct_Processing> processing;

//  Any manipulation of product post-collection that is intended to alter
// the product.  For example a buffy-coat enrichment or CD8 reduction of
// Peripheral Blood Stem Cells to make it more suitable for infusion.
BiologicallyDerivedProduct_Manipulation manipulation;

//  Product storage.
List<BiologicallyDerivedProduct_Storage> storage;

BiologicallyDerivedProduct(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.productCategory,
    this.productCode,
    this.status,
    this.request,
    this.quantity,
    this.parent,
    this.collection,
    this.processing,
    this.manipulation,
    this.storage,
    });

  factory BiologicallyDerivedProduct.fromJson(Map<String, dynamic> json) => _$BiologicallyDerivedProductFromJson(json);
  Map<String, dynamic> toJson() => _$BiologicallyDerivedProductToJson(this);
}

@JsonSerializable(explicitToJson: true)
class BiologicallyDerivedProduct_Collection {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Healthcare professional who is performing the collection.
Reference collector;

//  The patient or entity, such as a hospital or vendor in the case of a
// processed/manipulated/manufactured product, providing the product.
Reference source;

//  Time of product collection.
String collectedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Time of product collection.
Period collectedPeriod;

BiologicallyDerivedProduct_Collection(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.collector,
    this.source,
    this.collectedDateTime,
    this.collectedPeriod,
    });

  factory BiologicallyDerivedProduct_Collection.fromJson(Map<String, dynamic> json) => _$BiologicallyDerivedProduct_CollectionFromJson(json);
  Map<String, dynamic> toJson() => _$BiologicallyDerivedProduct_CollectionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class BiologicallyDerivedProduct_Processing {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Description of of processing.
String description;

//  Procesing code.
CodeableConcept procedure;

//  Substance added during processing.
Reference additive;

//  Time of processing.
String timeDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Time of processing.
Period timePeriod;

BiologicallyDerivedProduct_Processing(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.procedure,
    this.additive,
    this.timeDateTime,
    this.timePeriod,
    });

  factory BiologicallyDerivedProduct_Processing.fromJson(Map<String, dynamic> json) => _$BiologicallyDerivedProduct_ProcessingFromJson(json);
  Map<String, dynamic> toJson() => _$BiologicallyDerivedProduct_ProcessingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class BiologicallyDerivedProduct_Manipulation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Description of manipulation.
String description;

//  Time of manipulation.
String timeDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Time of manipulation.
Period timePeriod;

BiologicallyDerivedProduct_Manipulation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.timeDateTime,
    this.timePeriod,
    });

  factory BiologicallyDerivedProduct_Manipulation.fromJson(Map<String, dynamic> json) => _$BiologicallyDerivedProduct_ManipulationFromJson(json);
  Map<String, dynamic> toJson() => _$BiologicallyDerivedProduct_ManipulationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class BiologicallyDerivedProduct_Storage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Description of storage.
String description;

//  Storage temperature.
double temperature;

//  Temperature scale used.
String scale; // <code> enum: farenheit/celsius/kelvin;

//  Storage timeperiod.
Period duration;

BiologicallyDerivedProduct_Storage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.temperature,
    this.scale,
    this.duration,
    });

  factory BiologicallyDerivedProduct_Storage.fromJson(Map<String, dynamic> json) => _$BiologicallyDerivedProduct_StorageFromJson(json);
  Map<String, dynamic> toJson() => _$BiologicallyDerivedProduct_StorageToJson(this);
}

part 'bodyStructure.g.dart';

@JsonSerializable(explicitToJson: true)
class BodyStructure {

//  This is a BodyStructure resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for this instance of the anatomical structure.
List<Identifier> identifier;

//  Whether this body site is in active use.
bool active;

//  The kind of structure being represented by the body structure at
// `BodyStructure.location`.  This can define both normal and abnormal
// morphologies.
CodeableConcept morphology;

//  The anatomical location or region of the specimen, lesion, or body
// structure.
CodeableConcept location;

//  Qualifier to refine the anatomical location.  These include qualifiers
// for laterality, relative location, directionality, number, and plane.
List<CodeableConcept> locationQualifier;

//  A summary, characterization or explanation of the body structure.
String description;

//  Image or images used to identify a location.
List<Attachment> image;

//  The person to which the body site belongs.
Reference patient;

BodyStructure(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.morphology,
    this.location,
    this.locationQualifier,
    this.description,
    this.image,
    this.patient,
    });

  factory BodyStructure.fromJson(Map<String, dynamic> json) => _$BodyStructureFromJson(json);
  Map<String, dynamic> toJson() => _$BodyStructureToJson(this);
}

part 'bundle.g.dart';

@JsonSerializable(explicitToJson: true)
class Bundle {

//  This is a Bundle resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A persistent identifier for the bundle that won't change as a bundle
// is copied from server to server.
Identifier identifier;

//  Indicates the purpose of this bundle - how it is intended to be used.
String type; // <code> enum: document/message/transaction/transaction-response/batch/batch-response/history/searchset/collection;

//  The date/time that the bundle was assembled - i.e. when the resources
// were placed in the bundle.
DateTime timestamp;

//  If a set of search matches, this is the total number of entries of
// type 'match' across all pages in the search.  It does not include
// search.mode = 'include' or 'outcome' entries and it does not provide a
// count of the number of entries in the Bundle.
int total;

//  A series of links that provide context to this bundle.
List<Bundle_Link> link;

//  An entry in a bundle resource - will either contain a resource or
// information about a resource (transactions and history only).
List<Bundle_Entry> entry;

//  Digital Signature - base64 encoded. XML-DSig or a JWT.
Signature signature;

Bundle(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.identifier,
    this.type,
    this.timestamp,
    this.total,
    this.link,
    this.entry,
    this.signature,
    });

  factory Bundle.fromJson(Map<String, dynamic> json) => _$BundleFromJson(json);
  Map<String, dynamic> toJson() => _$BundleToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Bundle_Link {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A name which details the functional use for this link - see
// [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
String relation;

//  The reference details for the link.
String url;

Bundle_Link(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.relation,
    this.url,
    });

  factory Bundle_Link.fromJson(Map<String, dynamic> json) => _$Bundle_LinkFromJson(json);
  Map<String, dynamic> toJson() => _$Bundle_LinkToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Bundle_Entry {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A series of links that provide context to this entry.
List<Bundle_Link> link;

//  The Absolute URL for the resource.  The fullUrl SHALL NOT disagree
// with the id in the resource - i.e. if the fullUrl is not a urn:uuid,
// the URL shall be version-independent URL consistent with the
// Resource.id. The fullUrl is a version independent reference to the
// resource. The fullUrl element SHALL have a value except that:  *
// fullUrl can be empty on a POST (although it does not need to when
// specifying a temporary id for reference in the bundle) * Results from
// operations might involve resources that are not identified.
String fullUrl;

//  The Resource for the entry. The purpose/meaning of the resource is
// determined by the Bundle.type.
ResourceList resource;

//  Information about the search process that lead to the creation of this
// entry.
Bundle_Search search;

//  Additional information about how this entry should be processed as
// part of a transaction or batch.  For history, it shows how the entry
// was processed to create the version contained in the entry.
Bundle_Request request;

//  Indicates the results of processing the corresponding 'request' entry
// in the batch or transaction being responded to or what the results of
// an operation where when returning history.
Bundle_Response response;

Bundle_Entry(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.link,
    this.fullUrl,
    this.resource,
    this.search,
    this.request,
    this.response,
    });

  factory Bundle_Entry.fromJson(Map<String, dynamic> json) => _$Bundle_EntryFromJson(json);
  Map<String, dynamic> toJson() => _$Bundle_EntryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Bundle_Search {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Why this entry is in the result set - whether it's included as a match
// or because of an _include requirement, or to convey information or
// warning information about the search process.
String mode; // <code> enum: match/include/outcome;

//  When searching, the server's search ranking score for the entry.
double score;

Bundle_Search(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.score,
    });

  factory Bundle_Search.fromJson(Map<String, dynamic> json) => _$Bundle_SearchFromJson(json);
  Map<String, dynamic> toJson() => _$Bundle_SearchToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Bundle_Request {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  In a transaction or batch, this is the HTTP action to be executed for
// this entry. In a history bundle, this indicates the HTTP action that
// occurred.
String method; // <code> enum: GET/HEAD/POST/PUT/DELETE/PATCH;

//  The URL for this entry, relative to the root (the address to which the
// request is posted).
String url;

//  If the ETag values match, return a 304 Not Modified status. See the
// API documentation for ["Conditional Read"](http.html#cread).
String ifNoneMatch;

//  Only perform the operation if the last updated date matches. See the
// API documentation for ["Conditional Read"](http.html#cread).
DateTime ifModifiedSince;

//  Only perform the operation if the Etag value matches. For more
// information, see the API section ["Managing Resource
// Contention"](http.html#concurrency).
String ifMatch;

//  Instruct the server not to perform the create if a specified resource
// already exists. For further information, see the API documentation for
// ["Conditional Create"](http.html#ccreate). This is just the query
// portion of the URL - what follows the "?" (not including the "?").
String ifNoneExist;

Bundle_Request(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.method,
    this.url,
    this.ifNoneMatch,
    this.ifModifiedSince,
    this.ifMatch,
    this.ifNoneExist,
    });

  factory Bundle_Request.fromJson(Map<String, dynamic> json) => _$Bundle_RequestFromJson(json);
  Map<String, dynamic> toJson() => _$Bundle_RequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Bundle_Response {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The status code returned by processing this entry. The status SHALL
// start with a 3 digit HTTP code (e.g. 404) and may contain the standard
// HTTP description associated with the status code.
String status;

//  The location header created by processing this operation, populated if
// the operation returns a location.
String location;

//  The Etag for the resource, if the operation for the entry produced a
// versioned resource (see [Resource Metadata and
// Versioning](http.html#versioning) and [Managing Resource
// Contention](http.html#concurrency)).
String etag;

//  The date/time that the resource was modified on the server.
DateTime lastModified;

//  An OperationOutcome containing hints and warnings produced as part of
// processing this entry in a batch or transaction.
ResourceList outcome;

Bundle_Response(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.status,
    this.location,
    this.etag,
    this.lastModified,
    this.outcome,
    });

  factory Bundle_Response.fromJson(Map<String, dynamic> json) => _$Bundle_ResponseFromJson(json);
  Map<String, dynamic> toJson() => _$Bundle_ResponseToJson(this);
}

part 'capabilityStatement.g.dart';

@JsonSerializable(explicitToJson: true)
class CapabilityStatement {

//  This is a CapabilityStatement resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this capability statement
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this capability statement is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the capability statement is stored on different servers.
String url;

//  The identifier that is used to identify this version of the capability
// statement when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the capability
// statement author and is not expected to be globally unique. For
// example, it might be a timestamp (e.g. yyyymmdd) if a managed version
// is not available. There is also no expectation that versions can be
// placed in a lexicographical sequence.
String version;

//  A natural language name identifying the capability statement. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the capability
// statement.
String title;

//  The status of this capability statement. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this capability statement is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the capability statement was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the capability statement
// changes.
DateTime date;

//  The name of the organization or individual that published the
// capability statement.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the capability statement
// from a consumer's perspective. Typically, this is used when the
// capability statement describes a desired rather than an actual
// solution, for example as a formal expression of requirements as part of
// an RFP.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate capability statement instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the capability statement is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this capability statement is needed and why it has
// been designed as it has.
String purpose;

//  A copyright statement relating to the capability statement and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the capability statement.
String copyright;

//  The way that this statement is intended to be used, to describe an
// actual running instance of software, a particular product (kind, not
// instance of software) or a class of implementation (e.g. a desired
// purchase).
String kind; // <code> enum: instance/capability/requirements;

//  Reference to a canonical URL of another CapabilityStatement that this
// software implements. This capability statement is a published API
// description that corresponds to a business service. The server may
// actually implement a subset of the capability statement it claims to
// implement, so the capability statement must specify the full capability
// details.
List<String> instantiates;

//  Reference to a canonical URL of another CapabilityStatement that this
// software adds to. The capability statement automatically includes
// everything in the other statement, and it is not duplicated, though the
// server may repeat the same resources, interactions and operations to
// add additional details to them.
List<String> imports;

//  Software that is covered by this capability statement.  It is used
// when the capability statement describes the capabilities of a
// particular software version, independent of an installation.
CapabilityStatement_Software software;

//  Identifies a specific implementation instance that is described by the
// capability statement - i.e. a particular installation, rather than the
// capabilities of a software program.
CapabilityStatement_Implementation implementation;

//  The version of the FHIR specification that this CapabilityStatement
// describes (which SHALL be the same as the FHIR version of the
// CapabilityStatement itself). There is no default value.
String fhirVersion; // <code> enum: 0.01/0.05/0.06/0.11/0.0.80/0.0.81/0.0.82/0.4.0/0.5.0/1.0.0/1.0.1/1.0.2/1.1.0/1.4.0/1.6.0/1.8.0/3.0.0/3.0.1/3.3.0/3.5.0/4.0.0/4.0.1;

//  A list of the formats supported by this implementation using their
// content types.
List<String> format;

//  A list of the patch formats supported by this implementation using
// their content types.
List<String> patchFormat;

//  A list of implementation guides that the server does (or should)
// support in their entirety.
List<String> implementationGuide;

//  A definition of the restful capabilities of the solution, if any.
List<CapabilityStatement_Rest> rest;

//  A description of the messaging capabilities of the solution.
List<CapabilityStatement_Messaging> messaging;

//  A document definition.
List<CapabilityStatement_Document> document;

CapabilityStatement(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.kind,
    this.instantiates,
    this.imports,
    this.software,
    this.implementation,
    this.fhirVersion,
    this.format,
    this.patchFormat,
    this.implementationGuide,
    this.rest,
    this.messaging,
    this.document,
    });

  factory CapabilityStatement.fromJson(Map<String, dynamic> json) => _$CapabilityStatementFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatementToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Software {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name the software is known by.
String name;

//  The version identifier for the software covered by this statement.
String version;

//  Date this version of the software was released.
DateTime releaseDate;

CapabilityStatement_Software(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.version,
    this.releaseDate,
    });

  factory CapabilityStatement_Software.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_SoftwareFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_SoftwareToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Implementation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Information about the specific installation that this capability
// statement relates to.
String description;

//  An absolute base URL for the implementation.  This forms the base for
// REST interfaces as well as the mailbox and document interfaces.
String url;

//  The organization responsible for the management of the instance and
// oversight of the data on the server at the specified URL.
Reference custodian;

CapabilityStatement_Implementation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.url,
    this.custodian,
    });

  factory CapabilityStatement_Implementation.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_ImplementationFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_ImplementationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Rest {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies whether this portion of the statement is describing the
// ability to initiate or receive restful operations.
String mode; // <code> enum: client/server;

//  Information about the system's restful capabilities that apply across
// all applications, such as security.
String documentation;

//  Information about security implementation from an interface
// perspective - what a client needs to know.
CapabilityStatement_Security security;

//  A specification of the restful capabilities of the solution for a
// specific resource type.
List<CapabilityStatement_Resource> resource;

//  A specification of restful operations supported by the system.
List<CapabilityStatement_Interaction1> interaction;

//  Search parameters that are supported for searching all resources for
// implementations to support and/or make use of - either references to
// ones defined in the specification, or additional ones defined for/by
// the implementation.
List<CapabilityStatement_SearchParam> searchParam;

//  Definition of an operation or a named query together with its
// parameters and their meaning and type.
List<CapabilityStatement_Operation> operation;

//  An absolute URI which is a reference to the definition of a
// compartment that the system supports. The reference is to a
// CompartmentDefinition resource by its canonical URL .
List<String> compartment;

CapabilityStatement_Rest(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.documentation,
    this.security,
    this.resource,
    this.interaction,
    this.searchParam,
    this.operation,
    this.compartment,
    });

  factory CapabilityStatement_Rest.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_RestFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_RestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Security {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Server adds CORS headers when responding to requests - this enables
// Javascript applications to use the server.
bool cors;

//  Types of security services that are supported/required by the system.
List<CodeableConcept> service;

//  General description of how security works.
String description;

CapabilityStatement_Security(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.cors,
    this.service,
    this.description,
    });

  factory CapabilityStatement_Security.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_SecurityFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_SecurityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Resource {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A type of resource exposed via the restful interface.
String type;

//  A specification of the profile that describes the solution's overall
// support for the resource, including any constraints on cardinality,
// bindings, lengths or other limitations. See further discussion in
// [Using Profiles](profiling.html#profile-uses).
String profile;

//  A list of profiles that represent different use cases supported by the
// system. For a server, "supported by the system" means the system
// hosts/produces a set of resources that are conformant to a particular
// profile, and allows clients that use its services to search using this
// profile and to find appropriate data. For a client, it means the system
// will search by this profile and process data according to the guidance
// implicit in the profile. See further discussion in [Using
// Profiles](profiling.html#profile-uses).
List<String> supportedProfile;

//  Additional information about the resource type used by the system.
String documentation;

//  Identifies a restful operation supported by the solution.
List<CapabilityStatement_Interaction> interaction;

//  This field is set to no-version to specify that the system does not
// support (server) or use (client) versioning for this resource type. If
// this has some other value, the server must at least correctly track and
// populate the versionId meta-property on resources. If the value is
// 'versioned-update', then the server supports all the versioning
// features, including using e-tags for version integrity in the API.
String versioning; // <code> enum: no-version/versioned/versioned-update;

//  A flag for whether the server is able to return past versions as part
// of the vRead operation.
bool readHistory;

//  A flag to indicate that the server allows or needs to allow the client
// to create new identities on the server (that is, the client PUTs to a
// location where there is no existing resource). Allowing this operation
// means that the server allows the client to create new identities on the
// server.
bool updateCreate;

//  A flag that indicates that the server supports conditional create.
bool conditionalCreate;

//  A code that indicates how the server supports conditional read.
String conditionalRead; // <code> enum: not-supported/modified-since/not-match/full-support;

//  A flag that indicates that the server supports conditional update.
bool conditionalUpdate;

//  A code that indicates how the server supports conditional delete.
String conditionalDelete; // <code> enum: not-supported/single/multiple;

//  A set of flags that defines how references are supported.
List<String> referencePolicy; // <code> enum: literal/logical/resolves/enforced/local> referencePolicy;

//  A list of _include values supported by the server.
List<String> searchInclude;

//  A list of _revinclude (reverse include) values supported by the
// server.
List<String> searchRevInclude;

//  Search parameters for implementations to support and/or make use of -
// either references to ones defined in the specification, or additional
// ones defined for/by the implementation.
List<CapabilityStatement_SearchParam> searchParam;

//  Definition of an operation or a named query together with its
// parameters and their meaning and type. Consult the definition of the
// operation for details about how to invoke the operation, and the
// parameters.
List<CapabilityStatement_Operation> operation;

CapabilityStatement_Resource(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.profile,
    this.supportedProfile,
    this.documentation,
    this.interaction,
    this.versioning,
    this.readHistory,
    this.updateCreate,
    this.conditionalCreate,
    this.conditionalRead,
    this.conditionalUpdate,
    this.conditionalDelete,
    this.referencePolicy,
    this.searchInclude,
    this.searchRevInclude,
    this.searchParam,
    this.operation,
    });

  factory CapabilityStatement_Resource.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_ResourceFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_ResourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Interaction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Coded identifier of the operation, supported by the system resource.
String code; // <code> enum: read/vread/update/patch/delete/history-instance/history-type/create/search-type;

//  Guidance specific to the implementation of this operation, such as
// 'delete is a logical delete' or 'updates are only allowed with version
// id' or 'creates permitted from pre-authorized certificates only'.
String documentation;

CapabilityStatement_Interaction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.documentation,
    });

  factory CapabilityStatement_Interaction.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_InteractionFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_InteractionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_SearchParam {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the search parameter used in the interface.
String name;

//  An absolute URI that is a formal reference to where this parameter was
// first defined, so that a client can be confident of the meaning of the
// search parameter (a reference to [[[SearchParameter.url]]]). This
// element SHALL be populated if the search parameter refers to a
// SearchParameter defined by the FHIR core specification or externally
// defined IGs.
String definition;

//  The type of value a search parameter refers to, and how the content is
// interpreted.
String type; // <code> enum: number/date/string/token/reference/composite/quantity/uri/special;

//  This allows documentation of any distinct behaviors about how the
// search parameter is used.  For example, text matching algorithms.
String documentation;

CapabilityStatement_SearchParam(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.definition,
    this.type,
    this.documentation,
    });

  factory CapabilityStatement_SearchParam.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_SearchParamFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_SearchParamToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Operation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the operation or query. For an operation, this is the name
//  prefixed with $ and used in the URL. For a query, this is the name
// used in the _query parameter when the query is called.
String name;

//  Where the formal definition can be found. If a server references the
// base definition of an Operation (i.e. from the specification itself
// such as ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```),
// that means it supports the full capabilities of the operation - e.g.
// both GET and POST invocation.  If it only supports a subset, it must
// define its own custom [[[OperationDefinition]]] with a 'base' of the
// original OperationDefinition.  The custom definition would describe the
// specific subset of functionality supported.
String definition;

//  Documentation that describes anything special about the operation
// behavior, possibly detailing different behavior for system, type and
// instance-level invocation of the operation.
String documentation;

CapabilityStatement_Operation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.definition,
    this.documentation,
    });

  factory CapabilityStatement_Operation.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_OperationFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_OperationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Interaction1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A coded identifier of the operation, supported by the system.
String code; // <code> enum: transaction/batch/search-system/history-system;

//  Guidance specific to the implementation of this operation, such as
// limitations on the kind of transactions allowed, or information about
// system wide search is implemented.
String documentation;

CapabilityStatement_Interaction1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.documentation,
    });

  factory CapabilityStatement_Interaction1.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_Interaction1FromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_Interaction1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Messaging {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An endpoint (network accessible address) to which messages and/or
// replies are to be sent.
List<CapabilityStatement_Endpoint> endpoint;

//  Length if the receiver's reliable messaging cache in minutes (if a
// receiver) or how long the cache length on the receiver should be (if a
// sender).
int reliableCache;

//  Documentation about the system's messaging capabilities for this
// endpoint not otherwise documented by the capability statement.  For
// example, the process for becoming an authorized messaging exchange
// partner.
String documentation;

//  References to message definitions for messages this system can send or
// receive.
List<CapabilityStatement_SupportedMessage> supportedMessage;

CapabilityStatement_Messaging(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.endpoint,
    this.reliableCache,
    this.documentation,
    this.supportedMessage,
    });

  factory CapabilityStatement_Messaging.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_MessagingFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_MessagingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Endpoint {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A list of the messaging transport protocol(s) identifiers, supported
// by this endpoint.
Coding protocol;

//  The network address of the endpoint. For solutions that do not use
// network addresses for routing, it can be just an identifier.
String address;

CapabilityStatement_Endpoint(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.protocol,
    this.address,
    });

  factory CapabilityStatement_Endpoint.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_EndpointFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_EndpointToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_SupportedMessage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The mode of this event declaration - whether application is sender or
// receiver.
String mode; // <code> enum: sender/receiver;

//  Points to a message definition that identifies the messaging event,
// message structure, allowed responses, etc.
String definition;

CapabilityStatement_SupportedMessage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.definition,
    });

  factory CapabilityStatement_SupportedMessage.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_SupportedMessageFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_SupportedMessageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CapabilityStatement_Document {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Mode of this document declaration - whether an application is a
// producer or consumer.
String mode; // <code> enum: producer/consumer;

//  A description of how the application supports or uses the specified
// document profile.  For example, when documents are created, what action
// is taken with consumed documents, etc.
String documentation;

//  A profile on the document Bundle that constrains which resources are
// present, and their contents.
String profile;

CapabilityStatement_Document(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.documentation,
    this.profile,
    });

  factory CapabilityStatement_Document.fromJson(Map<String, dynamic> json) => _$CapabilityStatement_DocumentFromJson(json);
  Map<String, dynamic> toJson() => _$CapabilityStatement_DocumentToJson(this);
}

part 'carePlan.g.dart';

@JsonSerializable(explicitToJson: true)
class CarePlan {

//  This is a CarePlan resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this care plan by the performer or
// other systems which remain constant as the resource is updated and
// propagates from server to server.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, questionnaire
// or other definition that is adhered to in whole or in part by this
// CarePlan.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// questionnaire or other definition that is adhered to in whole or in
// part by this CarePlan.
List<String> instantiatesUri;

//  A care plan that is fulfilled in whole or in part by this care plan.
List<Reference> basedOn;

//  Completed or terminated care plan whose function is taken by this new
// care plan.
List<Reference> replaces;

//  A larger care plan of which this particular care plan is a component
// or step.
List<Reference> partOf;

//  Indicates whether the plan is currently being acted upon, represents
// future intentions or is now a historical record.
String status;

//  Indicates the level of authority/intentionality associated with the
// care plan and where the care plan fits into the workflow chain.
String intent;

//  Identifies what "kind" of plan this is to support differentiation
// between multiple co-existing plans; e.g. "Home health", "psychiatric",
// "asthma", "disease management", "wellness plan", etc.
List<CodeableConcept> category;

//  Human-friendly name for the care plan.
String title;

//  A description of the scope and nature of the plan.
String description;

//  Identifies the patient or group whose intended care is described by
// the plan.
Reference subject;

//  The Encounter during which this CarePlan was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  Indicates when the plan did (or is intended to) come into effect and
// end.
Period period;

//  Represents when this particular CarePlan record was created in the
// system, which is often a system-generated date.
DateTime created;

//  When populated, the author is responsible for the care plan.  The care
// plan is attributed to the author.
Reference author;

//  Identifies the individual(s) or organization who provided the contents
// of the care plan.
List<Reference> contributor;

//  Identifies all people and organizations who are expected to be
// involved in the care envisioned by this plan.
List<Reference> careTeam;

//  Identifies the conditions/problems/concerns/diagnoses/etc. whose
// management and/or mitigation are handled by this plan.
List<Reference> addresses;

//  Identifies portions of the patient's record that specifically
// influenced the formation of the plan.  These might include
// comorbidities, recent procedures, limitations, recent assessments, etc.
List<Reference> supportingInfo;

//  Describes the intended objective(s) of carrying out the care plan.
List<Reference> goal;

//  Identifies a planned action to occur as part of the plan.  For
// example, a medication to be used, lab tests to perform,
// self-monitoring, education, etc.
List<CarePlan_Activity> activity;

//  General notes about the care plan not covered elsewhere.
List<Annotation> note;

CarePlan(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.replaces,
    this.partOf,
    this.status,
    this.intent,
    this.category,
    this.title,
    this.description,
    this.subject,
    this.encounter,
    this.period,
    this.created,
    this.author,
    this.contributor,
    this.careTeam,
    this.addresses,
    this.supportingInfo,
    this.goal,
    this.activity,
    this.note,
    });

  factory CarePlan.fromJson(Map<String, dynamic> json) => _$CarePlanFromJson(json);
  Map<String, dynamic> toJson() => _$CarePlanToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CarePlan_Activity {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies the outcome at the point when the status of the activity is
// assessed.  For example, the outcome of an education activity could be
// patient understands (or not).
List<CodeableConcept> outcomeCodeableConcept;

//  Details of the outcome or action resulting from the activity.  The
// reference to an "event" resource, such as Procedure or Encounter or
// Observation, is the result/outcome of the activity itself.  The
// activity can be conveyed using CarePlan.activity.detail OR using the
// CarePlan.activity.reference (a reference to a request resource).
List<Reference> outcomeReference;

//  Notes about the adherence/status/progress of the activity.
List<Annotation> progress;

//  The details of the proposed activity represented in a specific
// resource.
Reference reference;

//  A simple summary of a planned activity suitable for a general care
// plan system (e.g. form driven) that doesn't know about specific
// resources such as procedure etc.
CarePlan_Detail detail;

CarePlan_Activity(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.outcomeCodeableConcept,
    this.outcomeReference,
    this.progress,
    this.reference,
    this.detail,
    });

  factory CarePlan_Activity.fromJson(Map<String, dynamic> json) => _$CarePlan_ActivityFromJson(json);
  Map<String, dynamic> toJson() => _$CarePlan_ActivityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CarePlan_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A description of the kind of resource the in-line definition of a care
// plan activity is representing.  The CarePlan.activity.detail is an
// in-line definition when a resource is not referenced using
// CarePlan.activity.reference.  For example, a MedicationRequest, a
// ServiceRequest, or a CommunicationRequest.
String kind;

//  The URL pointing to a FHIR-defined protocol, guideline, questionnaire
// or other definition that is adhered to in whole or in part by this
// CarePlan activity.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// questionnaire or other definition that is adhered to in whole or in
// part by this CarePlan activity.
List<String> instantiatesUri;

//  Detailed description of the type of planned activity; e.g. what lab
// test, what procedure, what kind of encounter.
CodeableConcept code;

//  Provides the rationale that drove the inclusion of this particular
// activity as part of the plan or the reason why the activity was
// prohibited.
List<CodeableConcept> reasonCode;

//  Indicates another resource, such as the health condition(s), whose
// existence justifies this request and drove the inclusion of this
// particular activity as part of the plan.
List<Reference> reasonReference;

//  Internal reference that identifies the goals that this activity is
// intended to contribute towards meeting.
List<Reference> goal;

//  Identifies what progress is being made for the specific activity.
String status; // <code> enum: not-started/scheduled/in-progress/on-hold/completed/cancelled/stopped/unknown/entered-in-error;

//  Provides reason why the activity isn't yet started, is on hold, was
// cancelled, etc.
CodeableConcept statusReason;

//  If true, indicates that the described activity is one that must NOT be
// engaged in when following the plan.  If false, or missing, indicates
// that the described activity is one that should be engaged in when
// following the plan.
bool doNotPerform;

//  The period, timing or frequency upon which the described activity is
// to occur.
Timing scheduledTiming;

//  The period, timing or frequency upon which the described activity is
// to occur.
Period scheduledPeriod;

//  The period, timing or frequency upon which the described activity is
// to occur.
String scheduledString; //  pattern: ^[ \r\n\t\S]+$

//  Identifies the facility where the activity will occur; e.g. home,
// hospital, specific clinic, etc.
Reference location;

//  Identifies who's expected to be involved in the activity.
List<Reference> performer;

//  Identifies the food, drug or other product to be consumed or supplied
// in the activity.
CodeableConcept productCodeableConcept;

//  Identifies the food, drug or other product to be consumed or supplied
// in the activity.
Reference productReference;

//  Identifies the quantity expected to be consumed in a given day.
Quantity dailyAmount;

//  Identifies the quantity expected to be supplied, administered or
// consumed by the subject.
Quantity quantity;

//  This provides a textual description of constraints on the intended
// activity occurrence, including relation to other activities.  It may
// also include objectives, pre-conditions and end-conditions.  Finally,
// it may convey specifics about the activity such as body site, method,
// route, etc.
String description;

CarePlan_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.kind,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.code,
    this.reasonCode,
    this.reasonReference,
    this.goal,
    this.status,
    this.statusReason,
    this.doNotPerform,
    this.scheduledTiming,
    this.scheduledPeriod,
    this.scheduledString,
    this.location,
    this.performer,
    this.productCodeableConcept,
    this.productReference,
    this.dailyAmount,
    this.quantity,
    this.description,
    });

  factory CarePlan_Detail.fromJson(Map<String, dynamic> json) => _$CarePlan_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$CarePlan_DetailToJson(this);
}

part 'careTeam.g.dart';

@JsonSerializable(explicitToJson: true)
class CareTeam {

//  This is a CareTeam resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this care team by the performer or
// other systems which remain constant as the resource is updated and
// propagates from server to server.
List<Identifier> identifier;

//  Indicates the current state of the care team.
String status; // <code> enum: proposed/active/suspended/inactive/entered-in-error;

//  Identifies what kind of team.  This is to support differentiation
// between multiple co-existing teams, such as care plan team, episode of
// care team, longitudinal care team.
List<CodeableConcept> category;

//  A label for human use intended to distinguish like teams.  E.g. the
// "red" vs. "green" trauma teams.
String name;

//  Identifies the patient or group whose intended care is handled by the
// team.
Reference subject;

//  The Encounter during which this CareTeam was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  Indicates when the team did (or is intended to) come into effect and
// end.
Period period;

//  Identifies all people and organizations who are expected to be
// involved in the care team.
List<CareTeam_Participant> participant;

//  Describes why the care team exists.
List<CodeableConcept> reasonCode;

//  Condition(s) that this care team addresses.
List<Reference> reasonReference;

//  The organization responsible for the care team.
List<Reference> managingOrganization;

//  A central contact detail for the care team (that applies to all
// members).
List<ContactPoint> telecom;

//  Comments made about the CareTeam.
List<Annotation> note;

CareTeam(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.category,
    this.name,
    this.subject,
    this.encounter,
    this.period,
    this.participant,
    this.reasonCode,
    this.reasonReference,
    this.managingOrganization,
    this.telecom,
    this.note,
    });

  factory CareTeam.fromJson(Map<String, dynamic> json) => _$CareTeamFromJson(json);
  Map<String, dynamic> toJson() => _$CareTeamToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CareTeam_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates specific responsibility of an individual within the care
// team, such as "Primary care physician", "Trained social worker
// counselor", "Caregiver", etc.
List<CodeableConcept> role;

//  The specific person or organization who is participating/expected to
// participate in the care team.
Reference member;

//  The organization of the practitioner.
Reference onBehalfOf;

//  Indicates when the specific member or organization did (or is intended
// to) come into effect and end.
Period period;

CareTeam_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.role,
    this.member,
    this.onBehalfOf,
    this.period,
    });

  factory CareTeam_Participant.fromJson(Map<String, dynamic> json) => _$CareTeam_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$CareTeam_ParticipantToJson(this);
}

part 'catalogEntry.g.dart';

@JsonSerializable(explicitToJson: true)
class CatalogEntry {

//  This is a CatalogEntry resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Used in supporting different identifiers for the same product, e.g.
// manufacturer code and retailer code.
List<Identifier> identifier;

//  The type of item - medication, device, service, protocol or other.
CodeableConcept type;

//  Whether the entry represents an orderable item.
bool orderable;

//  The item in a catalog or definition.
Reference referencedItem;

//  Used in supporting related concepts, e.g. NDC to RxNorm.
List<Identifier> additionalIdentifier;

//  Classes of devices, or ATC for medication.
List<CodeableConcept> classification;

//  Used to support catalog exchange even for unsupported products, e.g.
// getting list of medications even if not prescribable.
String status; // <code> enum: draft/active/retired/unknown;

//  The time period in which this catalog entry is expected to be active.
Period validityPeriod;

//  The date until which this catalog entry is expected to be active.
DateTime validTo;

//  Typically date of issue is different from the beginning of the
// validity. This can be used to see when an item was last updated.
DateTime lastUpdated;

//  Used for examplefor Out of Formulary, or any specifics.
List<CodeableConcept> additionalCharacteristic;

//  User for example for ATC classification, or.
List<CodeableConcept> additionalClassification;

//  Used for example, to point to a substance, or to a device used to
// administer a medication.
List<CatalogEntry_RelatedEntry> relatedEntry;

CatalogEntry(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.orderable,
    this.referencedItem,
    this.additionalIdentifier,
    this.classification,
    this.status,
    this.validityPeriod,
    this.validTo,
    this.lastUpdated,
    this.additionalCharacteristic,
    this.additionalClassification,
    this.relatedEntry,
    });

  factory CatalogEntry.fromJson(Map<String, dynamic> json) => _$CatalogEntryFromJson(json);
  Map<String, dynamic> toJson() => _$CatalogEntryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CatalogEntry_RelatedEntry {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of relation to the related item: child, parent,
// packageContent, containerPackage, usedIn, uses, requires, etc.
String relationtype; // <code> enum: triggers/is-replaced-by;

//  The reference to the related item.
Reference item;

CatalogEntry_RelatedEntry(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.relationtype,
    this.item,
    });

  factory CatalogEntry_RelatedEntry.fromJson(Map<String, dynamic> json) => _$CatalogEntry_RelatedEntryFromJson(json);
  Map<String, dynamic> toJson() => _$CatalogEntry_RelatedEntryToJson(this);
}

part 'chargeItem.g.dart';

@JsonSerializable(explicitToJson: true)
class ChargeItem {

//  This is a ChargeItem resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this event performer or other systems.
List<Identifier> identifier;

//  References the (external) source of pricing information, rules of
// application for the code this ChargeItem uses.
List<String> definitionUri;

//  References the source of pricing information, rules of application for
// the code this ChargeItem uses.
List<String> definitionCanonical;

//  The current state of the ChargeItem.
String status; // <code> enum: planned/billable/not-billable/aborted/billed/entered-in-error/unknown;

//  ChargeItems can be grouped to larger ChargeItems covering the whole
// set.
List<Reference> partOf;

//  A code that identifies the charge, like a billing code.
CodeableConcept code;

//  The individual or set of individuals the action is being or was
// performed on.
Reference subject;

//  The encounter or episode of care that establishes the context for this
// event.
Reference context;

//  Date/time(s) or duration when the charged service was applied.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Date/time(s) or duration when the charged service was applied.
Period occurrencePeriod;

//  Date/time(s) or duration when the charged service was applied.
Timing occurrenceTiming;

//  Indicates who or what performed or participated in the charged
// service.
List<ChargeItem_Performer> performer;

//  The organization requesting the service.
Reference performingOrganization;

//  The organization performing the service.
Reference requestingOrganization;

//  The financial cost center permits the tracking of charge attribution.
Reference costCenter;

//  Quantity of which the charge item has been serviced.
Quantity quantity;

//  The anatomical location where the related service has been applied.
List<CodeableConcept> bodysite;

//  Factor overriding the factor determined by the rules associated with
// the code.
double factorOverride;

//  Total price of the charge overriding the list price associated with
// the code.
Money priceOverride;

//  If the list price or the rule-based factor associated with the code is
// overridden, this attribute can capture a text to indicate the  reason
// for this action.
String overrideReason;

//  The device, practitioner, etc. who entered the charge item.
Reference enterer;

//  Date the charge item was entered.
DateTime enteredDate;

//  Describes why the event occurred in coded or textual form.
List<CodeableConcept> reason;

//  Indicated the rendered service that caused this charge.
List<Reference> service;

//  Identifies the device, food, drug or other product being charged
// either by type code or reference to an instance.
Reference productReference;

//  Identifies the device, food, drug or other product being charged
// either by type code or reference to an instance.
CodeableConcept productCodeableConcept;

//  Account into which this ChargeItems belongs.
List<Reference> account;

//  Comments made about the event by the performer, subject or other
// participants.
List<Annotation> note;

//  Further information supporting this charge.
List<Reference> supportingInformation;

ChargeItem(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.definitionUri,
    this.definitionCanonical,
    this.status,
    this.partOf,
    this.code,
    this.subject,
    this.context,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.performer,
    this.performingOrganization,
    this.requestingOrganization,
    this.costCenter,
    this.quantity,
    this.bodysite,
    this.factorOverride,
    this.priceOverride,
    this.overrideReason,
    this.enterer,
    this.enteredDate,
    this.reason,
    this.service,
    this.productReference,
    this.productCodeableConcept,
    this.account,
    this.note,
    this.supportingInformation,
    });

  factory ChargeItem.fromJson(Map<String, dynamic> json) => _$ChargeItemFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ChargeItem_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the type of performance or participation(e.g. primary
// surgeon, anesthesiologiest, etc.).
CodeableConcept function;

//  The device, practitioner, etc. who performed or participated in the
// service.
Reference actor;

ChargeItem_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    });

  factory ChargeItem_Performer.fromJson(Map<String, dynamic> json) => _$ChargeItem_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItem_PerformerToJson(this);
}

part 'chargeItemDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ChargeItemDefinition {

//  This is a ChargeItemDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this charge item definition
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this charge item definition is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the charge item definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this charge item
// definition when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the charge
// item definition when it is referenced in a specification, model, design
// or instance. This is an arbitrary value managed by the charge item
// definition author and is not expected to be globally unique. For
// example, it might be a timestamp (e.g. yyyymmdd) if a managed version
// is not available. There is also no expectation that versions can be
// placed in a lexicographical sequence. To provide a version consistent
// with the Decision Support Service specification, use the format
// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
// knowledge assets, refer to the Decision Support Service specification.
// Note that a version is required for non-experimental active assets.
String version;

//  A short, descriptive, user-friendly title for the charge item
// definition.
String title;

//  The URL pointing to an externally-defined charge item definition that
// is adhered to in whole or in part by this definition.
List<String> derivedFromUri;

//  A larger definition of which this particular definition is a component
// or step.
List<String> partOf;

//  As new versions of a protocol or guideline are defined, allows
// identification of what versions are replaced by a new instance.
List<String> replaces;

//  The current state of the ChargeItemDefinition.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this charge item definition is
// authored for testing purposes (or education/evaluation/marketing) and
// is not intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the charge item definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the charge item definition
// changes.
DateTime date;

//  The name of the organization or individual that published the charge
// item definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the charge item definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate charge item definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the charge item definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the charge item definition and/or
// its contents. Copyright statements are generally legal restrictions on
// the use and publishing of the charge item definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the charge item definition content was or is
// planned to be in active use.
Period effectivePeriod;

//  The defined billing details in this resource pertain to the given
// billing code.
CodeableConcept code;

//  The defined billing details in this resource pertain to the given
// product instance(s).
List<Reference> instance;

//  Expressions that describe applicability criteria for the billing code.
List<ChargeItemDefinition_Applicability> applicability;

//  Group of properties which are applicable under the same conditions. If
// no applicability rules are established for the group, then all
// properties always apply.
List<ChargeItemDefinition_PropertyGroup> propertyGroup;

ChargeItemDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.title,
    this.derivedFromUri,
    this.partOf,
    this.replaces,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.code,
    this.instance,
    this.applicability,
    this.propertyGroup,
    });

  factory ChargeItemDefinition.fromJson(Map<String, dynamic> json) => _$ChargeItemDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItemDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ChargeItemDefinition_Applicability {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A brief, natural language description of the condition that
// effectively communicates the intended semantics.
String description;

//  The media type of the language for the expression, e.g. "text/cql" for
// Clinical Query Language expressions or "text/fhirpath" for FHIRPath
// expressions.
String language;

//  An expression that returns true or false, indicating whether the
// condition is satisfied. When using FHIRPath expressions, the %context
// environment variable must be replaced at runtime with the ChargeItem
// resource to which this definition is applied.
String expression;

ChargeItemDefinition_Applicability(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.language,
    this.expression,
    });

  factory ChargeItemDefinition_Applicability.fromJson(Map<String, dynamic> json) => _$ChargeItemDefinition_ApplicabilityFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItemDefinition_ApplicabilityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ChargeItemDefinition_PropertyGroup {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Expressions that describe applicability criteria for the
// priceComponent.
List<ChargeItemDefinition_Applicability> applicability;

//  The price for a ChargeItem may be calculated as a base price with
// surcharges/deductions that apply in certain conditions. A
// ChargeItemDefinition resource that defines the prices, factors and
// conditions that apply to a billing code is currently under development.
// The priceComponent element can be used to offer transparency to the
// recipient of the Invoice of how the prices have been calculated.
List<ChargeItemDefinition_PriceComponent> priceComponent;

ChargeItemDefinition_PropertyGroup(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.applicability,
    this.priceComponent,
    });

  factory ChargeItemDefinition_PropertyGroup.fromJson(Map<String, dynamic> json) => _$ChargeItemDefinition_PropertyGroupFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItemDefinition_PropertyGroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ChargeItemDefinition_PriceComponent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  This code identifies the type of the component.
String type;

//  A code that identifies the component. Codes may be used to
// differentiate between kinds of taxes, surcharges, discounts etc.
CodeableConcept code;

//  The factor that has been applied on the base price for calculating
// this component.
double factor;

//  The amount calculated for this component.
Money amount;

ChargeItemDefinition_PriceComponent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.code,
    this.factor,
    this.amount,
    });

  factory ChargeItemDefinition_PriceComponent.fromJson(Map<String, dynamic> json) => _$ChargeItemDefinition_PriceComponentFromJson(json);
  Map<String, dynamic> toJson() => _$ChargeItemDefinition_PriceComponentToJson(this);
}

part 'claim.g.dart';

@JsonSerializable(explicitToJson: true)
class Claim {

//  This is a Claim resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this claim.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  The category of claim, e.g. oral, pharmacy, vision, institutional,
// professional.
CodeableConcept type;

//  A finer grained suite of claim type codes which may convey additional
// information such as Inpatient vs Outpatient and/or a specialty service.
CodeableConcept subType;

//  A code to indicate whether the nature of the request is: to request
// adjudication of products and services previously rendered; or
// requesting authorization and adjudication for provision in the future;
// or requesting the non-binding adjudication of the listed products and
// services which could be provided in the future.
String use; // <code> enum: claim/preauthorization/predetermination;

//  The party to whom the professional services and/or products have been
// supplied or are being considered and for whom actual or forecast
// reimbursement is sought.
Reference patient;

//  The period for which charges are being submitted.
Period billablePeriod;

//  The date this resource was created.
DateTime created;

//  Individual who created the claim, predetermination or
// preauthorization.
Reference enterer;

//  The Insurer who is target of the request.
Reference insurer;

//  The provider which is responsible for the claim, predetermination or
// preauthorization.
Reference provider;

//  The provider-required urgency of processing the request. Typical
// values include: stat, routine deferred.
CodeableConcept priority;

//  A code to indicate whether and for whom funds are to be reserved for
// future claims.
CodeableConcept fundsReserve;

//  Other claims which are related to this claim such as prior submissions
// or claims for related services or for the same event.
List<Claim_Related> related;

//  Prescription to support the dispensing of pharmacy, device or vision
// products.
Reference prescription;

//  Original prescription which has been superseded by this prescription
// to support the dispensing of pharmacy services, medications or
// products.
Reference originalPrescription;

//  The party to be reimbursed for cost of the products and services
// according to the terms of the policy.
Claim_Payee payee;

//  A reference to a referral resource.
Reference referral;

//  Facility where the services were provided.
Reference facility;

//  The members of the team who provided the products and services.
List<Claim_CareTeam> careTeam;

//  Additional information codes regarding exceptions, special
// considerations, the condition, situation, prior or concurrent issues.
List<Claim_SupportingInfo> supportingInfo;

//  Information about diagnoses relevant to the claim items.
List<Claim_Diagnosis> diagnosis;

//  Procedures performed on the patient relevant to the billing items with
// the claim.
List<Claim_Procedure> procedure;

//  Financial instruments for reimbursement for the health care products
// and services specified on the claim.
List<Claim_Insurance> insurance;

//  Details of an accident which resulted in injuries which required the
// products and services listed in the claim.
Claim_Accident accident;

//  A claim line. Either a simple  product or service or a 'group' of
// details which can each be a simple items or groups of sub-details.
List<Claim_Item> item;

//  The total value of the all the items in the claim.
Money total;

Claim(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.subType,
    this.use,
    this.patient,
    this.billablePeriod,
    this.created,
    this.enterer,
    this.insurer,
    this.provider,
    this.priority,
    this.fundsReserve,
    this.related,
    this.prescription,
    this.originalPrescription,
    this.payee,
    this.referral,
    this.facility,
    this.careTeam,
    this.supportingInfo,
    this.diagnosis,
    this.procedure,
    this.insurance,
    this.accident,
    this.item,
    this.total,
    });

  factory Claim.fromJson(Map<String, dynamic> json) => _$ClaimFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Related {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reference to a related claim.
Reference claim;

//  A code to convey how the claims are related.
CodeableConcept relationship;

//  An alternate organizational reference to the case or file to which
// this particular claim pertains.
Identifier reference;

Claim_Related(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.claim,
    this.relationship,
    this.reference,
    });

  factory Claim_Related.fromJson(Map<String, dynamic> json) => _$Claim_RelatedFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_RelatedToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Payee {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of Party to be reimbursed: subscriber, provider, other.
CodeableConcept type;

//  Reference to the individual or organization to whom any payment will
// be made.
Reference party;

Claim_Payee(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.party,
    });

  factory Claim_Payee.fromJson(Map<String, dynamic> json) => _$Claim_PayeeFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_PayeeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_CareTeam {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify care team entries.
int sequence;

//  Member of the team who provided the product or service.
Reference provider;

//  The party who is billing and/or responsible for the claimed products
// or services.
bool responsible;

//  The lead, assisting or supervising practitioner and their discipline
// if a multidisciplinary team.
CodeableConcept role;

//  The qualification of the practitioner which is applicable for this
// service.
CodeableConcept qualification;

Claim_CareTeam(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.provider,
    this.responsible,
    this.role,
    this.qualification,
    });

  factory Claim_CareTeam.fromJson(Map<String, dynamic> json) => _$Claim_CareTeamFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_CareTeamToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_SupportingInfo {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify supporting information entries.
int sequence;

//  The general class of the information supplied: information; exception;
// accident, employment; onset, etc.
CodeableConcept category;

//  System and code pertaining to the specific information regarding
// special conditions relating to the setting, treatment or patient  for
// which care is sought.
CodeableConcept code;

//  The date when or period to which this information refers.
String timingDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date when or period to which this information refers.
Period timingPeriod;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
bool valueBoolean; //  pattern: ^true|false$

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Quantity valueQuantity;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Attachment valueAttachment;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Reference valueReference;

//  Provides the reason in the situation where a reason code is required
// in addition to the content.
CodeableConcept reason;

Claim_SupportingInfo(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.category,
    this.code,
    this.timingDate,
    this.timingPeriod,
    this.valueBoolean,
    this.valueString,
    this.valueQuantity,
    this.valueAttachment,
    this.valueReference,
    this.reason,
    });

  factory Claim_SupportingInfo.fromJson(Map<String, dynamic> json) => _$Claim_SupportingInfoFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_SupportingInfoToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Diagnosis {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify diagnosis entries.
int sequence;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
CodeableConcept diagnosisCodeableConcept;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
Reference diagnosisReference;

//  When the condition was observed or the relative ranking.
List<CodeableConcept> type;

//  Indication of whether the diagnosis was present on admission to a
// facility.
CodeableConcept onAdmission;

//  A package billing code or bundle code used to group products and
// services to a particular health condition (such as heart attack) which
// is based on a predetermined grouping code system.
CodeableConcept packageCode;

Claim_Diagnosis(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.diagnosisCodeableConcept,
    this.diagnosisReference,
    this.type,
    this.onAdmission,
    this.packageCode,
    });

  factory Claim_Diagnosis.fromJson(Map<String, dynamic> json) => _$Claim_DiagnosisFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_DiagnosisToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Procedure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify procedure entries.
int sequence;

//  When the condition was observed or the relative ranking.
List<CodeableConcept> type;

//  Date and optionally time the procedure was performed.
DateTime date;

//  The code or reference to a Procedure resource which identifies the
// clinical intervention performed.
CodeableConcept procedureCodeableConcept;

//  The code or reference to a Procedure resource which identifies the
// clinical intervention performed.
Reference procedureReference;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

Claim_Procedure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.type,
    this.date,
    this.procedureCodeableConcept,
    this.procedureReference,
    this.udi,
    });

  factory Claim_Procedure.fromJson(Map<String, dynamic> json) => _$Claim_ProcedureFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_ProcedureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Insurance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify insurance entries and provide a sequence
// of coverages to convey coordination of benefit order.
int sequence;

//  A flag to indicate that this Coverage is to be used for adjudication
// of this claim when set to true.
bool focal;

//  The business identifier to be used when the claim is sent for
// adjudication against this insurance policy.
Identifier identifier;

//  Reference to the insurance card level information contained in the
// Coverage resource. The coverage issuing insurer will use these details
// to locate the patient's actual coverage within the insurer's
// information system.
Reference coverage;

//  A business agreement number established between the provider and the
// insurer for special business processing purposes.
String businessArrangement;

//  Reference numbers previously provided by the insurer to the provider
// to be quoted on subsequent claims containing services or products
// related to the prior authorization.
List<String> preAuthRef;

//  The result of the adjudication of the line items for the Coverage
// specified in this insurance.
Reference claimResponse;

Claim_Insurance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.focal,
    this.identifier,
    this.coverage,
    this.businessArrangement,
    this.preAuthRef,
    this.claimResponse,
    });

  factory Claim_Insurance.fromJson(Map<String, dynamic> json) => _$Claim_InsuranceFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_InsuranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Accident {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Date of an accident event  related to the products and services
// contained in the claim.
String date;

//  The type or context of the accident event for the purposes of
// selection of potential insurance coverages and determination of
// coordination between insurers.
CodeableConcept type;

//  The physical location of the accident event.
Address locationAddress;

//  The physical location of the accident event.
Reference locationReference;

Claim_Accident(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.date,
    this.type,
    this.locationAddress,
    this.locationReference,
    });

  factory Claim_Accident.fromJson(Map<String, dynamic> json) => _$Claim_AccidentFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_AccidentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify item entries.
int sequence;

//  CareTeam members related to this service or product.
List<int> careTeamSequence;

//  Diagnosis applicable for this service or product.
List<int> diagnosisSequence;

//  Procedures applicable for this service or product.
List<int> procedureSequence;

//  Exceptions, special conditions and supporting information applicable
// for this service or product.
List<int> informationSequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The date or dates when the service or product was supplied, performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the service or product was supplied, performed
// or completed.
Period servicedPeriod;

//  Where the product or service was provided.
CodeableConcept locationCodeableConcept;

//  Where the product or service was provided.
Address locationAddress;

//  Where the product or service was provided.
Reference locationReference;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

//  Physical service site on the patient (limb, tooth, etc.).
CodeableConcept bodySite;

//  A region or surface of the bodySite, e.g. limb region or tooth
// surface(s).
List<CodeableConcept> subSite;

//  The Encounters during which this Claim was created or to which the
// creation of this record is tightly associated.
List<Reference> encounter;

//  A claim detail line. Either a simple (a product or service) or a
// 'group' of sub-details which are simple items.
List<Claim_Detail> detail;

Claim_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.careTeamSequence,
    this.diagnosisSequence,
    this.procedureSequence,
    this.informationSequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.servicedDate,
    this.servicedPeriod,
    this.locationCodeableConcept,
    this.locationAddress,
    this.locationReference,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    this.bodySite,
    this.subSite,
    this.encounter,
    this.detail,
    });

  factory Claim_Item.fromJson(Map<String, dynamic> json) => _$Claim_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify item entries.
int sequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

//  A claim detail line. Either a simple (a product or service) or a
// 'group' of sub-details which are simple items.
List<Claim_SubDetail> subDetail;

Claim_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    this.subDetail,
    });

  factory Claim_Detail.fromJson(Map<String, dynamic> json) => _$Claim_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_DetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Claim_SubDetail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify item entries.
int sequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

Claim_SubDetail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    });

  factory Claim_SubDetail.fromJson(Map<String, dynamic> json) => _$Claim_SubDetailFromJson(json);
  Map<String, dynamic> toJson() => _$Claim_SubDetailToJson(this);
}

part 'claimResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class ClaimResponse {

//  This is a ClaimResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this claim response.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  A finer grained suite of claim type codes which may convey additional
// information such as Inpatient vs Outpatient and/or a specialty service.
CodeableConcept type;

//  A finer grained suite of claim type codes which may convey additional
// information such as Inpatient vs Outpatient and/or a specialty service.
CodeableConcept subType;

//  A code to indicate whether the nature of the request is: to request
// adjudication of products and services previously rendered; or
// requesting authorization and adjudication for provision in the future;
// or requesting the non-binding adjudication of the listed products and
// services which could be provided in the future.
String use;

//  The party to whom the professional services and/or products have been
// supplied or are being considered and for whom actual for facast
// reimbursement is sought.
Reference patient;

//  The date this resource was created.
DateTime created;

//  The party responsible for authorization, adjudication and
// reimbursement.
Reference insurer;

//  The provider which is responsible for the claim, predetermination or
// preauthorization.
Reference requestor;

//  Original request resource reference.
Reference request;

//  The outcome of the claim, predetermination, or preauthorization
// processing.
String outcome;

//  A human readable description of the status of the adjudication.
String disposition;

//  Reference from the Insurer which is used in later communications which
// refers to this adjudication.
String preAuthRef;

//  The time frame during which this authorization is effective.
Period preAuthPeriod;

//  Type of Party to be reimbursed: subscriber, provider, other.
CodeableConcept payeeType;

//  A claim line. Either a simple (a product or service) or a 'group' of
// details which can also be a simple items or groups of sub-details.
List<ClaimResponse_Item> item;

//  The first-tier service adjudications for payor added product or
// service lines.
List<ClaimResponse_AddItem> addItem;

//  The adjudication results which are presented at the header level
// rather than at the line-item or add-item levels.
List<ClaimResponse_Adjudication> adjudication;

//  Categorized monetary totals for the adjudication.
List<ClaimResponse_Total> total;

//  Payment details for the adjudication of the claim.
ClaimResponse_Payment payment;

//  A code, used only on a response to a preauthorization, to indicate
// whether the benefits payable have been reserved and for whom.
CodeableConcept fundsReserve;

//  A code for the form to be used for printing the content.
CodeableConcept formCode;

//  The actual form, by reference or inclusion, for printing the content
// or an EOB.
Attachment form;

//  A note that describes or explains adjudication results in a human
// readable form.
List<ClaimResponse_ProcessNote> processNote;

//  Request for additional supporting or authorizing information.
List<Reference> communicationRequest;

//  Financial instruments for reimbursement for the health care products
// and services specified on the claim.
List<ClaimResponse_Insurance> insurance;

//  Errors encountered during the processing of the adjudication.
List<ClaimResponse_Error> error;

ClaimResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.subType,
    this.use,
    this.patient,
    this.created,
    this.insurer,
    this.requestor,
    this.request,
    this.outcome,
    this.disposition,
    this.preAuthRef,
    this.preAuthPeriod,
    this.payeeType,
    this.item,
    this.addItem,
    this.adjudication,
    this.total,
    this.payment,
    this.fundsReserve,
    this.formCode,
    this.form,
    this.processNote,
    this.communicationRequest,
    this.insurance,
    this.error,
    });

  factory ClaimResponse.fromJson(Map<String, dynamic> json) => _$ClaimResponseFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely reference the claim item entries.
int itemSequence;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  If this item is a group then the values here are a summary of the
// adjudication of the detail items. If this item is a simple product or
// service then this is the result of the adjudication of this item.
List<ClaimResponse_Adjudication> adjudication;

//  A claim detail. Either a simple (a product or service) or a 'group' of
// sub-details which are simple items.
List<ClaimResponse_Detail> detail;

ClaimResponse_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemSequence,
    this.noteNumber,
    this.adjudication,
    this.detail,
    });

  factory ClaimResponse_Item.fromJson(Map<String, dynamic> json) => _$ClaimResponse_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Adjudication {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code to indicate the information type of this adjudication record.
// Information types may include the value submitted, maximum values or
// percentages allowed or payable under the plan, amounts that: the
// patient is responsible for in aggregate or pertaining to this item;
// amounts paid by other coverages; and, the benefit payable for this
// item.
CodeableConcept category;

//  A code supporting the understanding of the adjudication result and
// explaining variance from expected amount.
CodeableConcept reason;

//  Monetary amount associated with the category.
Money amount;

//  A non-monetary value associated with the category. Mutually exclusive
// to the amount element above.
double value;

ClaimResponse_Adjudication(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.reason,
    this.amount,
    this.value,
    });

  factory ClaimResponse_Adjudication.fromJson(Map<String, dynamic> json) => _$ClaimResponse_AdjudicationFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_AdjudicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely reference the claim detail entry.
int detailSequence;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ClaimResponse_Adjudication> adjudication;

//  A sub-detail adjudication of a simple product or service.
List<ClaimResponse_SubDetail> subDetail;

ClaimResponse_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.detailSequence,
    this.noteNumber,
    this.adjudication,
    this.subDetail,
    });

  factory ClaimResponse_Detail.fromJson(Map<String, dynamic> json) => _$ClaimResponse_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_DetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_SubDetail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely reference the claim sub-detail entry.
int subDetailSequence;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ClaimResponse_Adjudication> adjudication;

ClaimResponse_SubDetail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.subDetailSequence,
    this.noteNumber,
    this.adjudication,
    });

  factory ClaimResponse_SubDetail.fromJson(Map<String, dynamic> json) => _$ClaimResponse_SubDetailFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_SubDetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_AddItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Claim items which this service line is intended to replace.
List<int> itemSequence;

//  The sequence number of the details within the claim item which this
// line is intended to replace.
List<int> detailSequence;

//  The sequence number of the sub-details within the details within the
// claim item which this line is intended to replace.
List<int> subdetailSequence;

//  The providers who are authorized for the services rendered to the
// patient.
List<Reference> provider;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The date or dates when the service or product was supplied, performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the service or product was supplied, performed
// or completed.
Period servicedPeriod;

//  Where the product or service was provided.
CodeableConcept locationCodeableConcept;

//  Where the product or service was provided.
Address locationAddress;

//  Where the product or service was provided.
Reference locationReference;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Physical service site on the patient (limb, tooth, etc.).
CodeableConcept bodySite;

//  A region or surface of the bodySite, e.g. limb region or tooth
// surface(s).
List<CodeableConcept> subSite;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ClaimResponse_Adjudication> adjudication;

//  The second-tier service adjudications for payor added services.
List<ClaimResponse_Detail1> detail;

ClaimResponse_AddItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemSequence,
    this.detailSequence,
    this.subdetailSequence,
    this.provider,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.servicedDate,
    this.servicedPeriod,
    this.locationCodeableConcept,
    this.locationAddress,
    this.locationReference,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.bodySite,
    this.subSite,
    this.noteNumber,
    this.adjudication,
    this.detail,
    });

  factory ClaimResponse_AddItem.fromJson(Map<String, dynamic> json) => _$ClaimResponse_AddItemFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_AddItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Detail1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ClaimResponse_Adjudication> adjudication;

//  The third-tier service adjudications for payor added services.
List<ClaimResponse_SubDetail1> subDetail;

ClaimResponse_Detail1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.productOrService,
    this.modifier,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.noteNumber,
    this.adjudication,
    this.subDetail,
    });

  factory ClaimResponse_Detail1.fromJson(Map<String, dynamic> json) => _$ClaimResponse_Detail1FromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_Detail1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_SubDetail1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ClaimResponse_Adjudication> adjudication;

ClaimResponse_SubDetail1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.productOrService,
    this.modifier,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.noteNumber,
    this.adjudication,
    });

  factory ClaimResponse_SubDetail1.fromJson(Map<String, dynamic> json) => _$ClaimResponse_SubDetail1FromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_SubDetail1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Total {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code to indicate the information type of this adjudication record.
// Information types may include: the value submitted, maximum values or
// percentages allowed or payable under the plan, amounts that the patient
// is responsible for in aggregate or pertaining to this item, amounts
// paid by other coverages, and the benefit payable for this item.
CodeableConcept category;

//  Monetary total amount associated with the category.
Money amount;

ClaimResponse_Total(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.amount,
    });

  factory ClaimResponse_Total.fromJson(Map<String, dynamic> json) => _$ClaimResponse_TotalFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_TotalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Payment {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether this represents partial or complete payment of the benefits
// payable.
CodeableConcept type;

//  Total amount of all adjustments to this payment included in this
// transaction which are not related to this claim's adjudication.
Money adjustment;

//  Reason for the payment adjustment.
CodeableConcept adjustmentReason;

//  Estimated date the payment will be issued or the actual issue date of
// payment.
String date;

//  Benefits payable less any payment adjustment.
Money amount;

//  Issuer's unique identifier for the payment instrument.
Identifier identifier;

ClaimResponse_Payment(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.adjustment,
    this.adjustmentReason,
    this.date,
    this.amount,
    this.identifier,
    });

  factory ClaimResponse_Payment.fromJson(Map<String, dynamic> json) => _$ClaimResponse_PaymentFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_PaymentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_ProcessNote {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify a note entry.
int number;

//  The business purpose of the note text.
String type; // <code> enum: display/print/printoper;

//  The explanation or description associated with the processing.
String text;

//  A code to define the language used in the text of the note.
CodeableConcept language;

ClaimResponse_ProcessNote(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.number,
    this.type,
    this.text,
    this.language,
    });

  factory ClaimResponse_ProcessNote.fromJson(Map<String, dynamic> json) => _$ClaimResponse_ProcessNoteFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_ProcessNoteToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Insurance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify insurance entries and provide a sequence
// of coverages to convey coordination of benefit order.
int sequence;

//  A flag to indicate that this Coverage is to be used for adjudication
// of this claim when set to true.
bool focal;

//  Reference to the insurance card level information contained in the
// Coverage resource. The coverage issuing insurer will use these details
// to locate the patient's actual coverage within the insurer's
// information system.
Reference coverage;

//  A business agreement number established between the provider and the
// insurer for special business processing purposes.
String businessArrangement;

//  The result of the adjudication of the line items for the Coverage
// specified in this insurance.
Reference claimResponse;

ClaimResponse_Insurance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.focal,
    this.coverage,
    this.businessArrangement,
    this.claimResponse,
    });

  factory ClaimResponse_Insurance.fromJson(Map<String, dynamic> json) => _$ClaimResponse_InsuranceFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_InsuranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClaimResponse_Error {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The sequence number of the line item submitted which contains the
// error. This value is omitted when the error occurs outside of the item
// structure.
int itemSequence;

//  The sequence number of the detail within the line item submitted which
// contains the error. This value is omitted when the error occurs outside
// of the item structure.
int detailSequence;

//  The sequence number of the sub-detail within the detail within the
// line item submitted which contains the error. This value is omitted
// when the error occurs outside of the item structure.
int subDetailSequence;

//  An error code, from a specified code system, which details why the
// claim could not be adjudicated.
CodeableConcept code;

ClaimResponse_Error(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemSequence,
    this.detailSequence,
    this.subDetailSequence,
    this.code,
    });

  factory ClaimResponse_Error.fromJson(Map<String, dynamic> json) => _$ClaimResponse_ErrorFromJson(json);
  Map<String, dynamic> toJson() => _$ClaimResponse_ErrorToJson(this);
}

part 'clinicalImpression.g.dart';

@JsonSerializable(explicitToJson: true)
class ClinicalImpression {

//  This is a ClinicalImpression resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this clinical impression by the
// performer or other systems which remain constant as the resource is
// updated and propagates from server to server.
List<Identifier> identifier;

//  Identifies the workflow status of the assessment.
String status;

//  Captures the reason for the current state of the ClinicalImpression.
CodeableConcept statusReason;

//  Categorizes the type of clinical assessment performed.
CodeableConcept code;

//  A summary of the context and/or cause of the assessment - why / where
// it was performed, and what patient events/status prompted it.
String description;

//  The patient or group of individuals assessed as part of this record.
Reference subject;

//  The Encounter during which this ClinicalImpression was created or to
// which the creation of this record is tightly associated.
Reference encounter;

//  The point in time or period over which the subject was assessed.
String effectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The point in time or period over which the subject was assessed.
Period effectivePeriod;

//  Indicates when the documentation of the assessment was complete.
DateTime date;

//  The clinician performing the assessment.
Reference assessor;

//  A reference to the last assessment that was conducted on this patient.
// Assessments are often/usually ongoing in nature; a care provider
// (practitioner or team) will make new assessments on an ongoing basis as
// new data arises or the patient's conditions changes.
Reference previous;

//  A list of the relevant problems/conditions for a patient.
List<Reference> problem;

//  One or more sets of investigations (signs, symptoms, etc.). The actual
// grouping of investigations varies greatly depending on the type and
// context of the assessment. These investigations may include data
// generated during the assessment process, or data previously generated
// and recorded that is pertinent to the outcomes.
List<ClinicalImpression_Investigation> investigation;

//  Reference to a specific published clinical protocol that was followed
// during this assessment, and/or that provides evidence in support of the
// diagnosis.
List<String> protocol;

//  A text summary of the investigations and the diagnosis.
String summary;

//  Specific findings or diagnoses that were considered likely or relevant
// to ongoing treatment.
List<ClinicalImpression_Finding> finding;

//  Estimate of likely outcome.
List<CodeableConcept> prognosisCodeableConcept;

//  RiskAssessment expressing likely outcome.
List<Reference> prognosisReference;

//  Information supporting the clinical impression.
List<Reference> supportingInfo;

//  Commentary about the impression, typically recorded after the
// impression itself was made, though supplemental notes by the original
// author could also appear.
List<Annotation> note;

ClinicalImpression(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.statusReason,
    this.code,
    this.description,
    this.subject,
    this.encounter,
    this.effectiveDateTime,
    this.effectivePeriod,
    this.date,
    this.assessor,
    this.previous,
    this.problem,
    this.investigation,
    this.protocol,
    this.summary,
    this.finding,
    this.prognosisCodeableConcept,
    this.prognosisReference,
    this.supportingInfo,
    this.note,
    });

  factory ClinicalImpression.fromJson(Map<String, dynamic> json) => _$ClinicalImpressionFromJson(json);
  Map<String, dynamic> toJson() => _$ClinicalImpressionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClinicalImpression_Investigation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A name/code for the group ("set") of investigations. Typically, this
// will be something like "signs", "symptoms", "clinical", "diagnostic",
// but the list is not constrained, and others such groups such as
// (exposure|family|travel|nutritional) history may be used.
CodeableConcept code;

//  A record of a specific investigation that was undertaken.
List<Reference> item;

ClinicalImpression_Investigation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.item,
    });

  factory ClinicalImpression_Investigation.fromJson(Map<String, dynamic> json) => _$ClinicalImpression_InvestigationFromJson(json);
  Map<String, dynamic> toJson() => _$ClinicalImpression_InvestigationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ClinicalImpression_Finding {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specific text or code for finding or diagnosis, which may include
// ruled-out or resolved conditions.
CodeableConcept itemCodeableConcept;

//  Specific reference for finding or diagnosis, which may include
// ruled-out or resolved conditions.
Reference itemReference;

//  Which investigations support finding or diagnosis.
String basis;

ClinicalImpression_Finding(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemCodeableConcept,
    this.itemReference,
    this.basis,
    });

  factory ClinicalImpression_Finding.fromJson(Map<String, dynamic> json) => _$ClinicalImpression_FindingFromJson(json);
  Map<String, dynamic> toJson() => _$ClinicalImpression_FindingToJson(this);
}

part 'codeSystem.g.dart';

@JsonSerializable(explicitToJson: true)
class CodeSystem {

//  This is a CodeSystem resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this code system when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this code system is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the code
// system is stored on different servers. This is used in
// [Coding](datatypes.html#Coding).system.
String url;

//  A formal identifier that is used to identify this code system when it
// is represented in other formats, or referenced in a specification,
// model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the code
// system when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the code system author
// and is not expected to be globally unique. For example, it might be a
// timestamp (e.g. yyyymmdd) if a managed version is not available. There
// is also no expectation that versions can be placed in a lexicographical
// sequence. This is used in [Coding](datatypes.html#Coding).version.
String version;

//  A natural language name identifying the code system. This name should
// be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the code system.
String title;

//  The date (and optionally time) when the code system resource was
// created or revised.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this code system is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the code system was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the code system changes.
DateTime date;

//  The name of the organization or individual that published the code
// system.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the code system from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate code system instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the code system is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this code system is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the code system and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the code system.
String copyright;

//  If code comparison is case sensitive when codes within this system are
// compared to each other.
bool caseSensitive;

//  Canonical reference to the value set that contains the entire code
// system.
String valueSet;

//  The meaning of the hierarchy of concepts as represented in this
// resource.
String hierarchyMeaning; // <code> enum: grouped-by/is-a/part-of/classified-with;

//  The code system defines a compositional (post-coordination) grammar.
bool compositional;

//  This flag is used to signify that the code system does not commit to
// concept permanence across versions. If true, a version must be
// specified when referencing this code system.
bool versionNeeded;

//  The extent of the content of the code system (the concepts and codes
// it defines) are represented in this resource instance.
String content; // <code> enum: not-present/example/fragment/complete/supplement;

//  The canonical URL of the code system that this code system supplement
// is adding designations and properties to.
String supplements;

//  The total number of concepts defined by the code system. Where the
// code system has a compositional grammar, the basis of this count is
// defined by the system steward.
int count;

//  A filter that can be used in a value set compose statement when
// selecting concepts using a filter.
List<CodeSystem_Filter> filter;

//  A property defines an additional slot through which additional
// information can be provided about a concept.
List<CodeSystem_Property> property;

//  Concepts that are in the code system. The concept definitions are
// inherently hierarchical, but the definitions must be consulted to
// determine what the meanings of the hierarchical relationships are.
List<CodeSystem_Concept> concept;

CodeSystem(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.caseSensitive,
    this.valueSet,
    this.hierarchyMeaning,
    this.compositional,
    this.versionNeeded,
    this.content,
    this.supplements,
    this.count,
    this.filter,
    this.property,
    this.concept,
    });

  factory CodeSystem.fromJson(Map<String, dynamic> json) => _$CodeSystemFromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CodeSystem_Filter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The code that identifies this filter when it is used as a filter in
// [[[ValueSet]]].compose.include.filter.
String code;

//  A description of how or why the filter is used.
String description;

//  A list of operators that can be used with the filter.
List<String> operator;

//  A description of what the value for the filter should be.
String value;

CodeSystem_Filter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.description,
    this.operator,
    this.value,
    });

  factory CodeSystem_Filter.fromJson(Map<String, dynamic> json) => _$CodeSystem_FilterFromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystem_FilterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CodeSystem_Property {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code that is used to identify the property. The code is used
// internally (in CodeSystem.concept.property.code) and also externally,
// such as in property filters.
String code;

//  Reference to the formal meaning of the property. One possible source
// of meaning is the [Concept
// Properties](codesystem-concept-properties.html) code system.
String uri;

//  A description of the property- why it is defined, and how its value
// might be used.
String description;

//  The type of the property value. Properties of type "code" contain a
// code defined by the code system (e.g. a reference to another defined
// concept).
String type; // <code> enum: code/Coding/string/integer/boolean/dateTime/decimal;

CodeSystem_Property(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.uri,
    this.description,
    this.type,
    });

  factory CodeSystem_Property.fromJson(Map<String, dynamic> json) => _$CodeSystem_PropertyFromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystem_PropertyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CodeSystem_Concept {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code - a text symbol - that uniquely identifies the concept within
// the code system.
String code;

//  A human readable string that is the recommended default way to present
// this concept to a user.
String display;

//  The formal definition of the concept. The code system resource does
// not make formal definitions required, because of the prevalence of
// legacy systems. However, they are highly recommended, as without them
// there is no formal meaning associated with the concept.
String definition;

//  Additional representations for the concept - other languages, aliases,
// specialized purposes, used for particular purposes, etc.
List<CodeSystem_Designation> designation;

//  A property value for this concept.
List<CodeSystem_Property1> property;

//  Defines children of a concept to produce a hierarchy of concepts. The
// nature of the relationships is variable (is-a/contains/categorizes) -
// see hierarchyMeaning.
List<CodeSystem_Concept> concept;

CodeSystem_Concept(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.display,
    this.definition,
    this.designation,
    this.property,
    this.concept,
    });

  factory CodeSystem_Concept.fromJson(Map<String, dynamic> json) => _$CodeSystem_ConceptFromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystem_ConceptToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CodeSystem_Designation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The language this designation is defined for.
String language;

//  A code that details how this designation would be used.
Coding use;

//  The text value for this designation.
String value;

CodeSystem_Designation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.language,
    this.use,
    this.value,
    });

  factory CodeSystem_Designation.fromJson(Map<String, dynamic> json) => _$CodeSystem_DesignationFromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystem_DesignationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CodeSystem_Property1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code that is a reference to CodeSystem.property.code.
String code;

//  The value of this property.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The value of this property.
Coding valueCoding;

//  The value of this property.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The value of this property.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The value of this property.
bool valueBoolean; //  pattern: ^true|false$

//  The value of this property.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The value of this property.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

CodeSystem_Property1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.valueCode,
    this.valueCoding,
    this.valueString,
    this.valueInteger,
    this.valueBoolean,
    this.valueDateTime,
    this.valueDecimal,
    });

  factory CodeSystem_Property1.fromJson(Map<String, dynamic> json) => _$CodeSystem_Property1FromJson(json);
  Map<String, dynamic> toJson() => _$CodeSystem_Property1ToJson(this);
}

part 'communication.g.dart';

@JsonSerializable(explicitToJson: true)
class Communication {

//  This is a Communication resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this communication by the performer
// or other systems which remain constant as the resource is updated and
// propagates from server to server.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this
// Communication.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this Communication.
List<String> instantiatesUri;

//  An order, proposal or plan fulfilled in whole or in part by this
// Communication.
List<Reference> basedOn;

//  Part of this action.
List<Reference> partOf;

//  Prior communication that this communication is in response to.
List<Reference> inResponseTo;

//  The status of the transmission.
String status;

//  Captures the reason for the current state of the Communication.
CodeableConcept statusReason;

//  The type of message conveyed such as alert, notification, reminder,
// instruction, etc.
List<CodeableConcept> category;

//  Characterizes how quickly the planned or in progress communication
// must be addressed. Includes concepts such as stat, urgent, routine.
String priority;

//  A channel that was used for this communication (e.g. email, fax).
List<CodeableConcept> medium;

//  The patient or group that was the focus of this communication.
Reference subject;

//  Description of the purpose/content, similar to a subject line in an
// email.
CodeableConcept topic;

//  Other resources that pertain to this communication and to which this
// communication should be associated.
List<Reference> about;

//  The Encounter during which this Communication was created or to which
// the creation of this record is tightly associated.
Reference encounter;

//  The time when this communication was sent.
DateTime sent;

//  The time when this communication arrived at the destination.
DateTime received;

//  The entity (e.g. person, organization, clinical information system,
// care team or device) which was the target of the communication. If
// receipts need to be tracked by an individual, a separate resource
// instance will need to be created for each recipient.  Multiple
// recipient communications are intended where either receipts are not
// tracked (e.g. a mass mail-out) or a receipt is captured in aggregate
// (all emails confirmed received by a particular time).
List<Reference> recipient;

//  The entity (e.g. person, organization, clinical information system, or
// device) which was the source of the communication.
Reference sender;

//  The reason or justification for the communication.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies this
// communication.
List<Reference> reasonReference;

//  Text, attachment(s), or resource(s) that was communicated to the
// recipient.
List<Communication_Payload> payload;

//  Additional notes or commentary about the communication by the sender,
// receiver or other interested parties.
List<Annotation> note;

Communication(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.partOf,
    this.inResponseTo,
    this.status,
    this.statusReason,
    this.category,
    this.priority,
    this.medium,
    this.subject,
    this.topic,
    this.about,
    this.encounter,
    this.sent,
    this.received,
    this.recipient,
    this.sender,
    this.reasonCode,
    this.reasonReference,
    this.payload,
    this.note,
    });

  factory Communication.fromJson(Map<String, dynamic> json) => _$CommunicationFromJson(json);
  Map<String, dynamic> toJson() => _$CommunicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Communication_Payload {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A communicated content (or for multi-part communications, one portion
// of the communication).
String contentString; //  pattern: ^[ \r\n\t\S]+$

//  A communicated content (or for multi-part communications, one portion
// of the communication).
Attachment contentAttachment;

//  A communicated content (or for multi-part communications, one portion
// of the communication).
Reference contentReference;

Communication_Payload(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.contentString,
    this.contentAttachment,
    this.contentReference,
    });

  factory Communication_Payload.fromJson(Map<String, dynamic> json) => _$Communication_PayloadFromJson(json);
  Map<String, dynamic> toJson() => _$Communication_PayloadToJson(this);
}

part 'communicationRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class CommunicationRequest {

//  This is a CommunicationRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this communication request by the
// performer or other systems which remain constant as the resource is
// updated and propagates from server to server.
List<Identifier> identifier;

//  A plan or proposal that is fulfilled in whole or in part by this
// request.
List<Reference> basedOn;

//  Completed or terminated request(s) whose function is taken by this new
// request.
List<Reference> replaces;

//  A shared identifier common to all requests that were authorized more
// or less simultaneously by a single author, representing the identifier
// of the requisition, prescription or similar form.
Identifier groupIdentifier;

//  The status of the proposal or order.
String status;

//  Captures the reason for the current state of the CommunicationRequest.
CodeableConcept statusReason;

//  The type of message to be sent such as alert, notification, reminder,
// instruction, etc.
List<CodeableConcept> category;

//  Characterizes how quickly the proposed act must be initiated. Includes
// concepts such as stat, urgent, routine.
String priority;

//  If true indicates that the CommunicationRequest is asking for the
// specified action to *not* occur.
bool doNotPerform;

//  A channel that was used for this communication (e.g. email, fax).
List<CodeableConcept> medium;

//  The patient or group that is the focus of this communication request.
Reference subject;

//  Other resources that pertain to this communication request and to
// which this communication request should be associated.
List<Reference> about;

//  The Encounter during which this CommunicationRequest was created or to
// which the creation of this record is tightly associated.
Reference encounter;

//  Text, attachment(s), or resource(s) to be communicated to the
// recipient.
List<CommunicationRequest_Payload> payload;

//  The time when this communication is to occur.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The time when this communication is to occur.
Period occurrencePeriod;

//  For draft requests, indicates the date of initial creation.  For
// requests with other statuses, indicates the date of activation.
DateTime authoredOn;

//  The device, individual, or organization who initiated the request and
// has responsibility for its activation.
Reference requester;

//  The entity (e.g. person, organization, clinical information system,
// device, group, or care team) which is the intended target of the
// communication.
List<Reference> recipient;

//  The entity (e.g. person, organization, clinical information system, or
// device) which is to be the source of the communication.
Reference sender;

//  Describes why the request is being made in coded or textual form.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies this request.
List<Reference> reasonReference;

//  Comments made about the request by the requester, sender, recipient,
// subject or other participants.
List<Annotation> note;

CommunicationRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.replaces,
    this.groupIdentifier,
    this.status,
    this.statusReason,
    this.category,
    this.priority,
    this.doNotPerform,
    this.medium,
    this.subject,
    this.about,
    this.encounter,
    this.payload,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.authoredOn,
    this.requester,
    this.recipient,
    this.sender,
    this.reasonCode,
    this.reasonReference,
    this.note,
    });

  factory CommunicationRequest.fromJson(Map<String, dynamic> json) => _$CommunicationRequestFromJson(json);
  Map<String, dynamic> toJson() => _$CommunicationRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CommunicationRequest_Payload {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The communicated content (or for multi-part communications, one
// portion of the communication).
String contentString; //  pattern: ^[ \r\n\t\S]+$

//  The communicated content (or for multi-part communications, one
// portion of the communication).
Attachment contentAttachment;

//  The communicated content (or for multi-part communications, one
// portion of the communication).
Reference contentReference;

CommunicationRequest_Payload(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.contentString,
    this.contentAttachment,
    this.contentReference,
    });

  factory CommunicationRequest_Payload.fromJson(Map<String, dynamic> json) => _$CommunicationRequest_PayloadFromJson(json);
  Map<String, dynamic> toJson() => _$CommunicationRequest_PayloadToJson(this);
}

part 'compartmentDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class CompartmentDefinition {

//  This is a CompartmentDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this compartment definition
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this compartment definition is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the compartment definition is stored on different servers.
String url;

//  The identifier that is used to identify this version of the
// compartment definition when it is referenced in a specification, model,
// design or instance. This is an arbitrary value managed by the
// compartment definition author and is not expected to be globally
// unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
// managed version is not available. There is also no expectation that
// versions can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the compartment definition. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  The status of this compartment definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this compartment definition is
// authored for testing purposes (or education/evaluation/marketing) and
// is not intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the compartment definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the compartment definition
// changes.
DateTime date;

//  The name of the organization or individual that published the
// compartment definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the compartment definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate compartment definition instances.
List<UsageContext> useContext;

//  Explanation of why this compartment definition is needed and why it
// has been designed as it has.
String purpose;

//  Which compartment this definition describes.
String code; // <code> enum: Patient/Encounter/RelatedPerson/Practitioner/Device;

//  Whether the search syntax is supported,.
bool search;

//  Information about how a resource is related to the compartment.
List<CompartmentDefinition_Resource> resource;

CompartmentDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.purpose,
    this.code,
    this.search,
    this.resource,
    });

  factory CompartmentDefinition.fromJson(Map<String, dynamic> json) => _$CompartmentDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$CompartmentDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CompartmentDefinition_Resource {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of a resource supported by the server.
String code;

//  The name of a search parameter that represents the link to the
// compartment. More than one may be listed because a resource may be
// linked to a compartment in more than one way,.
List<String> param;

//  Additional documentation about the resource and compartment.
String documentation;

CompartmentDefinition_Resource(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.param,
    this.documentation,
    });

  factory CompartmentDefinition_Resource.fromJson(Map<String, dynamic> json) => _$CompartmentDefinition_ResourceFromJson(json);
  Map<String, dynamic> toJson() => _$CompartmentDefinition_ResourceToJson(this);
}

part 'composition.g.dart';

@JsonSerializable(explicitToJson: true)
class Composition {

//  This is a Composition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A version-independent identifier for the Composition. This identifier
// stays constant as the composition is changed over time.
Identifier identifier;

//  The workflow/clinical status of this composition. The status is a
// marker for the clinical standing of the document.
String status; // <code> enum: preliminary/final/amended/entered-in-error;

//  Specifies the particular kind of composition (e.g. History and
// Physical, Discharge Summary, Progress Note). This usually equates to
// the purpose of making the composition.
CodeableConcept type;

//  A categorization for the type of the composition - helps for indexing
// and searching. This may be implied by or derived from the code
// specified in the Composition Type.
List<CodeableConcept> category;

//  Who or what the composition is about. The composition can be about a
// person, (patient or healthcare practitioner), a device (e.g. a machine)
// or even a group of subjects (such as a document about a herd of
// livestock, or a set of patients that share a common exposure).
Reference subject;

//  Describes the clinical encounter or type of care this documentation is
// associated with.
Reference encounter;

//  The composition editing time, when the composition was last logically
// changed by the author.
DateTime date;

//  Identifies who is responsible for the information in the composition,
// not necessarily who typed it in.
List<Reference> author;

//  Official human-readable label for the composition.
String title;

//  The code specifying the level of confidentiality of the Composition.
String confidentiality;

//  A participant who has attested to the accuracy of the
// composition/document.
List<Composition_Attester> attester;

//  Identifies the organization or group who is responsible for ongoing
// maintenance of and access to the composition/document information.
Reference custodian;

//  Relationships that this composition has with other compositions or
// documents that already exist.
List<Composition_RelatesTo> relatesTo;

//  The clinical service, such as a colonoscopy or an appendectomy, being
// documented.
List<Composition_Event> event;

//  The root of the sections that make up the composition.
List<Composition_Section> section;

Composition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.category,
    this.subject,
    this.encounter,
    this.date,
    this.author,
    this.title,
    this.confidentiality,
    this.attester,
    this.custodian,
    this.relatesTo,
    this.event,
    this.section,
    });

  factory Composition.fromJson(Map<String, dynamic> json) => _$CompositionFromJson(json);
  Map<String, dynamic> toJson() => _$CompositionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Composition_Attester {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of attestation the authenticator offers.
String mode; // <code> enum: personal/professional/legal/official;

//  When the composition was attested by the party.
DateTime time;

//  Who attested the composition in the specified way.
Reference party;

Composition_Attester(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.time,
    this.party,
    });

  factory Composition_Attester.fromJson(Map<String, dynamic> json) => _$Composition_AttesterFromJson(json);
  Map<String, dynamic> toJson() => _$Composition_AttesterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Composition_RelatesTo {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of relationship that this composition has with anther
// composition or document.
String code;

//  The target composition/document of this relationship.
Identifier targetIdentifier;

//  The target composition/document of this relationship.
Reference targetReference;

Composition_RelatesTo(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.targetIdentifier,
    this.targetReference,
    });

  factory Composition_RelatesTo.fromJson(Map<String, dynamic> json) => _$Composition_RelatesToFromJson(json);
  Map<String, dynamic> toJson() => _$Composition_RelatesToToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Composition_Event {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  This list of codes represents the main clinical acts, such as a
// colonoscopy or an appendectomy, being documented. In some cases, the
// event is inherent in the typeCode, such as a "History and Physical
// Report" in which the procedure being documented is necessarily a
// "History and Physical" act.
List<CodeableConcept> code;

//  The period of time covered by the documentation. There is no assertion
// that the documentation is a complete representation for this period,
// only that it documents events during this time.
Period period;

//  The description and/or reference of the event(s) being documented. For
// example, this could be used to document such a colonoscopy or an
// appendectomy.
List<Reference> detail;

Composition_Event(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.period,
    this.detail,
    });

  factory Composition_Event.fromJson(Map<String, dynamic> json) => _$Composition_EventFromJson(json);
  Map<String, dynamic> toJson() => _$Composition_EventToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Composition_Section {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The label for this particular section.  This will be part of the
// rendered content for the document, and is often used to build a table
// of contents.
String title;

//  A code identifying the kind of content contained within the section.
// This must be consistent with the section title.
CodeableConcept code;

//  Identifies who is responsible for the information in this section, not
// necessarily who typed it in.
List<Reference> author;

//  The actual focus of the section when it is not the subject of the
// composition, but instead represents something or someone associated
// with the subject such as (for a patient subject) a spouse, parent,
// fetus, or donor. If not focus is specified, the focus is assumed to be
// focus of the parent section, or, for a section in the Composition
// itself, the subject of the composition. Sections with a focus SHALL
// only include resources where the logical subject (patient, subject,
// focus, etc.) matches the section focus, or the resources have no
// logical subject (few resources).
Reference focus;

//  A human-readable narrative that contains the attested content of the
// section, used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative.
Narrative text;

//  How the entry list was prepared - whether it is a working list that is
// suitable for being maintained on an ongoing basis, or if it represents
// a snapshot of a list of items from another source, or whether it is a
// prepared list where items may be marked as added, modified or deleted.
String mode;

//  Specifies the order applied to the items in the section entries.
CodeableConcept orderedBy;

//  A reference to the actual resource from which the narrative in the
// section is derived.
List<Reference> entry;

//  If the section is empty, why the list is empty. An empty section
// typically has some text explaining the empty reason.
CodeableConcept emptyReason;

//  A nested sub-section within this section.
List<Composition_Section> section;

Composition_Section(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.title,
    this.code,
    this.author,
    this.focus,
    this.text,
    this.mode,
    this.orderedBy,
    this.entry,
    this.emptyReason,
    this.section,
    });

  factory Composition_Section.fromJson(Map<String, dynamic> json) => _$Composition_SectionFromJson(json);
  Map<String, dynamic> toJson() => _$Composition_SectionToJson(this);
}

part 'conceptMap.g.dart';

@JsonSerializable(explicitToJson: true)
class ConceptMap {

//  This is a ConceptMap resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this concept map when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this concept map is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// concept map is stored on different servers.
String url;

//  A formal identifier that is used to identify this concept map when it
// is represented in other formats, or referenced in a specification,
// model, design or an instance.
Identifier identifier;

//  The identifier that is used to identify this version of the concept
// map when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the concept map author
// and is not expected to be globally unique. For example, it might be a
// timestamp (e.g. yyyymmdd) if a managed version is not available. There
// is also no expectation that versions can be placed in a lexicographical
// sequence.
String version;

//  A natural language name identifying the concept map. This name should
// be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the concept map.
String title;

//  The status of this concept map. Enables tracking the life-cycle of the
// content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this concept map is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the concept map was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the concept map changes.
DateTime date;

//  The name of the organization or individual that published the concept
// map.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the concept map from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate concept map instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the concept map is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this concept map is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the concept map and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the concept map.
String copyright;

//  Identifier for the source value set that contains the concepts that
// are being mapped and provides context for the mappings.
String sourceUri; //  pattern: ^\S*$

//  Identifier for the source value set that contains the concepts that
// are being mapped and provides context for the mappings.
String sourceCanonical; //  pattern: ^\S*$

//  The target value set provides context for the mappings. Note that the
// mapping is made between concepts, not between value sets, but the value
// set provides important context about how the concept mapping choices
// are made.
String targetUri; //  pattern: ^\S*$

//  The target value set provides context for the mappings. Note that the
// mapping is made between concepts, not between value sets, but the value
// set provides important context about how the concept mapping choices
// are made.
String targetCanonical; //  pattern: ^\S*$

//  A group of mappings that all have the same source and target system.
List<ConceptMap_Group> group;

ConceptMap(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.sourceUri,
    this.sourceCanonical,
    this.targetUri,
    this.targetCanonical,
    this.group,
    });

  factory ConceptMap.fromJson(Map<String, dynamic> json) => _$ConceptMapFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMapToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ConceptMap_Group {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that identifies the source system where the concepts
// to be mapped are defined.
String source;

//  The specific version of the code system, as determined by the code
// system authority.
String sourceVersion;

//  An absolute URI that identifies the target system that the concepts
// will be mapped to.
String target;

//  The specific version of the code system, as determined by the code
// system authority.
String targetVersion;

//  Mappings for an individual concept in the source to one or more
// concepts in the target.
List<ConceptMap_Element> element;

//  What to do when there is no mapping for the source concept. "Unmapped"
// does not include codes that are unmatched, and the unmapped element is
// ignored in a code is specified to have equivalence = unmatched.
ConceptMap_Unmapped unmapped;

ConceptMap_Group(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.source,
    this.sourceVersion,
    this.target,
    this.targetVersion,
    this.element,
    this.unmapped,
    });

  factory ConceptMap_Group.fromJson(Map<String, dynamic> json) => _$ConceptMap_GroupFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMap_GroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ConceptMap_Element {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identity (code or path) or the element/item being mapped.
String code;

//  The display for the code. The display is only provided to help editors
// when editing the concept map.
String display;

//  A concept from the target value set that this concept maps to.
List<ConceptMap_Target> target;

ConceptMap_Element(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.display,
    this.target,
    });

  factory ConceptMap_Element.fromJson(Map<String, dynamic> json) => _$ConceptMap_ElementFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMap_ElementToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ConceptMap_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identity (code or path) or the element/item that the map refers to.
String code;

//  The display for the code. The display is only provided to help editors
// when editing the concept map.
String display;

//  The equivalence between the source and target concepts (counting for
// the dependencies and products). The equivalence is read from target to
// source (e.g. the target is 'wider' than the source).
String equivalence; // <code> enum: relatedto/equivalent/equal/wider/subsumes/narrower/specializes/inexact/unmatched/disjoint;

//  A description of status/issues in mapping that conveys additional
// information not represented in  the structured data.
String comment;

//  A set of additional dependencies for this mapping to hold. This
// mapping is only applicable if the specified element can be resolved,
// and it has the specified value.
List<ConceptMap_DependsOn> dependsOn;

//  A set of additional outcomes from this mapping to other elements. To
// properly execute this mapping, the specified element must be mapped to
// some data element or source that is in context. The mapping may still
// be useful without a place for the additional data elements, but the
// equivalence cannot be relied on.
List<ConceptMap_DependsOn> product;

ConceptMap_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.display,
    this.equivalence,
    this.comment,
    this.dependsOn,
    this.product,
    });

  factory ConceptMap_Target.fromJson(Map<String, dynamic> json) => _$ConceptMap_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMap_TargetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ConceptMap_DependsOn {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A reference to an element that holds a coded value that corresponds to
// a code system property. The idea is that the information model carries
// an element somewhere that is labeled to correspond with a code system
// property.
String property;

//  An absolute URI that identifies the code system of the dependency code
// (if the source/dependency is a value set that crosses code systems).
String system;

//  Identity (code or path) or the element/item/ValueSet/text that the map
// depends on / refers to.
String value;

//  The display for the code. The display is only provided to help editors
// when editing the concept map.
String display;

ConceptMap_DependsOn(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.property,
    this.system,
    this.value,
    this.display,
    });

  factory ConceptMap_DependsOn.fromJson(Map<String, dynamic> json) => _$ConceptMap_DependsOnFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMap_DependsOnToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ConceptMap_Unmapped {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Defines which action to take if there is no match for the source
// concept in the target system designated for the group. One of 3 actions
// are possible: use the unmapped code (this is useful when doing a
// mapping between versions, and only a few codes have changed), use a
// fixed code (a default code), or alternatively, a reference to a
// different concept map can be provided (by canonical URL).
String mode; // <code> enum: provided/fixed/other-map;

//  The fixed code to use when the mode = 'fixed'  - all unmapped codes
// are mapped to a single fixed code.
String code;

//  The display for the code. The display is only provided to help editors
// when editing the concept map.
String display;

//  The canonical reference to an additional ConceptMap resource instance
// to use for mapping if this ConceptMap resource contains no matching
// mapping for the source concept.
String url;

ConceptMap_Unmapped(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.mode,
    this.code,
    this.display,
    this.url,
    });

  factory ConceptMap_Unmapped.fromJson(Map<String, dynamic> json) => _$ConceptMap_UnmappedFromJson(json);
  Map<String, dynamic> toJson() => _$ConceptMap_UnmappedToJson(this);
}

part 'condition.g.dart';

@JsonSerializable(explicitToJson: true)
class Condition {

//  This is a Condition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this condition by the performer or
// other systems which remain constant as the resource is updated and
// propagates from server to server.
List<Identifier> identifier;

//  The clinical status of the condition.
CodeableConcept clinicalStatus;

//  The verification status to support the clinical status of the
// condition.
CodeableConcept verificationStatus;

//  A category assigned to the condition.
List<CodeableConcept> category;

//  A subjective assessment of the severity of the condition as evaluated
// by the clinician.
CodeableConcept severity;

//  Identification of the condition, problem or diagnosis.
CodeableConcept code;

//  The anatomical location where this condition manifests itself.
List<CodeableConcept> bodySite;

//  Indicates the patient or group who the condition record is associated
// with.
Reference subject;

//  The Encounter during which this Condition was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  Estimated or actual date or date-time  the condition began, in the
// opinion of the clinician.
String onsetDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Estimated or actual date or date-time  the condition began, in the
// opinion of the clinician.
Age onsetAge;

//  Estimated or actual date or date-time  the condition began, in the
// opinion of the clinician.
Period onsetPeriod;

//  Estimated or actual date or date-time  the condition began, in the
// opinion of the clinician.
Range onsetRange;

//  Estimated or actual date or date-time  the condition began, in the
// opinion of the clinician.
String onsetString; //  pattern: ^[ \r\n\t\S]+$

//  The date or estimated date that the condition resolved or went into
// remission. This is called "abatement" because of the many overloaded
// connotations associated with "remission" or "resolution" - Conditions
// are never really resolved, but they can abate.
String abatementDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date or estimated date that the condition resolved or went into
// remission. This is called "abatement" because of the many overloaded
// connotations associated with "remission" or "resolution" - Conditions
// are never really resolved, but they can abate.
Age abatementAge;

//  The date or estimated date that the condition resolved or went into
// remission. This is called "abatement" because of the many overloaded
// connotations associated with "remission" or "resolution" - Conditions
// are never really resolved, but they can abate.
Period abatementPeriod;

//  The date or estimated date that the condition resolved or went into
// remission. This is called "abatement" because of the many overloaded
// connotations associated with "remission" or "resolution" - Conditions
// are never really resolved, but they can abate.
Range abatementRange;

//  The date or estimated date that the condition resolved or went into
// remission. This is called "abatement" because of the many overloaded
// connotations associated with "remission" or "resolution" - Conditions
// are never really resolved, but they can abate.
String abatementString; //  pattern: ^[ \r\n\t\S]+$

//  The recordedDate represents when this particular Condition record was
// created in the system, which is often a system-generated date.
DateTime recordedDate;

//  Individual who recorded the record and takes responsibility for its
// content.
Reference recorder;

//  Individual who is making the condition statement.
Reference asserter;

//  Clinical stage or grade of a condition. May include formal severity
// assessments.
List<Condition_Stage> stage;

//  Supporting evidence / manifestations that are the basis of the
// Condition's verification status, such as evidence that confirmed or
// refuted the condition.
List<Condition_Evidence> evidence;

//  Additional information about the Condition. This is a general
// notes/comments entry  for description of the Condition, its diagnosis
// and prognosis.
List<Annotation> note;

Condition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.clinicalStatus,
    this.verificationStatus,
    this.category,
    this.severity,
    this.code,
    this.bodySite,
    this.subject,
    this.encounter,
    this.onsetDateTime,
    this.onsetAge,
    this.onsetPeriod,
    this.onsetRange,
    this.onsetString,
    this.abatementDateTime,
    this.abatementAge,
    this.abatementPeriod,
    this.abatementRange,
    this.abatementString,
    this.recordedDate,
    this.recorder,
    this.asserter,
    this.stage,
    this.evidence,
    this.note,
    });

  factory Condition.fromJson(Map<String, dynamic> json) => _$ConditionFromJson(json);
  Map<String, dynamic> toJson() => _$ConditionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Condition_Stage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A simple summary of the stage such as "Stage 3". The determination of
// the stage is disease-specific.
CodeableConcept summary;

//  Reference to a formal record of the evidence on which the staging
// assessment is based.
List<Reference> assessment;

//  The kind of staging, such as pathological or clinical staging.
CodeableConcept type;

Condition_Stage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.summary,
    this.assessment,
    this.type,
    });

  factory Condition_Stage.fromJson(Map<String, dynamic> json) => _$Condition_StageFromJson(json);
  Map<String, dynamic> toJson() => _$Condition_StageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Condition_Evidence {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A manifestation or symptom that led to the recording of this
// condition.
List<CodeableConcept> code;

//  Links to other relevant information, including pathology reports.
List<Reference> detail;

Condition_Evidence(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.detail,
    });

  factory Condition_Evidence.fromJson(Map<String, dynamic> json) => _$Condition_EvidenceFromJson(json);
  Map<String, dynamic> toJson() => _$Condition_EvidenceToJson(this);
}

part 'consent.g.dart';

@JsonSerializable(explicitToJson: true)
class Consent {

//  This is a Consent resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for this copy of the Consent Statement.
List<Identifier> identifier;

//  Indicates the current state of this consent.
String status; // <code> enum: draft/proposed/active/rejected/inactive/entered-in-error;

//  A selector of the type of consent being presented: ADR, Privacy,
// Treatment, Research.  This list is now extensible.
CodeableConcept scope;

//  A classification of the type of consents found in the statement. This
// element supports indexing and retrieval of consent statements.
List<CodeableConcept> category;

//  The patient/healthcare consumer to whom this consent applies.
Reference patient;

//  When this  Consent was issued / created / indexed.
DateTime dateTime;

//  Either the Grantor, which is the entity responsible for granting the
// rights listed in a Consent Directive or the Grantee, which is the
// entity responsible for complying with the Consent Directive, including
// any obligations or limitations on authorizations and enforcement of
// prohibitions.
List<Reference> performer;

//  The organization that manages the consent, and the framework within
// which it is executed.
List<Reference> organization;

//  The source on which this consent statement is based. The source might
// be a scanned original paper form, or a reference to a consent that
// links back to such a source, a reference to a document repository (e.g.
// XDS) that stores the original consent document.
Attachment sourceAttachment;

//  The source on which this consent statement is based. The source might
// be a scanned original paper form, or a reference to a consent that
// links back to such a source, a reference to a document repository (e.g.
// XDS) that stores the original consent document.
Reference sourceReference;

//  The references to the policies that are included in this consent
// scope. Policies may be organizational, but are often defined
// jurisdictionally, or in law.
List<Consent_Policy> policy;

//  A reference to the specific base computable regulation or policy.
CodeableConcept policyRule;

//  Whether a treatment instruction (e.g. artificial respiration yes or
// no) was verified with the patient, his/her family or another authorized
// person.
List<Consent_Verification> verification;

//  An exception to the base policy of this consent. An exception can be
// an addition or removal of access permissions.
Consent_Provision provision;

Consent(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.scope,
    this.category,
    this.patient,
    this.dateTime,
    this.performer,
    this.organization,
    this.sourceAttachment,
    this.sourceReference,
    this.policy,
    this.policyRule,
    this.verification,
    this.provision,
    });

  factory Consent.fromJson(Map<String, dynamic> json) => _$ConsentFromJson(json);
  Map<String, dynamic> toJson() => _$ConsentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Consent_Policy {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Entity or Organization having regulatory jurisdiction or
// accountability for  enforcing policies pertaining to Consent
// Directives.
String authority;

//  The references to the policies that are included in this consent
// scope. Policies may be organizational, but are often defined
// jurisdictionally, or in law.
String uri;

Consent_Policy(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.authority,
    this.uri,
    });

  factory Consent_Policy.fromJson(Map<String, dynamic> json) => _$Consent_PolicyFromJson(json);
  Map<String, dynamic> toJson() => _$Consent_PolicyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Consent_Verification {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Has the instruction been verified.
bool verified;

//  Who verified the instruction (Patient, Relative or other Authorized
// Person).
Reference verifiedWith;

//  Date verification was collected.
DateTime verificationDate;

Consent_Verification(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.verified,
    this.verifiedWith,
    this.verificationDate,
    });

  factory Consent_Verification.fromJson(Map<String, dynamic> json) => _$Consent_VerificationFromJson(json);
  Map<String, dynamic> toJson() => _$Consent_VerificationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Consent_Provision {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Action  to take - permit or deny - when the rule conditions are met. 
// Not permitted in root rule, required in all nested rules.
String type; // <code> enum: deny/permit;

//  The timeframe in this rule is valid.
Period period;

//  Who or what is controlled by this rule. Use group to identify a set of
// actors by some property they share (e.g. 'admitting officers').
List<Consent_Actor> actor;

//  Actions controlled by this Rule.
List<CodeableConcept> action;

//  A security label, comprised of 0..* security label fields (Privacy
// tags), which define which resources are controlled by this exception.
List<Coding> securityLabel;

//  The context of the activities a user is taking - why the user is
// accessing the data - that are controlled by this rule.
List<Coding> purpose;

//  The class of information covered by this rule. The type can be a FHIR
// resource type, a profile on a type, or a CDA document, or some other
// type that indicates what sort of information the consent relates to.
List<Coding> class;

//  If this code is found in an instance, then the rule applies.
List<CodeableConcept> code;

//  Clinical or Operational Relevant period of time that bounds the data
// controlled by this rule.
Period dataPeriod;

//  The resources controlled by this rule if specific resources are
// referenced.
List<Consent_Data> data;

//  Rules which provide exceptions to the base rule or subrules.
List<Consent_Provision> provision;

Consent_Provision(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.period,
    this.actor,
    this.action,
    this.securityLabel,
    this.purpose,
    this.class,
    this.code,
    this.dataPeriod,
    this.data,
    this.provision,
    });

  factory Consent_Provision.fromJson(Map<String, dynamic> json) => _$Consent_ProvisionFromJson(json);
  Map<String, dynamic> toJson() => _$Consent_ProvisionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Consent_Actor {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  How the individual is involved in the resources content that is
// described in the exception.
CodeableConcept role;

//  The resource that identifies the actor. To identify actors by type,
// use group to identify a set of actors by some property they share (e.g.
// 'admitting officers').
Reference reference;

Consent_Actor(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.role,
    this.reference,
    });

  factory Consent_Actor.fromJson(Map<String, dynamic> json) => _$Consent_ActorFromJson(json);
  Map<String, dynamic> toJson() => _$Consent_ActorToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Consent_Data {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  How the resource reference is interpreted when testing consent
// restrictions.
String meaning; // <code> enum: instance/related/dependents/authoredby;

//  A reference to a specific resource that defines which resources are
// covered by this consent.
Reference reference;

Consent_Data(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.meaning,
    this.reference,
    });

  factory Consent_Data.fromJson(Map<String, dynamic> json) => _$Consent_DataFromJson(json);
  Map<String, dynamic> toJson() => _$Consent_DataToJson(this);
}

part 'contract.g.dart';

@JsonSerializable(explicitToJson: true)
class Contract {

//  This is a Contract resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for this Contract or a derivative that references a
// Source Contract.
List<Identifier> identifier;

//  Canonical identifier for this contract, represented as a URI (globally
// unique).
String url;

//  An edition identifier used for business purposes to label business
// significant variants.
String version;

//  The status of the resource instance.
String status;

//  Legal states of the formation of a legal instrument, which is a
// formally executed written document that can be formally attributed to
// its author, records and formally expresses a legally enforceable act,
// process, or contractual duty, obligation, or right, and therefore
// evidences that act, process, or agreement.
CodeableConcept legalState;

//  The URL pointing to a FHIR-defined Contract Definition that is adhered
// to in whole or part by this Contract.
Reference instantiatesCanonical;

//  The URL pointing to an externally maintained definition that is
// adhered to in whole or in part by this Contract.
String instantiatesUri;

//  The minimal content derived from the basal information source at a
// specific stage in its lifecycle.
CodeableConcept contentDerivative;

//  When this  Contract was issued.
DateTime issued;

//  Relevant time or time-period when this Contract is applicable.
Period applies;

//  Event resulting in discontinuation or termination of this Contract
// instance by one or more parties to the contract.
CodeableConcept expirationType;

//  The target entity impacted by or of interest to parties to the
// agreement.
List<Reference> subject;

//  A formally or informally recognized grouping of people, principals,
// organizations, or jurisdictions formed for the purpose of achieving
// some form of collective action such as the promulgation, administration
// and enforcement of contracts and policies.
List<Reference> authority;

//  Recognized governance framework or system operating with a
// circumscribed scope in accordance with specified principles, policies,
// processes or procedures for managing rights, actions, or behaviors of
// parties or principals relative to resources.
List<Reference> domain;

//  Sites in which the contract is complied with,  exercised, or in force.
List<Reference> site;

//  A natural language name identifying this Contract definition,
// derivative, or instance in any legal state. Provides additional
// information about its content. This name should be usable as an
// identifier for the module by machine processing applications such as
// code generation.
String name;

//  A short, descriptive, user-friendly title for this Contract
// definition, derivative, or instance in any legal state.t giving
// additional information about its content.
String title;

//  An explanatory or alternate user-friendly title for this Contract
// definition, derivative, or instance in any legal state.t giving
// additional information about its content.
String subtitle;

//  Alternative representation of the title for this Contract definition,
// derivative, or instance in any legal state., e.g., a domain specific
// contract number related to legislation.
List<String> alias;

//  The individual or organization that authored the Contract definition,
// derivative, or instance in any legal state.
Reference author;

//  A selector of legal concerns for this Contract definition, derivative,
// or instance in any legal state.
CodeableConcept scope;

//  Narrows the range of legal concerns to focus on the achievement of
// specific contractual objectives.
CodeableConcept topicCodeableConcept;

//  Narrows the range of legal concerns to focus on the achievement of
// specific contractual objectives.
Reference topicReference;

//  A high-level category for the legal instrument, whether constructed as
// a Contract definition, derivative, or instance in any legal state. 
// Provides additional information about its content within the context of
// the Contract's scope to distinguish the kinds of systems that would be
// interested in the contract.
CodeableConcept type;

//  Sub-category for the Contract that distinguishes the kinds of systems
// that would be interested in the Contract within the context of the
// Contract's scope.
List<CodeableConcept> subType;

//  Precusory content developed with a focus and intent of supporting the
// formation a Contract instance, which may be associated with and
// transformable into a Contract.
Contract_ContentDefinition contentDefinition;

//  One or more Contract Provisions, which may be related and conveyed as
// a group, and may contain nested groups.
List<Contract_Term> term;

//  Information that may be needed by/relevant to the performer in their
// execution of this term action.
List<Reference> supportingInfo;

//  Links to Provenance records for past versions of this Contract
// definition, derivative, or instance, which identify key state
// transitions or updates that are likely to be relevant to a user looking
// at the current version of the Contract.  The Provence.entity indicates
// the target that was changed in the update.
// http://build.fhir.org/provenance-definitions.html#Provenance.entity.
List<Reference> relevantHistory;

//  Parties with legal standing in the Contract, including the principal
// parties, the grantor(s) and grantee(s), which are any person or
// organization bound by the contract, and any ancillary parties, which
// facilitate the execution of the contract such as a notary or witness.
List<Contract_Signer> signer;

//  The "patient friendly language" versionof the Contract in whole or in
// parts. "Patient friendly language" means the representation of the
// Contract and Contract Provisions in a manner that is readily accessible
// and understandable by a layperson in accordance with best practices for
// communication styles that ensure that those agreeing to or signing the
// Contract understand the roles, actions, obligations, responsibilities,
// and implication of the agreement.
List<Contract_Friendly> friendly;

//  List of Legal expressions or representations of this Contract.
List<Contract_Legal> legal;

//  List of Computable Policy Rule Language Representations of this
// Contract.
List<Contract_Rule> rule;

//  Legally binding Contract: This is the signed and legally recognized
// representation of the Contract, which is considered the "source of
// truth" and which would be the basis for legal action related to
// enforcement of this Contract.
Attachment legallyBindingAttachment;

//  Legally binding Contract: This is the signed and legally recognized
// representation of the Contract, which is considered the "source of
// truth" and which would be the basis for legal action related to
// enforcement of this Contract.
Reference legallyBindingReference;

Contract(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.url,
    this.version,
    this.status,
    this.legalState,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.contentDerivative,
    this.issued,
    this.applies,
    this.expirationType,
    this.subject,
    this.authority,
    this.domain,
    this.site,
    this.name,
    this.title,
    this.subtitle,
    this.alias,
    this.author,
    this.scope,
    this.topicCodeableConcept,
    this.topicReference,
    this.type,
    this.subType,
    this.contentDefinition,
    this.term,
    this.supportingInfo,
    this.relevantHistory,
    this.signer,
    this.friendly,
    this.legal,
    this.rule,
    this.legallyBindingAttachment,
    this.legallyBindingReference,
    });

  factory Contract.fromJson(Map<String, dynamic> json) => _$ContractFromJson(json);
  Map<String, dynamic> toJson() => _$ContractToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_ContentDefinition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Precusory content structure and use, i.e., a boilerplate, template,
// application for a contract such as an insurance policy or benefits
// under a program, e.g., workers compensation.
CodeableConcept type;

//  Detailed Precusory content type.
CodeableConcept subType;

//  The  individual or organization that published the Contract precursor
// content.
Reference publisher;

//  The date (and optionally time) when the contract was published. The
// date must change when the business version changes and it must change
// if the status code changes. In addition, it should change when the
// substantive content of the contract changes.
DateTime publicationDate;

//  amended | appended | cancelled | disputed | entered-in-error |
// executable | executed | negotiable | offered | policy | rejected |
// renewed | revoked | resolved | terminated.
String publicationStatus;

//  A copyright statement relating to Contract precursor content.
// Copyright statements are generally legal restrictions on the use and
// publishing of the Contract precursor content.
String copyright;

Contract_ContentDefinition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.subType,
    this.publisher,
    this.publicationDate,
    this.publicationStatus,
    this.copyright,
    });

  factory Contract_ContentDefinition.fromJson(Map<String, dynamic> json) => _$Contract_ContentDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_ContentDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Term {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for this particular Contract Provision.
Identifier identifier;

//  When this Contract Provision was issued.
DateTime issued;

//  Relevant time or time-period when this Contract Provision is
// applicable.
Period applies;

//  The entity that the term applies to.
CodeableConcept topicCodeableConcept;

//  The entity that the term applies to.
Reference topicReference;

//  A legal clause or condition contained within a contract that requires
// one or both parties to perform a particular requirement by some
// specified time or prevents one or both parties from performing a
// particular requirement by some specified time.
CodeableConcept type;

//  A specialized legal clause or condition based on overarching contract
// type.
CodeableConcept subType;

//  Statement of a provision in a policy or a contract.
String text;

//  Security labels that protect the handling of information about the
// term and its elements, which may be specifically identified..
List<Contract_SecurityLabel> securityLabel;

//  The matter of concern in the context of this provision of the
// agrement.
Contract_Offer offer;

//  Contract Term Asset List.
List<Contract_Asset> asset;

//  An actor taking a role in an activity for which it can be assigned
// some degree of responsibility for the activity taking place.
List<Contract_Action> action;

//  Nested group of Contract Provisions.
List<Contract_Term> group;

Contract_Term(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.issued,
    this.applies,
    this.topicCodeableConcept,
    this.topicReference,
    this.type,
    this.subType,
    this.text,
    this.securityLabel,
    this.offer,
    this.asset,
    this.action,
    this.group,
    });

  factory Contract_Term.fromJson(Map<String, dynamic> json) => _$Contract_TermFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_TermToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_SecurityLabel {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Number used to link this term or term element to the applicable
// Security Label.
List<int> number;

//  Security label privacy tag that species the level of confidentiality
// protection required for this term and/or term elements.
Coding classification;

//  Security label privacy tag that species the applicable privacy and
// security policies governing this term and/or term elements.
List<Coding> category;

//  Security label privacy tag that species the manner in which term
// and/or term elements are to be protected.
List<Coding> control;

Contract_SecurityLabel(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.number,
    this.classification,
    this.category,
    this.control,
    });

  factory Contract_SecurityLabel.fromJson(Map<String, dynamic> json) => _$Contract_SecurityLabelFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_SecurityLabelToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Offer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for this particular Contract Provision.
List<Identifier> identifier;

//  Offer Recipient.
List<Contract_Party> party;

//  The owner of an asset has the residual control rights over the asset:
// the right to decide all usages of the asset in any way not inconsistent
// with a prior contract, custom, or law (Hart, 1995, p. 30).
Reference topic;

//  Type of Contract Provision such as specific requirements, purposes for
// actions, obligations, prohibitions, e.g. life time maximum benefit.
CodeableConcept type;

//  Type of choice made by accepting party with respect to an offer made
// by an offeror/ grantee.
CodeableConcept decision;

//  How the decision about a Contract was conveyed.
List<CodeableConcept> decisionMode;

//  Response to offer text.
List<Contract_Answer> answer;

//  Human readable form of this Contract Offer.
String text;

//  The id of the clause or question text of the offer in the referenced
// questionnaire/response.
List<String> linkId;

//  Security labels that protects the offer.
List<int> securityLabelNumber;

Contract_Offer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.party,
    this.topic,
    this.type,
    this.decision,
    this.decisionMode,
    this.answer,
    this.text,
    this.linkId,
    this.securityLabelNumber,
    });

  factory Contract_Offer.fromJson(Map<String, dynamic> json) => _$Contract_OfferFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_OfferToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Party {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Participant in the offer.
List<Reference> reference;

//  How the party participates in the offer.
CodeableConcept role;

Contract_Party(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.reference,
    this.role,
    });

  factory Contract_Party.fromJson(Map<String, dynamic> json) => _$Contract_PartyFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_PartyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Answer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
bool valueBoolean; //  pattern: ^true|false$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
String valueUri; //  pattern: ^\S*$

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
Attachment valueAttachment;

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
Coding valueCoding;

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
Quantity valueQuantity;

//  Response to an offer clause or question text,  which enables selection
// of values to be agreed to, e.g., the period of participation, the date
// of occupancy of a rental, warrently duration, or whether biospecimen
// may be used for further research.
Reference valueReference;

Contract_Answer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.valueBoolean,
    this.valueDecimal,
    this.valueInteger,
    this.valueDate,
    this.valueDateTime,
    this.valueTime,
    this.valueString,
    this.valueUri,
    this.valueAttachment,
    this.valueCoding,
    this.valueQuantity,
    this.valueReference,
    });

  factory Contract_Answer.fromJson(Map<String, dynamic> json) => _$Contract_AnswerFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_AnswerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Asset {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Differentiates the kind of the asset .
CodeableConcept scope;

//  Target entity type about which the term may be concerned.
List<CodeableConcept> type;

//  Associated entities.
List<Reference> typeReference;

//  May be a subtype or part of an offered asset.
List<CodeableConcept> subtype;

//  Specifies the applicability of the term to an asset resource instance,
// and instances it refers to orinstances that refer to it, and/or are
// owned by the offeree.
Coding relationship;

//  Circumstance of the asset.
List<Contract_Context> context;

//  Description of the quality and completeness of the asset that imay be
// a factor in its valuation.
String condition;

//  Type of Asset availability for use or ownership.
List<CodeableConcept> periodType;

//  Asset relevant contractual time period.
List<Period> period;

//  Time period of asset use.
List<Period> usePeriod;

//  Clause or question text (Prose Object) concerning the asset in a
// linked form, such as a QuestionnaireResponse used in the formation of
// the contract.
String text;

//  Id [identifier??] of the clause or question text about the asset in
// the referenced form or QuestionnaireResponse.
List<String> linkId;

//  Response to assets.
List<Contract_Answer> answer;

//  Security labels that protects the asset.
List<int> securityLabelNumber;

//  Contract Valued Item List.
List<Contract_ValuedItem> valuedItem;

Contract_Asset(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.scope,
    this.type,
    this.typeReference,
    this.subtype,
    this.relationship,
    this.context,
    this.condition,
    this.periodType,
    this.period,
    this.usePeriod,
    this.text,
    this.linkId,
    this.answer,
    this.securityLabelNumber,
    this.valuedItem,
    });

  factory Contract_Asset.fromJson(Map<String, dynamic> json) => _$Contract_AssetFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_AssetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Context {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Asset context reference may include the creator, custodian, or owning
// Person or Organization (e.g., bank, repository),  location held, e.g.,
// building,  jurisdiction.
Reference reference;

//  Coded representation of the context generally or of the Referenced
// entity, such as the asset holder type or location.
List<CodeableConcept> code;

//  Context description.
String text;

Contract_Context(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.reference,
    this.code,
    this.text,
    });

  factory Contract_Context.fromJson(Map<String, dynamic> json) => _$Contract_ContextFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_ContextToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_ValuedItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specific type of Contract Valued Item that may be priced.
CodeableConcept entityCodeableConcept;

//  Specific type of Contract Valued Item that may be priced.
Reference entityReference;

//  Identifies a Contract Valued Item instance.
Identifier identifier;

//  Indicates the time during which this Contract ValuedItem information
// is effective.
DateTime effectiveTime;

//  Specifies the units by which the Contract Valued Item is measured or
// counted, and quantifies the countable or measurable Contract Valued
// Item instances.
Quantity quantity;

//  A Contract Valued Item unit valuation measure.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of the Contract Valued Item delivered. The concept of a
// Factor allows for a discount or surcharge multiplier to be applied to a
// monetary amount.
double factor;

//  An amount that expresses the weighting (based on difficulty, cost
// and/or resource intensiveness) associated with the Contract Valued Item
// delivered. The concept of Points allows for assignment of point values
// for a Contract Valued Item, such that a monetary amount can be assigned
// to each point.
double points;

//  Expresses the product of the Contract Valued Item unitQuantity and the
// unitPriceAmt. For example, the formula: unit Quantity * unit Price
// (Cost per Point) * factor Number  * points = net Amount. Quantity,
// factor and points are assumed to be 1 if not supplied.
Money net;

//  Terms of valuation.
String payment;

//  When payment is due.
DateTime paymentDate;

//  Who will make payment.
Reference responsible;

//  Who will receive payment.
Reference recipient;

//  Id  of the clause or question text related to the context of this
// valuedItem in the referenced form or QuestionnaireResponse.
List<String> linkId;

//  A set of security labels that define which terms are controlled by
// this condition.
List<int> securityLabelNumber;

Contract_ValuedItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.entityCodeableConcept,
    this.entityReference,
    this.identifier,
    this.effectiveTime,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.points,
    this.net,
    this.payment,
    this.paymentDate,
    this.responsible,
    this.recipient,
    this.linkId,
    this.securityLabelNumber,
    });

  factory Contract_ValuedItem.fromJson(Map<String, dynamic> json) => _$Contract_ValuedItemFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_ValuedItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Action {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  True if the term prohibits the  action.
bool doNotPerform;

//  Activity or service obligation to be done or not done, performed or
// not performed, effectuated or not by this Contract term.
CodeableConcept type;

//  Entity of the action.
List<Contract_Subject> subject;

//  Reason or purpose for the action stipulated by this Contract
// Provision.
CodeableConcept intent;

//  Id [identifier??] of the clause or question text related to this
// action in the referenced form or QuestionnaireResponse.
List<String> linkId;

//  Current state of the term action.
CodeableConcept status;

//  Encounter or Episode with primary association to specified term
// activity.
Reference context;

//  Id [identifier??] of the clause or question text related to the
// requester of this action in the referenced form or
// QuestionnaireResponse.
List<String> contextLinkId;

//  When action happens.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  When action happens.
Period occurrencePeriod;

//  When action happens.
Timing occurrenceTiming;

//  Who or what initiated the action and has responsibility for its
// activation.
List<Reference> requester;

//  Id [identifier??] of the clause or question text related to the
// requester of this action in the referenced form or
// QuestionnaireResponse.
List<String> requesterLinkId;

//  The type of individual that is desired or required to perform or not
// perform the action.
List<CodeableConcept> performerType;

//  The type of role or competency of an individual desired or required to
// perform or not perform the action.
CodeableConcept performerRole;

//  Indicates who or what is being asked to perform (or not perform) the
// ction.
Reference performer;

//  Id [identifier??] of the clause or question text related to the reason
// type or reference of this  action in the referenced form or
// QuestionnaireResponse.
List<String> performerLinkId;

//  Rationale for the action to be performed or not performed. Describes
// why the action is permitted or prohibited.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies permitting or not
// permitting this action.
List<Reference> reasonReference;

//  Describes why the action is to be performed or not performed in
// textual form.
List<String> reason;

//  Id [identifier??] of the clause or question text related to the reason
// type or reference of this  action in the referenced form or
// QuestionnaireResponse.
List<String> reasonLinkId;

//  Comments made about the term action made by the requester, performer,
// subject or other participants.
List<Annotation> note;

//  Security labels that protects the action.
List<int> securityLabelNumber;

Contract_Action(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.doNotPerform,
    this.type,
    this.subject,
    this.intent,
    this.linkId,
    this.status,
    this.context,
    this.contextLinkId,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.requester,
    this.requesterLinkId,
    this.performerType,
    this.performerRole,
    this.performer,
    this.performerLinkId,
    this.reasonCode,
    this.reasonReference,
    this.reason,
    this.reasonLinkId,
    this.note,
    this.securityLabelNumber,
    });

  factory Contract_Action.fromJson(Map<String, dynamic> json) => _$Contract_ActionFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_ActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Subject {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The entity the action is performed or not performed on or for.
List<Reference> reference;

//  Role type of agent assigned roles in this Contract.
CodeableConcept role;

Contract_Subject(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.reference,
    this.role,
    });

  factory Contract_Subject.fromJson(Map<String, dynamic> json) => _$Contract_SubjectFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_SubjectToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Signer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Role of this Contract signer, e.g. notary, grantee.
Coding type;

//  Party which is a signator to this Contract.
Reference party;

//  Legally binding Contract DSIG signature contents in Base64.
List<Signature> signature;

Contract_Signer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.party,
    this.signature,
    });

  factory Contract_Signer.fromJson(Map<String, dynamic> json) => _$Contract_SignerFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_SignerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Friendly {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human readable rendering of this Contract in a format and
// representation intended to enhance comprehension and ensure
// understandability.
Attachment contentAttachment;

//  Human readable rendering of this Contract in a format and
// representation intended to enhance comprehension and ensure
// understandability.
Reference contentReference;

Contract_Friendly(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.contentAttachment,
    this.contentReference,
    });

  factory Contract_Friendly.fromJson(Map<String, dynamic> json) => _$Contract_FriendlyFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_FriendlyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Legal {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Contract legal text in human renderable form.
Attachment contentAttachment;

//  Contract legal text in human renderable form.
Reference contentReference;

Contract_Legal(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.contentAttachment,
    this.contentReference,
    });

  factory Contract_Legal.fromJson(Map<String, dynamic> json) => _$Contract_LegalFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_LegalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Contract_Rule {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Computable Contract conveyed using a policy rule language (e.g. XACML,
// DKAL, SecPal).
Attachment contentAttachment;

//  Computable Contract conveyed using a policy rule language (e.g. XACML,
// DKAL, SecPal).
Reference contentReference;

Contract_Rule(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.contentAttachment,
    this.contentReference,
    });

  factory Contract_Rule.fromJson(Map<String, dynamic> json) => _$Contract_RuleFromJson(json);
  Map<String, dynamic> toJson() => _$Contract_RuleToJson(this);
}

part 'coverage.g.dart';

@JsonSerializable(explicitToJson: true)
class Coverage {

//  This is a Coverage resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this coverage.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  The type of coverage: social program, medical plan, accident coverage
// (workers compensation, auto), group health or payment by an individual
// or organization.
CodeableConcept type;

//  The party who 'owns' the insurance policy.
Reference policyHolder;

//  The party who has signed-up for or 'owns' the contractual relationship
// to the policy or to whom the benefit of the policy for services
// rendered to them or their family is due.
Reference subscriber;

//  The insurer assigned ID for the Subscriber.
String subscriberId;

//  The party who benefits from the insurance coverage; the patient when
// products and/or services are provided.
Reference beneficiary;

//  A unique identifier for a dependent under the coverage.
String dependent;

//  The relationship of beneficiary (patient) to the subscriber.
CodeableConcept relationship;

//  Time period during which the coverage is in force. A missing start
// date indicates the start date isn't known, a missing end date means the
// coverage is continuing to be in force.
Period period;

//  The program or plan underwriter or payor including both insurance and
// non-insurance agreements, such as patient-pay agreements.
List<Reference> payor;

//  A suite of underwriter specific classifiers.
List<Coverage_Class> class;

//  The order of applicability of this coverage relative to other
// coverages which are currently in force. Note, there may be gaps in the
// numbering and this does not imply primary, secondary etc. as the
// specific positioning of coverages depends upon the episode of care.
int order;

//  The insurer-specific identifier for the insurer-defined network of
// providers to which the beneficiary may seek treatment which will be
// covered at the 'in-network' rate, otherwise 'out of network' terms and
// conditions apply.
String network;

//  A suite of codes indicating the cost category and associated amount
// which have been detailed in the policy and may have been  included on
// the health card.
List<Coverage_CostToBeneficiary> costToBeneficiary;

//  When 'subrogation=true' this insurance instance has been included not
// for adjudication but to provide insurers with the details to recover
// costs.
bool subrogation;

//  The policy(s) which constitute this insurance coverage.
List<Reference> contract;

Coverage(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.policyHolder,
    this.subscriber,
    this.subscriberId,
    this.beneficiary,
    this.dependent,
    this.relationship,
    this.period,
    this.payor,
    this.class,
    this.order,
    this.network,
    this.costToBeneficiary,
    this.subrogation,
    this.contract,
    });

  factory Coverage.fromJson(Map<String, dynamic> json) => _$CoverageFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Coverage_Class {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of classification for which an insurer-specific class label
// or number and optional name is provided, for example may be used to
// identify a class of coverage or employer group, Policy, Plan.
CodeableConcept type;

//  The alphanumeric string value associated with the insurer issued
// label.
String value;

//  A short description for the class.
String name;

Coverage_Class(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.value,
    this.name,
    });

  factory Coverage_Class.fromJson(Map<String, dynamic> json) => _$Coverage_ClassFromJson(json);
  Map<String, dynamic> toJson() => _$Coverage_ClassToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Coverage_CostToBeneficiary {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The category of patient centric costs associated with treatment.
CodeableConcept type;

//  The amount due from the patient for the cost category.
Quantity valueQuantity;

//  The amount due from the patient for the cost category.
Money valueMoney;

//  A suite of codes indicating exceptions or reductions to patient costs
// and their effective periods.
List<Coverage_Exception> exception;

Coverage_CostToBeneficiary(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueQuantity,
    this.valueMoney,
    this.exception,
    });

  factory Coverage_CostToBeneficiary.fromJson(Map<String, dynamic> json) => _$Coverage_CostToBeneficiaryFromJson(json);
  Map<String, dynamic> toJson() => _$Coverage_CostToBeneficiaryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Coverage_Exception {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The code for the specific exception.
CodeableConcept type;

//  The timeframe during when the exception is in force.
Period period;

Coverage_Exception(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.period,
    });

  factory Coverage_Exception.fromJson(Map<String, dynamic> json) => _$Coverage_ExceptionFromJson(json);
  Map<String, dynamic> toJson() => _$Coverage_ExceptionToJson(this);
}

part 'coverageEligibilityRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityRequest {

//  This is a CoverageEligibilityRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this coverage eligiblity request.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  When the requestor expects the processor to complete processing.
CodeableConcept priority;

//  Code to specify whether requesting: prior authorization requirements
// for some service categories or billing codes; benefits for coverages
// specified or discovered; discovery and return of coverages for the
// patient; and/or validation that the specified coverage is in-force at
// the date/period specified or 'now' if not specified.
List<String> purpose; // <code> enum: auth-requirements/benefits/discovery/validation> purpose;

//  The party who is the beneficiary of the supplied coverage and for whom
// eligibility is sought.
Reference patient;

//  The date or dates when the enclosed suite of services were performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the enclosed suite of services were performed
// or completed.
Period servicedPeriod;

//  The date when this resource was created.
DateTime created;

//  Person who created the request.
Reference enterer;

//  The provider which is responsible for the request.
Reference provider;

//  The Insurer who issued the coverage in question and is the recipient
// of the request.
Reference insurer;

//  Facility where the services are intended to be provided.
Reference facility;

//  Additional information codes regarding exceptions, special
// considerations, the condition, situation, prior or concurrent issues.
List<CoverageEligibilityRequest_SupportingInfo> supportingInfo;

//  Financial instruments for reimbursement for the health care products
// and services.
List<CoverageEligibilityRequest_Insurance> insurance;

//  Service categories or billable services for which benefit details
// and/or an authorization prior to service delivery may be required by
// the payor.
List<CoverageEligibilityRequest_Item> item;

CoverageEligibilityRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.priority,
    this.purpose,
    this.patient,
    this.servicedDate,
    this.servicedPeriod,
    this.created,
    this.enterer,
    this.provider,
    this.insurer,
    this.facility,
    this.supportingInfo,
    this.insurance,
    this.item,
    });

  factory CoverageEligibilityRequest.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityRequestFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityRequest_SupportingInfo {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify supporting information entries.
int sequence;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Reference information;

//  The supporting materials are applicable for all detail items,
// product/servce categories and specific billing codes.
bool appliesToAll;

CoverageEligibilityRequest_SupportingInfo(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.information,
    this.appliesToAll,
    });

  factory CoverageEligibilityRequest_SupportingInfo.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityRequest_SupportingInfoFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityRequest_SupportingInfoToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityRequest_Insurance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A flag to indicate that this Coverage is to be used for evaluation of
// this request when set to true.
bool focal;

//  Reference to the insurance card level information contained in the
// Coverage resource. The coverage issuing insurer will use these details
// to locate the patient's actual coverage within the insurer's
// information system.
Reference coverage;

//  A business agreement number established between the provider and the
// insurer for special business processing purposes.
String businessArrangement;

CoverageEligibilityRequest_Insurance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.focal,
    this.coverage,
    this.businessArrangement,
    });

  factory CoverageEligibilityRequest_Insurance.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityRequest_InsuranceFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityRequest_InsuranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityRequest_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Exceptions, special conditions and supporting information applicable
// for this service or product line.
List<int> supportingInfoSequence;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  This contains the product, service, drug or other billing code for the
// item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The practitioner who is responsible for the product or service to be
// rendered to the patient.
Reference provider;

//  The number of repetitions of a service or product.
Quantity quantity;

//  The amount charged to the patient by the provider for a single unit.
Money unitPrice;

//  Facility where the services will be provided.
Reference facility;

//  Patient diagnosis for which care is sought.
List<CoverageEligibilityRequest_Diagnosis> diagnosis;

//  The plan/proposal/order describing the proposed service in detail.
List<Reference> detail;

CoverageEligibilityRequest_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.supportingInfoSequence,
    this.category,
    this.productOrService,
    this.modifier,
    this.provider,
    this.quantity,
    this.unitPrice,
    this.facility,
    this.diagnosis,
    this.detail,
    });

  factory CoverageEligibilityRequest_Item.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityRequest_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityRequest_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityRequest_Diagnosis {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
CodeableConcept diagnosisCodeableConcept;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
Reference diagnosisReference;

CoverageEligibilityRequest_Diagnosis(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.diagnosisCodeableConcept,
    this.diagnosisReference,
    });

  factory CoverageEligibilityRequest_Diagnosis.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityRequest_DiagnosisFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityRequest_DiagnosisToJson(this);
}

part 'coverageEligibilityResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityResponse {

//  This is a CoverageEligibilityResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this coverage eligiblity request.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  Code to specify whether requesting: prior authorization requirements
// for some service categories or billing codes; benefits for coverages
// specified or discovered; discovery and return of coverages for the
// patient; and/or validation that the specified coverage is in-force at
// the date/period specified or 'now' if not specified.
List<String> purpose; // <code> enum: auth-requirements/benefits/discovery/validation> purpose;

//  The party who is the beneficiary of the supplied coverage and for whom
// eligibility is sought.
Reference patient;

//  The date or dates when the enclosed suite of services were performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the enclosed suite of services were performed
// or completed.
Period servicedPeriod;

//  The date this resource was created.
DateTime created;

//  The provider which is responsible for the request.
Reference requestor;

//  Reference to the original request resource.
Reference request;

//  The outcome of the request processing.
String outcome; // <code> enum: queued/complete/error/partial;

//  A human readable description of the status of the adjudication.
String disposition;

//  The Insurer who issued the coverage in question and is the author of
// the response.
Reference insurer;

//  Financial instruments for reimbursement for the health care products
// and services.
List<CoverageEligibilityResponse_Insurance> insurance;

//  A reference from the Insurer to which these services pertain to be
// used on further communication and as proof that the request occurred.
String preAuthRef;

//  A code for the form to be used for printing the content.
CodeableConcept form;

//  Errors encountered during the processing of the request.
List<CoverageEligibilityResponse_Error> error;

CoverageEligibilityResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.purpose,
    this.patient,
    this.servicedDate,
    this.servicedPeriod,
    this.created,
    this.requestor,
    this.request,
    this.outcome,
    this.disposition,
    this.insurer,
    this.insurance,
    this.preAuthRef,
    this.form,
    this.error,
    });

  factory CoverageEligibilityResponse.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityResponseFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityResponseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityResponse_Insurance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reference to the insurance card level information contained in the
// Coverage resource. The coverage issuing insurer will use these details
// to locate the patient's actual coverage within the insurer's
// information system.
Reference coverage;

//  Flag indicating if the coverage provided is inforce currently if no
// service date(s) specified or for the whole duration of the service
// dates.
bool inforce;

//  The term of the benefits documented in this response.
Period benefitPeriod;

//  Benefits and optionally current balances, and authorization details by
// category or service.
List<CoverageEligibilityResponse_Item> item;

CoverageEligibilityResponse_Insurance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.coverage,
    this.inforce,
    this.benefitPeriod,
    this.item,
    });

  factory CoverageEligibilityResponse_Insurance.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityResponse_InsuranceFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityResponse_InsuranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityResponse_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  This contains the product, service, drug or other billing code for the
// item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The practitioner who is eligible for the provision of the product or
// service.
Reference provider;

//  True if the indicated class of service is excluded from the plan,
// missing or False indicates the product or service is included in the
// coverage.
bool excluded;

//  A short name or tag for the benefit.
String name;

//  A richer description of the benefit or services covered.
String description;

//  Is a flag to indicate whether the benefits refer to in-network
// providers or out-of-network providers.
CodeableConcept network;

//  Indicates if the benefits apply to an individual or to the family.
CodeableConcept unit;

//  The term or period of the values such as 'maximum lifetime benefit' or
// 'maximum annual visits'.
CodeableConcept term;

//  Benefits used to date.
List<CoverageEligibilityResponse_Benefit> benefit;

//  A boolean flag indicating whether a preauthorization is required prior
// to actual service delivery.
bool authorizationRequired;

//  Codes or comments regarding information or actions associated with the
// preauthorization.
List<CodeableConcept> authorizationSupporting;

//  A web location for obtaining requirements or descriptive information
// regarding the preauthorization.
String authorizationUrl;

CoverageEligibilityResponse_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.productOrService,
    this.modifier,
    this.provider,
    this.excluded,
    this.name,
    this.description,
    this.network,
    this.unit,
    this.term,
    this.benefit,
    this.authorizationRequired,
    this.authorizationSupporting,
    this.authorizationUrl,
    });

  factory CoverageEligibilityResponse_Item.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityResponse_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityResponse_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityResponse_Benefit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Classification of benefit being provided.
CodeableConcept type;

//  The quantity of the benefit which is permitted under the coverage.
int allowedUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The quantity of the benefit which is permitted under the coverage.
String allowedString; //  pattern: ^[ \r\n\t\S]+$

//  The quantity of the benefit which is permitted under the coverage.
Money allowedMoney;

//  The quantity of the benefit which have been consumed to date.
int usedUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The quantity of the benefit which have been consumed to date.
String usedString; //  pattern: ^[ \r\n\t\S]+$

//  The quantity of the benefit which have been consumed to date.
Money usedMoney;

CoverageEligibilityResponse_Benefit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.allowedUnsignedInt,
    this.allowedString,
    this.allowedMoney,
    this.usedUnsignedInt,
    this.usedString,
    this.usedMoney,
    });

  factory CoverageEligibilityResponse_Benefit.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityResponse_BenefitFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityResponse_BenefitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class CoverageEligibilityResponse_Error {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An error code,from a specified code system, which details why the
// eligibility check could not be performed.
CodeableConcept code;

CoverageEligibilityResponse_Error(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    });

  factory CoverageEligibilityResponse_Error.fromJson(Map<String, dynamic> json) => _$CoverageEligibilityResponse_ErrorFromJson(json);
  Map<String, dynamic> toJson() => _$CoverageEligibilityResponse_ErrorToJson(this);
}

part 'detectedIssue.g.dart';

@JsonSerializable(explicitToJson: true)
class DetectedIssue {

//  This is a DetectedIssue resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifier associated with the detected issue record.
List<Identifier> identifier;

//  Indicates the status of the detected issue.
String status;

//  Identifies the general type of issue identified.
CodeableConcept code;

//  Indicates the degree of importance associated with the identified
// issue based on the potential impact on the patient.
String severity; // <code> enum: high/moderate/low;

//  Indicates the patient whose record the detected issue is associated
// with.
Reference patient;

//  The date or period when the detected issue was initially identified.
String identifiedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date or period when the detected issue was initially identified.
Period identifiedPeriod;

//  Individual or device responsible for the issue being raised.  For
// example, a decision support application or a pharmacist conducting a
// medication review.
Reference author;

//  Indicates the resource representing the current activity or proposed
// activity that is potentially problematic.
List<Reference> implicated;

//  Supporting evidence or manifestations that provide the basis for
// identifying the detected issue such as a GuidanceResponse or
// MeasureReport.
List<DetectedIssue_Evidence> evidence;

//  A textual explanation of the detected issue.
String detail;

//  The literature, knowledge-base or similar reference that describes the
// propensity for the detected issue identified.
String reference;

//  Indicates an action that has been taken or is committed to reduce or
// eliminate the likelihood of the risk identified by the detected issue
// from manifesting.  Can also reflect an observation of known mitigating
// factors that may reduce/eliminate the need for any action.
List<DetectedIssue_Mitigation> mitigation;

DetectedIssue(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.code,
    this.severity,
    this.patient,
    this.identifiedDateTime,
    this.identifiedPeriod,
    this.author,
    this.implicated,
    this.evidence,
    this.detail,
    this.reference,
    this.mitigation,
    });

  factory DetectedIssue.fromJson(Map<String, dynamic> json) => _$DetectedIssueFromJson(json);
  Map<String, dynamic> toJson() => _$DetectedIssueToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DetectedIssue_Evidence {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A manifestation that led to the recording of this detected issue.
List<CodeableConcept> code;

//  Links to resources that constitute evidence for the detected issue
// such as a GuidanceResponse or MeasureReport.
List<Reference> detail;

DetectedIssue_Evidence(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.detail,
    });

  factory DetectedIssue_Evidence.fromJson(Map<String, dynamic> json) => _$DetectedIssue_EvidenceFromJson(json);
  Map<String, dynamic> toJson() => _$DetectedIssue_EvidenceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DetectedIssue_Mitigation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the action that was taken or the observation that was made
// that reduces/eliminates the risk associated with the identified issue.
CodeableConcept action;

//  Indicates when the mitigating action was documented.
DateTime date;

//  Identifies the practitioner who determined the mitigation and takes
// responsibility for the mitigation step occurring.
Reference author;

DetectedIssue_Mitigation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    this.date,
    this.author,
    });

  factory DetectedIssue_Mitigation.fromJson(Map<String, dynamic> json) => _$DetectedIssue_MitigationFromJson(json);
  Map<String, dynamic> toJson() => _$DetectedIssue_MitigationToJson(this);
}

part 'device.g.dart';

@JsonSerializable(explicitToJson: true)
class Device {

//  This is a Device resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique instance identifiers assigned to a device by manufacturers
// other organizations or owners.
List<Identifier> identifier;

//  The reference to the definition for the device.
Reference definition;

//  Unique device identifier (UDI) assigned to device label or package. 
// Note that the Device may include multiple udiCarriers as it either may
// include just the udiCarrier for the jurisdiction it is sold, or for
// multiple jurisdictions it could have been sold.
List<Device_UdiCarrier> udiCarrier;

//  Status of the Device availability.
String status; // <code> enum: active/inactive/entered-in-error/unknown;

//  Reason for the dtatus of the Device availability.
List<CodeableConcept> statusReason;

//  The distinct identification string as required by regulation for a
// human cell, tissue, or cellular and tissue-based product.
String distinctIdentifier;

//  A name of the manufacturer.
String manufacturer;

//  The date and time when the device was manufactured.
DateTime manufactureDate;

//  The date and time beyond which this device is no longer valid or
// should not be used (if applicable).
DateTime expirationDate;

//  Lot number assigned by the manufacturer.
String lotNumber;

//  The serial number assigned by the organization when the device was
// manufactured.
String serialNumber;

//  This represents the manufacturer's name of the device as provided by
// the device, from a UDI label, or by a person describing the Device. 
// This typically would be used when a person provides the name(s) or when
// the device represents one of the names available from DeviceDefinition.
List<Device_DeviceName> deviceName;

//  The model number for the device.
String modelNumber;

//  The part number of the device.
String partNumber;

//  The kind or type of device.
CodeableConcept type;

//  The capabilities supported on a  device, the standards to which the
// device conforms for a particular purpose, and used for the
// communication.
List<Device_Specialization> specialization;

//  The actual design of the device or software version running on the
// device.
List<Device_Version> version;

//  The actual configuration settings of a device as it actually operates,
// e.g., regulation status, time properties.
List<Device_Property> property;

//  Patient information, If the device is affixed to a person.
Reference patient;

//  An organization that is responsible for the provision and ongoing
// maintenance of the device.
Reference owner;

//  Contact details for an organization or a particular human that is
// responsible for the device.
List<ContactPoint> contact;

//  The place where the device can be found.
Reference location;

//  A network address on which the device may be contacted directly.
String url;

//  Descriptive information, usage information or implantation information
// that is not captured in an existing element.
List<Annotation> note;

//  Provides additional safety characteristics about a medical device. 
// For example devices containing latex.
List<CodeableConcept> safety;

//  The parent device.
Reference parent;

Device(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.definition,
    this.udiCarrier,
    this.status,
    this.statusReason,
    this.distinctIdentifier,
    this.manufacturer,
    this.manufactureDate,
    this.expirationDate,
    this.lotNumber,
    this.serialNumber,
    this.deviceName,
    this.modelNumber,
    this.partNumber,
    this.type,
    this.specialization,
    this.version,
    this.property,
    this.patient,
    this.owner,
    this.contact,
    this.location,
    this.url,
    this.note,
    this.safety,
    this.parent,
    });

  factory Device.fromJson(Map<String, dynamic> json) => _$DeviceFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Device_UdiCarrier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The device identifier (DI) is a mandatory, fixed portion of a UDI that
// identifies the labeler and the specific version or model of a device.
String deviceIdentifier;

//  Organization that is charged with issuing UDIs for devices.  For
// example, the US FDA issuers include : 1) GS1: 
// http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC:
// http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood
// containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA
// for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
String issuer;

//  The identity of the authoritative source for UDI generation within a 
// jurisdiction.  All UDIs are globally unique within a single namespace
// with the appropriate repository uri as the system.  For example,  UDIs
// of devices managed in the U.S. by the FDA, the value is 
// http://hl7.org/fhir/NamingSystem/fda-udi.
String jurisdiction;

//  The full UDI carrier of the Automatic Identification and Data Capture
// (AIDC) technology representation of the barcode string as printed on
// the packaging of the device - e.g., a barcode or RFID.   Because of
// limitations on character sets in XML and the need to round-trip JSON
// data through XML, AIDC Formats *SHALL* be base64 encoded.
String carrierAIDC;

//  The full UDI carrier as the human readable form (HRF) representation
// of the barcode string as printed on the packaging of the device.
String carrierHRF;

//  A coded entry to indicate how the data was entered.
String entryType; // <code> enum: barcode/rfid/manual/card/self-reported/unknown;

Device_UdiCarrier(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.deviceIdentifier,
    this.issuer,
    this.jurisdiction,
    this.carrierAIDC,
    this.carrierHRF,
    this.entryType,
    });

  factory Device_UdiCarrier.fromJson(Map<String, dynamic> json) => _$Device_UdiCarrierFromJson(json);
  Map<String, dynamic> toJson() => _$Device_UdiCarrierToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Device_DeviceName {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the device.
String name;

//  The type of deviceName. UDILabelName | UserFriendlyName |
// PatientReportedName | ManufactureDeviceName | ModelName.
String type; // <code> enum: udi-label-name/user-friendly-name/patient-reported-name/manufacturer-name/model-name/other;

Device_DeviceName(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    });

  factory Device_DeviceName.fromJson(Map<String, dynamic> json) => _$Device_DeviceNameFromJson(json);
  Map<String, dynamic> toJson() => _$Device_DeviceNameToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Device_Specialization {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The standard that is used to operate and communicate.
CodeableConcept systemType;

//  The version of the standard that is used to operate and communicate.
String version;

Device_Specialization(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.systemType,
    this.version,
    });

  factory Device_Specialization.fromJson(Map<String, dynamic> json) => _$Device_SpecializationFromJson(json);
  Map<String, dynamic> toJson() => _$Device_SpecializationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Device_Version {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of the device version.
CodeableConcept type;

//  A single component of the device version.
Identifier component;

//  The version text.
String value;

Device_Version(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.component,
    this.value,
    });

  factory Device_Version.fromJson(Map<String, dynamic> json) => _$Device_VersionFromJson(json);
  Map<String, dynamic> toJson() => _$Device_VersionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Device_Property {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Code that specifies the property DeviceDefinitionPropetyCode
// (Extensible).
CodeableConcept type;

//  Property value as a quantity.
List<Quantity> valueQuantity;

//  Property value as a code, e.g., NTP4 (synced to NTP).
List<CodeableConcept> valueCode;

Device_Property(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueQuantity,
    this.valueCode,
    });

  factory Device_Property.fromJson(Map<String, dynamic> json) => _$Device_PropertyFromJson(json);
  Map<String, dynamic> toJson() => _$Device_PropertyToJson(this);
}

part 'deviceDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class DeviceDefinition {

//  This is a DeviceDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique instance identifiers assigned to a device by the software,
// manufacturers, other organizations or owners. For example: handle ID.
List<Identifier> identifier;

//  Unique device identifier (UDI) assigned to device label or package. 
// Note that the Device may include multiple udiCarriers as it either may
// include just the udiCarrier for the jurisdiction it is sold, or for
// multiple jurisdictions it could have been sold.
List<DeviceDefinition_UdiDeviceIdentifier> udiDeviceIdentifier;

//  A name of the manufacturer.
String manufacturerString; //  pattern: ^[ \r\n\t\S]+$

//  A name of the manufacturer.
Reference manufacturerReference;

//  A name given to the device to identify it.
List<DeviceDefinition_DeviceName> deviceName;

//  The model number for the device.
String modelNumber;

//  What kind of device or device system this is.
CodeableConcept type;

//  The capabilities supported on a  device, the standards to which the
// device conforms for a particular purpose, and used for the
// communication.
List<DeviceDefinition_Specialization> specialization;

//  The available versions of the device, e.g., software versions.
List<String> version;

//  Safety characteristics of the device.
List<CodeableConcept> safety;

//  Shelf Life and storage information.
List<ProductShelfLife> shelfLifeStorage;

//  Dimensions, color etc.
ProdCharacteristic physicalCharacteristics;

//  Language code for the human-readable text strings produced by the
// device (all supported).
List<CodeableConcept> languageCode;

//  Device capabilities.
List<DeviceDefinition_Capability> capability;

//  The actual configuration settings of a device as it actually operates,
// e.g., regulation status, time properties.
List<DeviceDefinition_Property> property;

//  An organization that is responsible for the provision and ongoing
// maintenance of the device.
Reference owner;

//  Contact details for an organization or a particular human that is
// responsible for the device.
List<ContactPoint> contact;

//  A network address on which the device may be contacted directly.
String url;

//  Access to on-line information about the device.
String onlineInformation;

//  Descriptive information, usage information or implantation information
// that is not captured in an existing element.
List<Annotation> note;

//  The quantity of the device present in the packaging (e.g. the number
// of devices present in a pack, or the number of devices in the same
// package of the medicinal product).
Quantity quantity;

//  The parent device it can be part of.
Reference parentDevice;

//  A substance used to create the material(s) of which the device is
// made.
List<DeviceDefinition_Material> material;

DeviceDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.udiDeviceIdentifier,
    this.manufacturerString,
    this.manufacturerReference,
    this.deviceName,
    this.modelNumber,
    this.type,
    this.specialization,
    this.version,
    this.safety,
    this.shelfLifeStorage,
    this.physicalCharacteristics,
    this.languageCode,
    this.capability,
    this.property,
    this.owner,
    this.contact,
    this.url,
    this.onlineInformation,
    this.note,
    this.quantity,
    this.parentDevice,
    this.material,
    });

  factory DeviceDefinition.fromJson(Map<String, dynamic> json) => _$DeviceDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_UdiDeviceIdentifier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The identifier that is to be associated with every Device that
// references this DeviceDefintiion for the issuer and jurisdication
// porvided in the DeviceDefinition.udiDeviceIdentifier.
String deviceIdentifier;

//  The organization that assigns the identifier algorithm.
String issuer;

//  The jurisdiction to which the deviceIdentifier applies.
String jurisdiction;

DeviceDefinition_UdiDeviceIdentifier(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.deviceIdentifier,
    this.issuer,
    this.jurisdiction,
    });

  factory DeviceDefinition_UdiDeviceIdentifier.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_UdiDeviceIdentifierFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_UdiDeviceIdentifierToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_DeviceName {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the device.
String name;

//  The type of deviceName. UDILabelName | UserFriendlyName |
// PatientReportedName | ManufactureDeviceName | ModelName.
String type; // <code> enum: udi-label-name/user-friendly-name/patient-reported-name/manufacturer-name/model-name/other;

DeviceDefinition_DeviceName(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    });

  factory DeviceDefinition_DeviceName.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_DeviceNameFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_DeviceNameToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_Specialization {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The standard that is used to operate and communicate.
String systemType;

//  The version of the standard that is used to operate and communicate.
String version;

DeviceDefinition_Specialization(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.systemType,
    this.version,
    });

  factory DeviceDefinition_Specialization.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_SpecializationFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_SpecializationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_Capability {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of capability.
CodeableConcept type;

//  Description of capability.
List<CodeableConcept> description;

DeviceDefinition_Capability(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.description,
    });

  factory DeviceDefinition_Capability.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_CapabilityFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_CapabilityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_Property {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Code that specifies the property DeviceDefinitionPropetyCode
// (Extensible).
CodeableConcept type;

//  Property value as a quantity.
List<Quantity> valueQuantity;

//  Property value as a code, e.g., NTP4 (synced to NTP).
List<CodeableConcept> valueCode;

DeviceDefinition_Property(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueQuantity,
    this.valueCode,
    });

  factory DeviceDefinition_Property.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_PropertyFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_PropertyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceDefinition_Material {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The substance.
CodeableConcept substance;

//  Indicates an alternative material of the device.
bool alternate;

//  Whether the substance is a known or suspected allergen.
bool allergenicIndicator;

DeviceDefinition_Material(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.substance,
    this.alternate,
    this.allergenicIndicator,
    });

  factory DeviceDefinition_Material.fromJson(Map<String, dynamic> json) => _$DeviceDefinition_MaterialFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceDefinition_MaterialToJson(this);
}

part 'deviceMetric.g.dart';

@JsonSerializable(explicitToJson: true)
class DeviceMetric {

//  This is a DeviceMetric resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique instance identifiers assigned to a device by the device or
// gateway software, manufacturers, other organizations or owners. For
// example: handle ID.
List<Identifier> identifier;

//  Describes the type of the metric. For example: Heart Rate, PEEP
// Setting, etc.
CodeableConcept type;

//  Describes the unit that an observed value determined for this metric
// will have. For example: Percent, Seconds, etc.
CodeableConcept unit;

//  Describes the link to the  Device that this DeviceMetric belongs to
// and that contains administrative device information such as
// manufacturer, serial number, etc.
Reference source;

//  Describes the link to the  Device that this DeviceMetric belongs to
// and that provide information about the location of this DeviceMetric in
// the containment structure of the parent Device. An example would be a
// Device that represents a Channel. This reference can be used by a
// client application to distinguish DeviceMetrics that have the same
// type, but should be interpreted based on their containment location.
Reference parent;

//  Indicates current operational state of the device. For example: On,
// Off, Standby, etc.
String operationalStatus; // <code> enum: on/off/standby/entered-in-error;

//  Describes the color representation for the metric. This is often used
// to aid clinicians to track and identify parameter types by color. In
// practice, consider a Patient Monitor that has ECG/HR and Pleth for
// example; the parameters are displayed in different characteristic
// colors, such as HR-blue, BP-green, and PR and SpO2- magenta.
String color; // <code> enum: black/red/green/yellow/blue/magenta/cyan/white;

//  Indicates the category of the observation generation process. A
// DeviceMetric can be for example a setting, measurement, or calculation.
String category; // <code> enum: measurement/setting/calculation/unspecified;

//  Describes the measurement repetition time. This is not necessarily the
// same as the update period. The measurement repetition time can range
// from milliseconds up to hours. An example for a measurement repetition
// time in the range of milliseconds is the sampling rate of an ECG. An
// example for a measurement repetition time in the range of hours is a
// NIBP that is triggered automatically every hour. The update period may
// be different than the measurement repetition time, if the device does
// not update the published observed value with the same frequency as it
// was measured.
Timing measurementPeriod;

//  Describes the calibrations that have been performed or that are
// required to be performed.
List<DeviceMetric_Calibration> calibration;

DeviceMetric(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.unit,
    this.source,
    this.parent,
    this.operationalStatus,
    this.color,
    this.category,
    this.measurementPeriod,
    this.calibration,
    });

  factory DeviceMetric.fromJson(Map<String, dynamic> json) => _$DeviceMetricFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceMetricToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceMetric_Calibration {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the type of the calibration method.
String type; // <code> enum: unspecified/offset/gain/two-point;

//  Describes the state of the calibration.
String state; // <code> enum: not-calibrated/calibration-required/calibrated/unspecified;

//  Describes the time last calibration has been performed.
DateTime time;

DeviceMetric_Calibration(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.state,
    this.time,
    });

  factory DeviceMetric_Calibration.fromJson(Map<String, dynamic> json) => _$DeviceMetric_CalibrationFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceMetric_CalibrationToJson(this);
}

part 'deviceRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class DeviceRequest {

//  This is a DeviceRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this order by the orderer or by the receiver.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this
// DeviceRequest.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this DeviceRequest.
List<String> instantiatesUri;

//  Plan/proposal/order fulfilled by this request.
List<Reference> basedOn;

//  The request takes the place of the referenced completed or terminated
// request(s).
List<Reference> priorRequest;

//  Composite request this is part of.
Identifier groupIdentifier;

//  The status of the request.
String status;

//  Whether the request is a proposal, plan, an original order or a reflex
// order.
String intent;

//  Indicates how quickly the {{title}} should be addressed with respect
// to other requests.
String priority;

//  The details of the device to be used.
Reference codeReference;

//  The details of the device to be used.
CodeableConcept codeCodeableConcept;

//  Specific parameters for the ordered item.  For example, the prism
// value for lenses.
List<DeviceRequest_Parameter> parameter;

//  The patient who will use the device.
Reference subject;

//  An encounter that provides additional context in which this request is
// made.
Reference encounter;

//  The timing schedule for the use of the device. The Schedule data type
// allows many different expressions, for example. "Every 8 hours"; "Three
// times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec
// 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The timing schedule for the use of the device. The Schedule data type
// allows many different expressions, for example. "Every 8 hours"; "Three
// times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec
// 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
Period occurrencePeriod;

//  The timing schedule for the use of the device. The Schedule data type
// allows many different expressions, for example. "Every 8 hours"; "Three
// times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec
// 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
Timing occurrenceTiming;

//  When the request transitioned to being actionable.
DateTime authoredOn;

//  The individual who initiated the request and has responsibility for
// its activation.
Reference requester;

//  Desired type of performer for doing the diagnostic testing.
CodeableConcept performerType;

//  The desired performer for doing the diagnostic testing.
Reference performer;

//  Reason or justification for the use of this device.
List<CodeableConcept> reasonCode;

//  Reason or justification for the use of this device.
List<Reference> reasonReference;

//  Insurance plans, coverage extensions, pre-authorizations and/or
// pre-determinations that may be required for delivering the requested
// service.
List<Reference> insurance;

//  Additional clinical information about the patient that may influence
// the request fulfilment.  For example, this may include where on the
// subject's body the device will be used (i.e. the target site).
List<Reference> supportingInfo;

//  Details about this request that were not represented at all or
// sufficiently in one of the attributes provided in a class. These may
// include for example a comment, an instruction, or a note associated
// with the statement.
List<Annotation> note;

//  Key events in the history of the request.
List<Reference> relevantHistory;

DeviceRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.priorRequest,
    this.groupIdentifier,
    this.status,
    this.intent,
    this.priority,
    this.codeReference,
    this.codeCodeableConcept,
    this.parameter,
    this.subject,
    this.encounter,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.authoredOn,
    this.requester,
    this.performerType,
    this.performer,
    this.reasonCode,
    this.reasonReference,
    this.insurance,
    this.supportingInfo,
    this.note,
    this.relevantHistory,
    });

  factory DeviceRequest.fromJson(Map<String, dynamic> json) => _$DeviceRequestFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DeviceRequest_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code or string that identifies the device detail being asserted.
CodeableConcept code;

//  The value of the device detail.
CodeableConcept valueCodeableConcept;

//  The value of the device detail.
Quantity valueQuantity;

//  The value of the device detail.
Range valueRange;

//  The value of the device detail.
bool valueBoolean; //  pattern: ^true|false$

DeviceRequest_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.valueCodeableConcept,
    this.valueQuantity,
    this.valueRange,
    this.valueBoolean,
    });

  factory DeviceRequest_Parameter.fromJson(Map<String, dynamic> json) => _$DeviceRequest_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceRequest_ParameterToJson(this);
}

part 'deviceUseStatement.g.dart';

@JsonSerializable(explicitToJson: true)
class DeviceUseStatement {

//  This is a DeviceUseStatement resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An external identifier for this statement such as an IRI.
List<Identifier> identifier;

//  A plan, proposal or order that is fulfilled in whole or in part by
// this DeviceUseStatement.
List<Reference> basedOn;

//  A code representing the patient or other source's judgment about the
// state of the device used that this statement is about.  Generally this
// will be active or completed.
String status; // <code> enum: active/completed/entered-in-error/intended/stopped/on-hold;

//  The patient who used the device.
Reference subject;

//  Allows linking the DeviceUseStatement to the underlying Request, or to
// other information that supports or is used to derive the
// DeviceUseStatement.
List<Reference> derivedFrom;

//  How often the device was used.
Timing timingTiming;

//  How often the device was used.
Period timingPeriod;

//  How often the device was used.
String timingDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The time at which the statement was made/recorded.
DateTime recordedOn;

//  Who reported the device was being used by the patient.
Reference source;

//  The details of the device used.
Reference device;

//  Reason or justification for the use of the device.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies this
// DeviceUseStatement.
List<Reference> reasonReference;

//  Indicates the anotomic location on the subject's body where the device
// was used ( i.e. the target).
CodeableConcept bodySite;

//  Details about the device statement that were not represented at all or
// sufficiently in one of the attributes provided in a class. These may
// include for example a comment, an instruction, or a note associated
// with the statement.
List<Annotation> note;

DeviceUseStatement(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.status,
    this.subject,
    this.derivedFrom,
    this.timingTiming,
    this.timingPeriod,
    this.timingDateTime,
    this.recordedOn,
    this.source,
    this.device,
    this.reasonCode,
    this.reasonReference,
    this.bodySite,
    this.note,
    });

  factory DeviceUseStatement.fromJson(Map<String, dynamic> json) => _$DeviceUseStatementFromJson(json);
  Map<String, dynamic> toJson() => _$DeviceUseStatementToJson(this);
}

part 'diagnosticReport.g.dart';

@JsonSerializable(explicitToJson: true)
class DiagnosticReport {

//  This is a DiagnosticReport resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this report by the performer or other systems.
List<Identifier> identifier;

//  Details concerning a service requested.
List<Reference> basedOn;

//  The status of the diagnostic report.
String status; // <code> enum: registered/partial/preliminary/final/amended/corrected/appended/cancelled/entered-in-error/unknown;

//  A code that classifies the clinical discipline, department or
// diagnostic service that created the report (e.g. cardiology,
// biochemistry, hematology, MRI). This is used for searching, sorting and
// display purposes.
List<CodeableConcept> category;

//  A code or name that describes this diagnostic report.
CodeableConcept code;

//  The subject of the report. Usually, but not always, this is a patient.
// However, diagnostic services also perform analyses on specimens
// collected from a variety of other sources.
Reference subject;

//  The healthcare event  (e.g. a patient and healthcare provider
// interaction) which this DiagnosticReport is about.
Reference encounter;

//  The time or time-period the observed values are related to. When the
// subject of the report is a patient, this is usually either the time of
// the procedure or of specimen collection(s), but very often the source
// of the date/time is not known, only the date/time itself.
String effectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The time or time-period the observed values are related to. When the
// subject of the report is a patient, this is usually either the time of
// the procedure or of specimen collection(s), but very often the source
// of the date/time is not known, only the date/time itself.
Period effectivePeriod;

//  The date and time that this version of the report was made available
// to providers, typically after the report was reviewed and verified.
DateTime issued;

//  The diagnostic service that is responsible for issuing the report.
List<Reference> performer;

//  The practitioner or organization that is responsible for the report's
// conclusions and interpretations.
List<Reference> resultsInterpreter;

//  Details about the specimens on which this diagnostic report is based.
List<Reference> specimen;

//  [Observations](observation.html)  that are part of this diagnostic
// report.
List<Reference> result;

//  One or more links to full details of any imaging performed during the
// diagnostic investigation. Typically, this is imaging performed by DICOM
// enabled modalities, but this is not required. A fully enabled PACS
// viewer can use this information to provide views of the source images.
List<Reference> imagingStudy;

//  A list of key images associated with this report. The images are
// generally created during the diagnostic process, and may be directly of
// the patient, or of treated specimens (i.e. slides of interest).
List<DiagnosticReport_Media> media;

//  Concise and clinically contextualized summary conclusion
// (interpretation/impression) of the diagnostic report.
String conclusion;

//  One or more codes that represent the summary conclusion
// (interpretation/impression) of the diagnostic report.
List<CodeableConcept> conclusionCode;

//  Rich text representation of the entire result as issued by the
// diagnostic service. Multiple formats are allowed but they SHALL be
// semantically equivalent.
List<Attachment> presentedForm;

DiagnosticReport(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.status,
    this.category,
    this.code,
    this.subject,
    this.encounter,
    this.effectiveDateTime,
    this.effectivePeriod,
    this.issued,
    this.performer,
    this.resultsInterpreter,
    this.specimen,
    this.result,
    this.imagingStudy,
    this.media,
    this.conclusion,
    this.conclusionCode,
    this.presentedForm,
    });

  factory DiagnosticReport.fromJson(Map<String, dynamic> json) => _$DiagnosticReportFromJson(json);
  Map<String, dynamic> toJson() => _$DiagnosticReportToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DiagnosticReport_Media {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A comment about the image. Typically, this is used to provide an
// explanation for why the image is included, or to draw the viewer's
// attention to important features.
String comment;

//  Reference to the image source.
Reference link;

DiagnosticReport_Media(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.comment,
    this.link,
    });

  factory DiagnosticReport_Media.fromJson(Map<String, dynamic> json) => _$DiagnosticReport_MediaFromJson(json);
  Map<String, dynamic> toJson() => _$DiagnosticReport_MediaToJson(this);
}

part 'documentManifest.g.dart';

@JsonSerializable(explicitToJson: true)
class DocumentManifest {

//  This is a DocumentManifest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A single identifier that uniquely identifies this manifest.
// Principally used to refer to the manifest in non-FHIR contexts.
Identifier masterIdentifier;

//  Other identifiers associated with the document manifest, including
// version independent  identifiers.
List<Identifier> identifier;

//  The status of this document manifest.
String status; // <code> enum: current/superseded/entered-in-error;

//  The code specifying the type of clinical activity that resulted in
// placing the associated content into the DocumentManifest.
CodeableConcept type;

//  Who or what the set of documents is about. The documents can be about
// a person, (patient or healthcare practitioner), a device (i.e. machine)
// or even a group of subjects (such as a document about a herd of farm
// animals, or a set of patients that share a common exposure). If the
// documents cross more than one subject, then more than one subject is
// allowed here (unusual use case).
Reference subject;

//  When the document manifest was created for submission to the server
// (not necessarily the same thing as the actual resource last modified
// time, since it may be modified, replicated, etc.).
DateTime created;

//  Identifies who is the author of the manifest. Manifest author is not
// necessarly the author of the references included.
List<Reference> author;

//  A patient, practitioner, or organization for which this set of
// documents is intended.
List<Reference> recipient;

//  Identifies the source system, application, or software that produced
// the document manifest.
String source;

//  Human-readable description of the source document. This is sometimes
// known as the "title".
String description;

//  The list of Resources that consist of the parts of this manifest.
List<Reference> content;

//  Related identifiers or resources associated with the DocumentManifest.
List<DocumentManifest_Related> related;

DocumentManifest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.masterIdentifier,
    this.identifier,
    this.status,
    this.type,
    this.subject,
    this.created,
    this.author,
    this.recipient,
    this.source,
    this.description,
    this.content,
    this.related,
    });

  factory DocumentManifest.fromJson(Map<String, dynamic> json) => _$DocumentManifestFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentManifestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DocumentManifest_Related {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Related identifier to this DocumentManifest.  For example, Order
// numbers, accession numbers, XDW workflow numbers.
Identifier identifier;

//  Related Resource to this DocumentManifest. For example, Order,
// ServiceRequest,  Procedure, EligibilityRequest, etc.
Reference ref;

DocumentManifest_Related(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.ref,
    });

  factory DocumentManifest_Related.fromJson(Map<String, dynamic> json) => _$DocumentManifest_RelatedFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentManifest_RelatedToJson(this);
}

part 'documentReference.g.dart';

@JsonSerializable(explicitToJson: true)
class DocumentReference {

//  This is a DocumentReference resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Document identifier as assigned by the source of the document. This
// identifier is specific to this version of the document. This unique
// identifier may be used elsewhere to identify this version of the
// document.
Identifier masterIdentifier;

//  Other identifiers associated with the document, including version
// independent identifiers.
List<Identifier> identifier;

//  The status of this document reference.
String status; // <code> enum: current/superseded/entered-in-error;

//  The status of the underlying document.
String docStatus;

//  Specifies the particular kind of document referenced  (e.g. History
// and Physical, Discharge Summary, Progress Note). This usually equates
// to the purpose of making the document referenced.
CodeableConcept type;

//  A categorization for the type of document referenced - helps for
// indexing and searching. This may be implied by or derived from the code
// specified in the DocumentReference.type.
List<CodeableConcept> category;

//  Who or what the document is about. The document can be about a person,
// (patient or healthcare practitioner), a device (e.g. a machine) or even
// a group of subjects (such as a document about a herd of farm animals,
// or a set of patients that share a common exposure).
Reference subject;

//  When the document reference was created.
DateTime date;

//  Identifies who is responsible for adding the information to the
// document.
List<Reference> author;

//  Which person or organization authenticates that this document is
// valid.
Reference authenticator;

//  Identifies the organization or group who is responsible for ongoing
// maintenance of and access to the document.
Reference custodian;

//  Relationships that this document has with other document references
// that already exist.
List<DocumentReference_RelatesTo> relatesTo;

//  Human-readable description of the source document.
String description;

//  A set of Security-Tag codes specifying the level of privacy/security
// of the Document. Note that DocumentReference.meta.security contains the
// security labels of the "reference" to the document, while
// DocumentReference.securityLabel contains a snapshot of the security
// labels on the document the reference refers to.
List<CodeableConcept> securityLabel;

//  The document and format referenced. There may be multiple content
// element repetitions, each with a different format.
List<DocumentReference_Content> content;

//  The clinical context in which the document was prepared.
DocumentReference_Context context;

DocumentReference(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.masterIdentifier,
    this.identifier,
    this.status,
    this.docStatus,
    this.type,
    this.category,
    this.subject,
    this.date,
    this.author,
    this.authenticator,
    this.custodian,
    this.relatesTo,
    this.description,
    this.securityLabel,
    this.content,
    this.context,
    });

  factory DocumentReference.fromJson(Map<String, dynamic> json) => _$DocumentReferenceFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentReferenceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DocumentReference_RelatesTo {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of relationship that this document has with anther document.
String code; // <code> enum: replaces/transforms/signs/appends;

//  The target document of this relationship.
Reference target;

DocumentReference_RelatesTo(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.target,
    });

  factory DocumentReference_RelatesTo.fromJson(Map<String, dynamic> json) => _$DocumentReference_RelatesToFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentReference_RelatesToToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DocumentReference_Content {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The document or URL of the document along with critical metadata to
// prove content has integrity.
Attachment attachment;

//  An identifier of the document encoding, structure, and template that
// the document conforms to beyond the base format indicated in the
// mimeType.
Coding format;

DocumentReference_Content(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.attachment,
    this.format,
    });

  factory DocumentReference_Content.fromJson(Map<String, dynamic> json) => _$DocumentReference_ContentFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentReference_ContentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class DocumentReference_Context {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the clinical encounter or type of care that the document
// content is associated with.
List<Reference> encounter;

//  This list of codes represents the main clinical acts, such as a
// colonoscopy or an appendectomy, being documented. In some cases, the
// event is inherent in the type Code, such as a "History and Physical
// Report" in which the procedure being documented is necessarily a
// "History and Physical" act.
List<CodeableConcept> event;

//  The time period over which the service that is described by the
// document was provided.
Period period;

//  The kind of facility where the patient was seen.
CodeableConcept facilityType;

//  This property may convey specifics about the practice setting where
// the content was created, often reflecting the clinical specialty.
CodeableConcept practiceSetting;

//  The Patient Information as known when the document was published. May
// be a reference to a version specific, or contained.
Reference sourcePatientInfo;

//  Related identifiers or resources associated with the
// DocumentReference.
List<Reference> related;

DocumentReference_Context(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.encounter,
    this.event,
    this.period,
    this.facilityType,
    this.practiceSetting,
    this.sourcePatientInfo,
    this.related,
    });

  factory DocumentReference_Context.fromJson(Map<String, dynamic> json) => _$DocumentReference_ContextFromJson(json);
  Map<String, dynamic> toJson() => _$DocumentReference_ContextToJson(this);
}

part 'effectEvidenceSynthesis.g.dart';

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis {

//  This is a EffectEvidenceSynthesis resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this effect evidence
// synthesis when it is referenced in a specification, model, design or an
// instance; also called its canonical identifier. This SHOULD be globally
// unique and SHOULD be a literal address at which at which an
// authoritative instance of this effect evidence synthesis is (or will
// be) published. This URL can be the target of a canonical reference. It
// SHALL remain the same when the effect evidence synthesis is stored on
// different servers.
String url;

//  A formal identifier that is used to identify this effect evidence
// synthesis when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the effect
// evidence synthesis when it is referenced in a specification, model,
// design or instance. This is an arbitrary value managed by the effect
// evidence synthesis author and is not expected to be globally unique.
// For example, it might be a timestamp (e.g. yyyymmdd) if a managed
// version is not available. There is also no expectation that versions
// can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the effect evidence synthesis.
// This name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the effect evidence
// synthesis.
String title;

//  The status of this effect evidence synthesis. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  The date  (and optionally time) when the effect evidence synthesis was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the effect evidence synthesis
// changes.
DateTime date;

//  The name of the organization or individual that published the effect
// evidence synthesis.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the effect evidence
// synthesis from a consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate effect evidence synthesis instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the effect evidence synthesis is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the effect evidence synthesis and/or
// its contents. Copyright statements are generally legal restrictions on
// the use and publishing of the effect evidence synthesis.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the effect evidence synthesis content was or
// is planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the
// EffectEvidenceSynthesis. Topics provide a high-level categorization
// grouping types of EffectEvidenceSynthesiss that can be useful for
// filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  Type of synthesis eg meta-analysis.
CodeableConcept synthesisType;

//  Type of study eg randomized trial.
CodeableConcept studyType;

//  A reference to a EvidenceVariable resource that defines the population
// for the research.
Reference population;

//  A reference to a EvidenceVariable resource that defines the exposure
// for the research.
Reference exposure;

//  A reference to a EvidenceVariable resource that defines the comparison
// exposure for the research.
Reference exposureAlternative;

//  A reference to a EvidenceVariable resomece that defines the outcome
// for the research.
Reference outcome;

//  A description of the size of the sample involved in the synthesis.
EffectEvidenceSynthesis_SampleSize sampleSize;

//  A description of the results for each exposure considered in the
// effect estimate.
List<EffectEvidenceSynthesis_ResultsByExposure> resultsByExposure;

//  The estimated effect of the exposure variant.
List<EffectEvidenceSynthesis_EffectEstimate> effectEstimate;

//  A description of the certainty of the effect estimate.
List<EffectEvidenceSynthesis_Certainty> certainty;

EffectEvidenceSynthesis(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.note,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.synthesisType,
    this.studyType,
    this.population,
    this.exposure,
    this.exposureAlternative,
    this.outcome,
    this.sampleSize,
    this.resultsByExposure,
    this.effectEstimate,
    this.certainty,
    });

  factory EffectEvidenceSynthesis.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesisFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesisToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_SampleSize {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable summary of sample size.
String description;

//  Number of studies included in this evidence synthesis.
int numberOfStudies;

//  Number of participants included in this evidence synthesis.
int numberOfParticipants;

EffectEvidenceSynthesis_SampleSize(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.numberOfStudies,
    this.numberOfParticipants,
    });

  factory EffectEvidenceSynthesis_SampleSize.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_SampleSizeFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_SampleSizeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_ResultsByExposure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable summary of results by exposure state.
String description;

//  Whether these results are for the exposure state or alternative
// exposure state.
String exposureState; // <code> enum: exposure/exposure-alternative;

//  Used to define variant exposure states such as low-risk state.
CodeableConcept variantState;

//  Reference to a RiskEvidenceSynthesis resource.
Reference riskEvidenceSynthesis;

EffectEvidenceSynthesis_ResultsByExposure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.exposureState,
    this.variantState,
    this.riskEvidenceSynthesis,
    });

  factory EffectEvidenceSynthesis_ResultsByExposure.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_ResultsByExposureFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_ResultsByExposureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_EffectEstimate {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable summary of effect estimate.
String description;

//  Examples include relative risk and mean difference.
CodeableConcept type;

//  Used to define variant exposure states such as low-risk state.
CodeableConcept variantState;

//  The point estimate of the effect estimate.
double value;

//  Specifies the UCUM unit for the outcome.
CodeableConcept unitOfMeasure;

//  A description of the precision of the estimate for the effect.
List<EffectEvidenceSynthesis_PrecisionEstimate> precisionEstimate;

EffectEvidenceSynthesis_EffectEstimate(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.type,
    this.variantState,
    this.value,
    this.unitOfMeasure,
    this.precisionEstimate,
    });

  factory EffectEvidenceSynthesis_EffectEstimate.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_EffectEstimateFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_EffectEstimateToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_PrecisionEstimate {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Examples include confidence interval and interquartile range.
CodeableConcept type;

//  Use 95 for a 95% confidence interval.
double level;

//  Lower bound of confidence interval.
double from;

//  Upper bound of confidence interval.
double to;

EffectEvidenceSynthesis_PrecisionEstimate(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.level,
    this.from,
    this.to,
    });

  factory EffectEvidenceSynthesis_PrecisionEstimate.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_PrecisionEstimateFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_PrecisionEstimateToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_Certainty {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A rating of the certainty of the effect estimate.
List<CodeableConcept> rating;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  A description of a component of the overall certainty.
List<EffectEvidenceSynthesis_CertaintySubcomponent> certaintySubcomponent;

EffectEvidenceSynthesis_Certainty(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.rating,
    this.note,
    this.certaintySubcomponent,
    });

  factory EffectEvidenceSynthesis_Certainty.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_CertaintyFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_CertaintyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EffectEvidenceSynthesis_CertaintySubcomponent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of subcomponent of certainty rating.
CodeableConcept type;

//  A rating of a subcomponent of rating certainty.
List<CodeableConcept> rating;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

EffectEvidenceSynthesis_CertaintySubcomponent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.rating,
    this.note,
    });

  factory EffectEvidenceSynthesis_CertaintySubcomponent.fromJson(Map<String, dynamic> json) => _$EffectEvidenceSynthesis_CertaintySubcomponentFromJson(json);
  Map<String, dynamic> toJson() => _$EffectEvidenceSynthesis_CertaintySubcomponentToJson(this);
}

part 'encounter.g.dart';

@JsonSerializable(explicitToJson: true)
class Encounter {

//  This is a Encounter resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier(s) by which this encounter is known.
List<Identifier> identifier;

//  planned | arrived | triaged | in-progress | onleave | finished |
// cancelled +.
String status; // <code> enum: planned/arrived/triaged/in-progress/onleave/finished/cancelled/entered-in-error/unknown;

//  The status history permits the encounter resource to contain the
// status history without needing to read through the historical versions
// of the resource, or even have the server store them.
List<Encounter_StatusHistory> statusHistory;

//  Concepts representing classification of patient encounter such as
// ambulatory (outpatient), inpatient, emergency, home health or others
// due to local variations.
Coding class;

//  The class history permits the tracking of the encounters transitions
// without needing to go  through the resource history.  This would be
// used for a case where an admission starts of as an emergency encounter,
// then transitions into an inpatient scenario. Doing this and not
// restarting a new encounter ensures that any lab/diagnostic results can
// more easily follow the patient and not require re-processing and not
// get lost or cancelled during a kind of discharge from emergency to
// inpatient.
List<Encounter_ClassHistory> classHistory;

//  Specific type of encounter (e.g. e-mail consultation, surgical
// day-care, skilled nursing, rehabilitation).
List<CodeableConcept> type;

//  Broad categorization of the service that is to be provided (e.g.
// cardiology).
CodeableConcept serviceType;

//  Indicates the urgency of the encounter.
CodeableConcept priority;

//  The patient or group present at the encounter.
Reference subject;

//  Where a specific encounter should be classified as a part of a
// specific episode(s) of care this field should be used. This association
// can facilitate grouping of related encounters together for a specific
// purpose, such as government reporting, issue tracking, association via
// a common problem.  The association is recorded on the encounter as
// these are typically created after the episode of care and grouped on
// entry rather than editing the episode of care to append another
// encounter to it (the episode of care could span years).
List<Reference> episodeOfCare;

//  The request this encounter satisfies (e.g. incoming referral or
// procedure request).
List<Reference> basedOn;

//  The list of people responsible for providing the service.
List<Encounter_Participant> participant;

//  The appointment that scheduled this encounter.
List<Reference> appointment;

//  The start and end time of the encounter.
Period period;

//  Quantity of time the encounter lasted. This excludes the time during
// leaves of absence.
Duration length;

//  Reason the encounter takes place, expressed as a code. For admissions,
// this can be used for a coded admission diagnosis.
List<CodeableConcept> reasonCode;

//  Reason the encounter takes place, expressed as a code. For admissions,
// this can be used for a coded admission diagnosis.
List<Reference> reasonReference;

//  The list of diagnosis relevant to this encounter.
List<Encounter_Diagnosis> diagnosis;

//  The set of accounts that may be used for billing for this Encounter.
List<Reference> account;

//  Details about the admission to a healthcare service.
Encounter_Hospitalization hospitalization;

//  List of locations where  the patient has been during this encounter.
List<Encounter_Location> location;

//  The organization that is primarily responsible for this Encounter's
// services. This MAY be the same as the organization on the Patient
// record, however it could be different, such as if the actor performing
// the services was from an external organization (which may be billed
// seperately) for an external consultation.  Refer to the example bundle
// showing an abbreviated set of Encounters for a colonoscopy.
Reference serviceProvider;

//  Another Encounter of which this encounter is a part of
// (administratively or in time).
Reference partOf;

Encounter(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.statusHistory,
    this.class,
    this.classHistory,
    this.type,
    this.serviceType,
    this.priority,
    this.subject,
    this.episodeOfCare,
    this.basedOn,
    this.participant,
    this.appointment,
    this.period,
    this.length,
    this.reasonCode,
    this.reasonReference,
    this.diagnosis,
    this.account,
    this.hospitalization,
    this.location,
    this.serviceProvider,
    this.partOf,
    });

  factory Encounter.fromJson(Map<String, dynamic> json) => _$EncounterFromJson(json);
  Map<String, dynamic> toJson() => _$EncounterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_StatusHistory {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  planned | arrived | triaged | in-progress | onleave | finished |
// cancelled +.
String status; // <code> enum: planned/arrived/triaged/in-progress/onleave/finished/cancelled/entered-in-error/unknown;

//  The time that the episode was in the specified status.
Period period;

Encounter_StatusHistory(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.status,
    this.period,
    });

  factory Encounter_StatusHistory.fromJson(Map<String, dynamic> json) => _$Encounter_StatusHistoryFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_StatusHistoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_ClassHistory {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  inpatient | outpatient | ambulatory | emergency +.
Coding class;

//  The time that the episode was in the specified class.
Period period;

Encounter_ClassHistory(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.class,
    this.period,
    });

  factory Encounter_ClassHistory.fromJson(Map<String, dynamic> json) => _$Encounter_ClassHistoryFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_ClassHistoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Role of participant in encounter.
List<CodeableConcept> type;

//  The period of time that the specified participant participated in the
// encounter. These can overlap or be sub-sets of the overall encounter's
// period.
Period period;

//  Persons involved in the encounter other than the patient.
Reference individual;

Encounter_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.period,
    this.individual,
    });

  factory Encounter_Participant.fromJson(Map<String, dynamic> json) => _$Encounter_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_ParticipantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_Diagnosis {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reason the encounter takes place, as specified using information from
// another resource. For admissions, this is the admission diagnosis. The
// indication will typically be a Condition (with other resources
// referenced in the evidence.detail), or a Procedure.
Reference condition;

//  Role that this diagnosis has within the encounter (e.g. admission,
// billing, discharge ).
CodeableConcept use;

//  Ranking of the diagnosis (for each role type).
int rank;

Encounter_Diagnosis(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.condition,
    this.use,
    this.rank,
    });

  factory Encounter_Diagnosis.fromJson(Map<String, dynamic> json) => _$Encounter_DiagnosisFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_DiagnosisToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_Hospitalization {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Pre-admission identifier.
Identifier preAdmissionIdentifier;

//  The location/organization from which the patient came before
// admission.
Reference origin;

//  From where patient was admitted (physician referral, transfer).
CodeableConcept admitSource;

//  Whether this hospitalization is a readmission and why if known.
CodeableConcept reAdmission;

//  Diet preferences reported by the patient.
List<CodeableConcept> dietPreference;

//  Special courtesies (VIP, board member).
List<CodeableConcept> specialCourtesy;

//  Any special requests that have been made for this hospitalization
// encounter, such as the provision of specific equipment or other things.
List<CodeableConcept> specialArrangement;

//  Location/organization to which the patient is discharged.
Reference destination;

//  Category or kind of location after discharge.
CodeableConcept dischargeDisposition;

Encounter_Hospitalization(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.preAdmissionIdentifier,
    this.origin,
    this.admitSource,
    this.reAdmission,
    this.dietPreference,
    this.specialCourtesy,
    this.specialArrangement,
    this.destination,
    this.dischargeDisposition,
    });

  factory Encounter_Hospitalization.fromJson(Map<String, dynamic> json) => _$Encounter_HospitalizationFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_HospitalizationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Encounter_Location {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The location where the encounter takes place.
Reference location;

//  The status of the participants' presence at the specified location
// during the period specified. If the participant is no longer at the
// location, then the period will have an end date/time.
String status; // <code> enum: planned/active/reserved/completed;

//  This will be used to specify the required levels (bed/ward/room/etc.)
// desired to be recorded to simplify either messaging or query.
CodeableConcept physicalType;

//  Time period during which the patient was present at the location.
Period period;

Encounter_Location(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.location,
    this.status,
    this.physicalType,
    this.period,
    });

  factory Encounter_Location.fromJson(Map<String, dynamic> json) => _$Encounter_LocationFromJson(json);
  Map<String, dynamic> toJson() => _$Encounter_LocationToJson(this);
}

part 'endpoint.g.dart';

@JsonSerializable(explicitToJson: true)
class Endpoint {

//  This is a Endpoint resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the organization that is used to identify the endpoint
// across multiple disparate systems.
List<Identifier> identifier;

//  active | suspended | error | off | test.
String status; // <code> enum: active/suspended/error/off/entered-in-error/test;

//  A coded value that represents the technical details of the usage of
// this endpoint, such as what WSDLs should be used in what way. (e.g.
// XDS.b/DICOM/cds-hook).
Coding connectionType;

//  A friendly name that this endpoint can be referred to with.
String name;

//  The organization that manages this endpoint (even if technically
// another organization is hosting this in the cloud, it is the
// organization associated with the data).
Reference managingOrganization;

//  Contact details for a human to contact about the subscription. The
// primary use of this for system administrator troubleshooting.
List<ContactPoint> contact;

//  The interval during which the endpoint is expected to be operational.
Period period;

//  The payload type describes the acceptable content that can be
// communicated on the endpoint.
List<CodeableConcept> payloadType;

//  The mime type to send the payload in - e.g. application/fhir+xml,
// application/fhir+json. If the mime type is not specified, then the
// sender could send any content (including no content depending on the
// connectionType).
List<String> payloadMimeType;

//  The uri that describes the actual end-point to connect to.
String address;

//  Additional headers / information to send as part of the notification.
List<String> header;

Endpoint(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.connectionType,
    this.name,
    this.managingOrganization,
    this.contact,
    this.period,
    this.payloadType,
    this.payloadMimeType,
    this.address,
    this.header,
    });

  factory Endpoint.fromJson(Map<String, dynamic> json) => _$EndpointFromJson(json);
  Map<String, dynamic> toJson() => _$EndpointToJson(this);
}

part 'enrollmentRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class EnrollmentRequest {

//  This is a EnrollmentRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The Response business identifier.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  The date when this resource was created.
DateTime created;

//  The Insurer who is target  of the request.
Reference insurer;

//  The practitioner who is responsible for the services rendered to the
// patient.
Reference provider;

//  Patient Resource.
Reference candidate;

//  Reference to the program or plan identification, underwriter or payor.
Reference coverage;

EnrollmentRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.created,
    this.insurer,
    this.provider,
    this.candidate,
    this.coverage,
    });

  factory EnrollmentRequest.fromJson(Map<String, dynamic> json) => _$EnrollmentRequestFromJson(json);
  Map<String, dynamic> toJson() => _$EnrollmentRequestToJson(this);
}

part 'enrollmentResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class EnrollmentResponse {

//  This is a EnrollmentResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The Response business identifier.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  Original request resource reference.
Reference request;

//  Processing status: error, complete.
String outcome; // <code> enum: queued/complete/error/partial;

//  A description of the status of the adjudication.
String disposition;

//  The date when the enclosed suite of services were performed or
// completed.
DateTime created;

//  The Insurer who produced this adjudicated response.
Reference organization;

//  The practitioner who is responsible for the services rendered to the
// patient.
Reference requestProvider;

EnrollmentResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.request,
    this.outcome,
    this.disposition,
    this.created,
    this.organization,
    this.requestProvider,
    });

  factory EnrollmentResponse.fromJson(Map<String, dynamic> json) => _$EnrollmentResponseFromJson(json);
  Map<String, dynamic> toJson() => _$EnrollmentResponseToJson(this);
}

part 'episodeOfCare.g.dart';

@JsonSerializable(explicitToJson: true)
class EpisodeOfCare {

//  This is a EpisodeOfCare resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The EpisodeOfCare may be known by different identifiers for different
// contexts of use, such as when an external agency is tracking the
// Episode for funding purposes.
List<Identifier> identifier;

//  planned | waitlist | active | onhold | finished | cancelled.
String status; // <code> enum: planned/waitlist/active/onhold/finished/cancelled/entered-in-error;

//  The history of statuses that the EpisodeOfCare has been through
// (without requiring processing the history of the resource).
List<EpisodeOfCare_StatusHistory> statusHistory;

//  A classification of the type of episode of care; e.g. specialist
// referral, disease management, type of funded care.
List<CodeableConcept> type;

//  The list of diagnosis relevant to this episode of care.
List<EpisodeOfCare_Diagnosis> diagnosis;

//  The patient who is the focus of this episode of care.
Reference patient;

//  The organization that has assumed the specific responsibilities for
// the specified duration.
Reference managingOrganization;

//  The interval during which the managing organization assumes the
// defined responsibility.
Period period;

//  Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming
// referrals.
List<Reference> referralRequest;

//  The practitioner that is the care manager/care coordinator for this
// patient.
Reference careManager;

//  The list of practitioners that may be facilitating this episode of
// care for specific purposes.
List<Reference> team;

//  The set of accounts that may be used for billing for this
// EpisodeOfCare.
List<Reference> account;

EpisodeOfCare(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.statusHistory,
    this.type,
    this.diagnosis,
    this.patient,
    this.managingOrganization,
    this.period,
    this.referralRequest,
    this.careManager,
    this.team,
    this.account,
    });

  factory EpisodeOfCare.fromJson(Map<String, dynamic> json) => _$EpisodeOfCareFromJson(json);
  Map<String, dynamic> toJson() => _$EpisodeOfCareToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EpisodeOfCare_StatusHistory {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  planned | waitlist | active | onhold | finished | cancelled.
String status; // <code> enum: planned/waitlist/active/onhold/finished/cancelled/entered-in-error;

//  The period during this EpisodeOfCare that the specific status applied.
Period period;

EpisodeOfCare_StatusHistory(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.status,
    this.period,
    });

  factory EpisodeOfCare_StatusHistory.fromJson(Map<String, dynamic> json) => _$EpisodeOfCare_StatusHistoryFromJson(json);
  Map<String, dynamic> toJson() => _$EpisodeOfCare_StatusHistoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EpisodeOfCare_Diagnosis {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A list of conditions/problems/diagnoses that this episode of care is
// intended to be providing care for.
Reference condition;

//  Role that this diagnosis has within the episode of care (e.g.
// admission, billing, discharge ).
CodeableConcept role;

//  Ranking of the diagnosis (for each role type).
int rank;

EpisodeOfCare_Diagnosis(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.condition,
    this.role,
    this.rank,
    });

  factory EpisodeOfCare_Diagnosis.fromJson(Map<String, dynamic> json) => _$EpisodeOfCare_DiagnosisFromJson(json);
  Map<String, dynamic> toJson() => _$EpisodeOfCare_DiagnosisToJson(this);
}

part 'eventDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class EventDefinition {

//  This is a EventDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this event definition when it
// is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this event definition is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// event definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this event definition
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the event
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the event definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the event definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the event definition.
String title;

//  An explanatory or alternate title for the event definition giving
// additional information about its content.
String subtitle;

//  The status of this event definition. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this event definition is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  A code or group definition that describes the intended subject of the
// event definition.
CodeableConcept subjectCodeableConcept;

//  A code or group definition that describes the intended subject of the
// event definition.
Reference subjectReference;

//  The date  (and optionally time) when the event definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the event definition changes.
DateTime date;

//  The name of the organization or individual that published the event
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the event definition from
// a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate event definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the event definition is intended
// to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this event definition is needed and why it has been
// designed as it has.
String purpose;

//  A detailed description of how the event definition is used from a
// clinical perspective.
String usage;

//  A copyright statement relating to the event definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the event definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the event definition content was or is planned
// to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the module. Topics provide a high-level
// categorization of the module that can be useful for filtering and
// searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related resources such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  The trigger element defines when the event occurs. If more than one
// trigger condition is specified, the event fires whenever any one of the
// trigger conditions is met.
List<TriggerDefinition> trigger;

EventDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.subtitle,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.trigger,
    });

  factory EventDefinition.fromJson(Map<String, dynamic> json) => _$EventDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$EventDefinitionToJson(this);
}

part 'evidence.g.dart';

@JsonSerializable(explicitToJson: true)
class Evidence {

//  This is a Evidence resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this evidence when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this evidence is (or will be) published. This URL can be the target
// of a canonical reference. It SHALL remain the same when the evidence is
// stored on different servers.
String url;

//  A formal identifier that is used to identify this evidence when it is
// represented in other formats, or referenced in a specification, model,
// design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the evidence
// when it is referenced in a specification, model, design or instance.
// This is an arbitrary value managed by the evidence author and is not
// expected to be globally unique. For example, it might be a timestamp
// (e.g. yyyymmdd) if a managed version is not available. There is also no
// expectation that versions can be placed in a lexicographical sequence.
// To provide a version consistent with the Decision Support Service
// specification, use the format Major.Minor.Revision (e.g. 1.0.0). For
// more information on versioning knowledge assets, refer to the Decision
// Support Service specification. Note that a version is required for
// non-experimental active artifacts.
String version;

//  A natural language name identifying the evidence. This name should be
// usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the evidence.
String title;

//  The short title provides an alternate title for use in informal
// descriptive contexts where the full, formal title is not necessary.
String shortTitle;

//  An explanatory or alternate title for the Evidence giving additional
// information about its content.
String subtitle;

//  The status of this evidence. Enables tracking the life-cycle of the
// content.
String status; // <code> enum: draft/active/retired/unknown;

//  The date  (and optionally time) when the evidence was published. The
// date must change when the business version changes and it must change
// if the status code changes. In addition, it should change when the
// substantive content of the evidence changes.
DateTime date;

//  The name of the organization or individual that published the
// evidence.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the evidence from a
// consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate evidence instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the evidence is intended to be
// used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the evidence and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the evidence.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the evidence content was or is planned to be
// in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the Evidence. Topics
// provide a high-level categorization grouping types of Evidences that
// can be useful for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a EvidenceVariable resource that defines the population
// for the research.
Reference exposureBackground;

//  A reference to a EvidenceVariable resource that defines the exposure
// for the research.
List<Reference> exposureVariant;

//  A reference to a EvidenceVariable resomece that defines the outcome
// for the research.
List<Reference> outcome;

Evidence(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.shortTitle,
    this.subtitle,
    this.status,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.note,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.exposureBackground,
    this.exposureVariant,
    this.outcome,
    });

  factory Evidence.fromJson(Map<String, dynamic> json) => _$EvidenceFromJson(json);
  Map<String, dynamic> toJson() => _$EvidenceToJson(this);
}

part 'evidenceVariable.g.dart';

@JsonSerializable(explicitToJson: true)
class EvidenceVariable {

//  This is a EvidenceVariable resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this evidence variable when
// it is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this evidence variable is (or will be) published. This URL can be
// the target of a canonical reference. It SHALL remain the same when the
// evidence variable is stored on different servers.
String url;

//  A formal identifier that is used to identify this evidence variable
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the evidence
// variable when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the evidence variable
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence. To provide a version consistent with the
// Decision Support Service specification, use the format
// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
// knowledge assets, refer to the Decision Support Service specification.
// Note that a version is required for non-experimental active artifacts.
String version;

//  A natural language name identifying the evidence variable. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the evidence variable.
String title;

//  The short title provides an alternate title for use in informal
// descriptive contexts where the full, formal title is not necessary.
String shortTitle;

//  An explanatory or alternate title for the EvidenceVariable giving
// additional information about its content.
String subtitle;

//  The status of this evidence variable. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  The date  (and optionally time) when the evidence variable was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the evidence variable changes.
DateTime date;

//  The name of the organization or individual that published the evidence
// variable.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the evidence variable from
// a consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate evidence variable instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the evidence variable is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the evidence variable and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the evidence variable.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the evidence variable content was or is
// planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the EvidenceVariable.
// Topics provide a high-level categorization grouping types of
// EvidenceVariables that can be useful for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  The type of evidence element, a population, an exposure, or an
// outcome.
String type; // <code> enum: dichotomous/continuous/descriptive;

//  A characteristic that defines the members of the evidence element.
// Multiple characteristics are applied with "and" semantics.
List<EvidenceVariable_Characteristic> characteristic;

EvidenceVariable(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.shortTitle,
    this.subtitle,
    this.status,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.note,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.type,
    this.characteristic,
    });

  factory EvidenceVariable.fromJson(Map<String, dynamic> json) => _$EvidenceVariableFromJson(json);
  Map<String, dynamic> toJson() => _$EvidenceVariableToJson(this);
}

@JsonSerializable(explicitToJson: true)
class EvidenceVariable_Characteristic {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A short, natural language description of the characteristic that could
// be used to communicate the criteria to an end-user.
String description;

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
Reference definitionReference;

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
String definitionCanonical; //  pattern: ^\S*$

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
CodeableConcept definitionCodeableConcept;

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
Expression definitionExpression;

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
DataRequirement definitionDataRequirement;

//  Define members of the evidence element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
TriggerDefinition definitionTriggerDefinition;

//  Use UsageContext to define the members of the population, such as Age
// Ranges, Genders, Settings.
List<UsageContext> usageContext;

//  When true, members with this characteristic are excluded from the
// element.
bool exclude;

//  Indicates what effective period the study covers.
String participantEffectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Indicates what effective period the study covers.
Period participantEffectivePeriod;

//  Indicates what effective period the study covers.
Duration participantEffectiveDuration;

//  Indicates what effective period the study covers.
Timing participantEffectiveTiming;

//  Indicates duration from the participant's study entry.
Duration timeFromStart;

//  Indicates how elements are aggregated within the study effective
// period.
String groupMeasure; // <code> enum: mean/median/mean-of-mean/mean-of-median/median-of-mean/median-of-median;

EvidenceVariable_Characteristic(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.definitionReference,
    this.definitionCanonical,
    this.definitionCodeableConcept,
    this.definitionExpression,
    this.definitionDataRequirement,
    this.definitionTriggerDefinition,
    this.usageContext,
    this.exclude,
    this.participantEffectiveDateTime,
    this.participantEffectivePeriod,
    this.participantEffectiveDuration,
    this.participantEffectiveTiming,
    this.timeFromStart,
    this.groupMeasure,
    });

  factory EvidenceVariable_Characteristic.fromJson(Map<String, dynamic> json) => _$EvidenceVariable_CharacteristicFromJson(json);
  Map<String, dynamic> toJson() => _$EvidenceVariable_CharacteristicToJson(this);
}

part 'exampleScenario.g.dart';

@JsonSerializable(explicitToJson: true)
class ExampleScenario {

//  This is a ExampleScenario resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this example scenario when it
// is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this example scenario is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// example scenario is stored on different servers.
String url;

//  A formal identifier that is used to identify this example scenario
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the example
// scenario when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the example scenario
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the example scenario. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  The status of this example scenario. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this example scenario is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the example scenario was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the example scenario changes.
// (e.g. the 'content logical definition').
DateTime date;

//  The name of the organization or individual that published the example
// scenario.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate example scenario instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the example scenario is intended
// to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the example scenario and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the example scenario.
String copyright;

//  What the example scenario resource is created for. This should not be
// used to show the business purpose of the scenario itself, but the
// purpose of documenting a scenario.
String purpose;

//  Actor participating in the resource.
List<ExampleScenario_Actor> actor;

//  Each resource and each version that is present in the workflow.
List<ExampleScenario_Instance> instance;

//  Each major process - a group of operations.
List<ExampleScenario_Process> process;

//  Another nested workflow.
List<String> workflow;

ExampleScenario(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.purpose,
    this.actor,
    this.instance,
    this.process,
    this.workflow,
    });

  factory ExampleScenario.fromJson(Map<String, dynamic> json) => _$ExampleScenarioFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenarioToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Actor {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  ID or acronym of actor.
String actorId;

//  The type of actor - person or system.
String type; // <code> enum: person/entity;

//  The name of the actor as shown in the page.
String name;

//  The description of the actor.
String description;

ExampleScenario_Actor(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.actorId,
    this.type,
    this.name,
    this.description,
    });

  factory ExampleScenario_Actor.fromJson(Map<String, dynamic> json) => _$ExampleScenario_ActorFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_ActorToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Instance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The id of the resource for referencing.
String resourceId;

//  The type of the resource.
String resourceType;

//  A short name for the resource instance.
String name;

//  Human-friendly description of the resource instance.
String description;

//  A specific version of the resource.
List<ExampleScenario_Version> version;

//  Resources contained in the instance (e.g. the observations contained
// in a bundle).
List<ExampleScenario_ContainedInstance> containedInstance;

ExampleScenario_Instance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.resourceId,
    this.resourceType,
    this.name,
    this.description,
    this.version,
    this.containedInstance,
    });

  factory ExampleScenario_Instance.fromJson(Map<String, dynamic> json) => _$ExampleScenario_InstanceFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_InstanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Version {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The identifier of a specific version of a resource.
String versionId;

//  The description of the resource version.
String description;

ExampleScenario_Version(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.versionId,
    this.description,
    });

  factory ExampleScenario_Version.fromJson(Map<String, dynamic> json) => _$ExampleScenario_VersionFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_VersionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_ContainedInstance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Each resource contained in the instance.
String resourceId;

//  A specific version of a resource contained in the instance.
String versionId;

ExampleScenario_ContainedInstance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.resourceId,
    this.versionId,
    });

  factory ExampleScenario_ContainedInstance.fromJson(Map<String, dynamic> json) => _$ExampleScenario_ContainedInstanceFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_ContainedInstanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Process {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The diagram title of the group of operations.
String title;

//  A longer description of the group of operations.
String description;

//  Description of initial status before the process starts.
String preConditions;

//  Description of final status after the process ends.
String postConditions;

//  Each step of the process.
List<ExampleScenario_Step> step;

ExampleScenario_Process(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.title,
    this.description,
    this.preConditions,
    this.postConditions,
    this.step,
    });

  factory ExampleScenario_Process.fromJson(Map<String, dynamic> json) => _$ExampleScenario_ProcessFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_ProcessToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Step {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Nested process.
List<ExampleScenario_Process> process;

//  If there is a pause in the flow.
bool pause;

//  Each interaction or action.
ExampleScenario_Operation operation;

//  Indicates an alternative step that can be taken instead of the
// operations on the base step in exceptional/atypical circumstances.
List<ExampleScenario_Alternative> alternative;

ExampleScenario_Step(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.process,
    this.pause,
    this.operation,
    this.alternative,
    });

  factory ExampleScenario_Step.fromJson(Map<String, dynamic> json) => _$ExampleScenario_StepFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_StepToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Operation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The sequential number of the interaction, e.g. 1.2.5.
String number;

//  The type of operation - CRUD.
String type;

//  The human-friendly name of the interaction.
String name;

//  Who starts the transaction.
String initiator;

//  Who receives the transaction.
String receiver;

//  A comment to be inserted in the diagram.
String description;

//  Whether the initiator is deactivated right after the transaction.
bool initiatorActive;

//  Whether the receiver is deactivated right after the transaction.
bool receiverActive;

//  Each resource instance used by the initiator.
ExampleScenario_ContainedInstance request;

//  Each resource instance used by the responder.
ExampleScenario_ContainedInstance response;

ExampleScenario_Operation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.number,
    this.type,
    this.name,
    this.initiator,
    this.receiver,
    this.description,
    this.initiatorActive,
    this.receiverActive,
    this.request,
    this.response,
    });

  factory ExampleScenario_Operation.fromJson(Map<String, dynamic> json) => _$ExampleScenario_OperationFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_OperationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExampleScenario_Alternative {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The label to display for the alternative that gives a sense of the
// circumstance in which the alternative should be invoked.
String title;

//  A human-readable description of the alternative explaining when the
// alternative should occur rather than the base step.
String description;

//  What happens in each alternative option.
List<ExampleScenario_Step> step;

ExampleScenario_Alternative(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.title,
    this.description,
    this.step,
    });

  factory ExampleScenario_Alternative.fromJson(Map<String, dynamic> json) => _$ExampleScenario_AlternativeFromJson(json);
  Map<String, dynamic> toJson() => _$ExampleScenario_AlternativeToJson(this);
}

part 'explanationOfBenefit.g.dart';

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit {

//  This is a ExplanationOfBenefit resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this explanation of benefit.
List<Identifier> identifier;

//  The status of the resource instance.
String status; // <code> enum: active/cancelled/draft/entered-in-error;

//  The category of claim, e.g. oral, pharmacy, vision, institutional,
// professional.
CodeableConcept type;

//  A finer grained suite of claim type codes which may convey additional
// information such as Inpatient vs Outpatient and/or a specialty service.
CodeableConcept subType;

//  A code to indicate whether the nature of the request is: to request
// adjudication of products and services previously rendered; or
// requesting authorization and adjudication for provision in the future;
// or requesting the non-binding adjudication of the listed products and
// services which could be provided in the future.
String use;

//  The party to whom the professional services and/or products have been
// supplied or are being considered and for whom actual for forecast
// reimbursement is sought.
Reference patient;

//  The period for which charges are being submitted.
Period billablePeriod;

//  The date this resource was created.
DateTime created;

//  Individual who created the claim, predetermination or
// preauthorization.
Reference enterer;

//  The party responsible for authorization, adjudication and
// reimbursement.
Reference insurer;

//  The provider which is responsible for the claim, predetermination or
// preauthorization.
Reference provider;

//  The provider-required urgency of processing the request. Typical
// values include: stat, routine deferred.
CodeableConcept priority;

//  A code to indicate whether and for whom funds are to be reserved for
// future claims.
CodeableConcept fundsReserveRequested;

//  A code, used only on a response to a preauthorization, to indicate
// whether the benefits payable have been reserved and for whom.
CodeableConcept fundsReserve;

//  Other claims which are related to this claim such as prior submissions
// or claims for related services or for the same event.
List<ExplanationOfBenefit_Related> related;

//  Prescription to support the dispensing of pharmacy, device or vision
// products.
Reference prescription;

//  Original prescription which has been superseded by this prescription
// to support the dispensing of pharmacy services, medications or
// products.
Reference originalPrescription;

//  The party to be reimbursed for cost of the products and services
// according to the terms of the policy.
ExplanationOfBenefit_Payee payee;

//  A reference to a referral resource.
Reference referral;

//  Facility where the services were provided.
Reference facility;

//  The business identifier for the instance of the adjudication request:
// claim predetermination or preauthorization.
Reference claim;

//  The business identifier for the instance of the adjudication response:
// claim, predetermination or preauthorization response.
Reference claimResponse;

//  The outcome of the claim, predetermination, or preauthorization
// processing.
String outcome;

//  A human readable description of the status of the adjudication.
String disposition;

//  Reference from the Insurer which is used in later communications which
// refers to this adjudication.
List<String> preAuthRef;

//  The timeframe during which the supplied preauthorization reference may
// be quoted on claims to obtain the adjudication as provided.
List<Period> preAuthRefPeriod;

//  The members of the team who provided the products and services.
List<ExplanationOfBenefit_CareTeam> careTeam;

//  Additional information codes regarding exceptions, special
// considerations, the condition, situation, prior or concurrent issues.
List<ExplanationOfBenefit_SupportingInfo> supportingInfo;

//  Information about diagnoses relevant to the claim items.
List<ExplanationOfBenefit_Diagnosis> diagnosis;

//  Procedures performed on the patient relevant to the billing items with
// the claim.
List<ExplanationOfBenefit_Procedure> procedure;

//  This indicates the relative order of a series of EOBs related to
// different coverages for the same suite of services.
int precedence;

//  Financial instruments for reimbursement for the health care products
// and services specified on the claim.
List<ExplanationOfBenefit_Insurance> insurance;

//  Details of a accident which resulted in injuries which required the
// products and services listed in the claim.
ExplanationOfBenefit_Accident accident;

//  A claim line. Either a simple (a product or service) or a 'group' of
// details which can also be a simple items or groups of sub-details.
List<ExplanationOfBenefit_Item> item;

//  The first-tier service adjudications for payor added product or
// service lines.
List<ExplanationOfBenefit_AddItem> addItem;

//  The adjudication results which are presented at the header level
// rather than at the line-item or add-item levels.
List<ExplanationOfBenefit_Adjudication> adjudication;

//  Categorized monetary totals for the adjudication.
List<ExplanationOfBenefit_Total> total;

//  Payment details for the adjudication of the claim.
ExplanationOfBenefit_Payment payment;

//  A code for the form to be used for printing the content.
CodeableConcept formCode;

//  The actual form, by reference or inclusion, for printing the content
// or an EOB.
Attachment form;

//  A note that describes or explains adjudication results in a human
// readable form.
List<ExplanationOfBenefit_ProcessNote> processNote;

//  The term of the benefits documented in this response.
Period benefitPeriod;

//  Balance by Benefit Category.
List<ExplanationOfBenefit_BenefitBalance> benefitBalance;

ExplanationOfBenefit(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.subType,
    this.use,
    this.patient,
    this.billablePeriod,
    this.created,
    this.enterer,
    this.insurer,
    this.provider,
    this.priority,
    this.fundsReserveRequested,
    this.fundsReserve,
    this.related,
    this.prescription,
    this.originalPrescription,
    this.payee,
    this.referral,
    this.facility,
    this.claim,
    this.claimResponse,
    this.outcome,
    this.disposition,
    this.preAuthRef,
    this.preAuthRefPeriod,
    this.careTeam,
    this.supportingInfo,
    this.diagnosis,
    this.procedure,
    this.precedence,
    this.insurance,
    this.accident,
    this.item,
    this.addItem,
    this.adjudication,
    this.total,
    this.payment,
    this.formCode,
    this.form,
    this.processNote,
    this.benefitPeriod,
    this.benefitBalance,
    });

  factory ExplanationOfBenefit.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefitFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Related {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reference to a related claim.
Reference claim;

//  A code to convey how the claims are related.
CodeableConcept relationship;

//  An alternate organizational reference to the case or file to which
// this particular claim pertains.
Identifier reference;

ExplanationOfBenefit_Related(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.claim,
    this.relationship,
    this.reference,
    });

  factory ExplanationOfBenefit_Related.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_RelatedFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_RelatedToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Payee {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of Party to be reimbursed: Subscriber, provider, other.
CodeableConcept type;

//  Reference to the individual or organization to whom any payment will
// be made.
Reference party;

ExplanationOfBenefit_Payee(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.party,
    });

  factory ExplanationOfBenefit_Payee.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_PayeeFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_PayeeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_CareTeam {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify care team entries.
int sequence;

//  Member of the team who provided the product or service.
Reference provider;

//  The party who is billing and/or responsible for the claimed products
// or services.
bool responsible;

//  The lead, assisting or supervising practitioner and their discipline
// if a multidisciplinary team.
CodeableConcept role;

//  The qualification of the practitioner which is applicable for this
// service.
CodeableConcept qualification;

ExplanationOfBenefit_CareTeam(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.provider,
    this.responsible,
    this.role,
    this.qualification,
    });

  factory ExplanationOfBenefit_CareTeam.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_CareTeamFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_CareTeamToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_SupportingInfo {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify supporting information entries.
int sequence;

//  The general class of the information supplied: information; exception;
// accident, employment; onset, etc.
CodeableConcept category;

//  System and code pertaining to the specific information regarding
// special conditions relating to the setting, treatment or patient  for
// which care is sought.
CodeableConcept code;

//  The date when or period to which this information refers.
String timingDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date when or period to which this information refers.
Period timingPeriod;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
bool valueBoolean; //  pattern: ^true|false$

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Quantity valueQuantity;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Attachment valueAttachment;

//  Additional data or information such as resources, documents, images
// etc. including references to the data or the actual inclusion of the
// data.
Reference valueReference;

//  Provides the reason in the situation where a reason code is required
// in addition to the content.
Coding reason;

ExplanationOfBenefit_SupportingInfo(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.category,
    this.code,
    this.timingDate,
    this.timingPeriod,
    this.valueBoolean,
    this.valueString,
    this.valueQuantity,
    this.valueAttachment,
    this.valueReference,
    this.reason,
    });

  factory ExplanationOfBenefit_SupportingInfo.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_SupportingInfoFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_SupportingInfoToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Diagnosis {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify diagnosis entries.
int sequence;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
CodeableConcept diagnosisCodeableConcept;

//  The nature of illness or problem in a coded form or as a reference to
// an external defined Condition.
Reference diagnosisReference;

//  When the condition was observed or the relative ranking.
List<CodeableConcept> type;

//  Indication of whether the diagnosis was present on admission to a
// facility.
CodeableConcept onAdmission;

//  A package billing code or bundle code used to group products and
// services to a particular health condition (such as heart attack) which
// is based on a predetermined grouping code system.
CodeableConcept packageCode;

ExplanationOfBenefit_Diagnosis(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.diagnosisCodeableConcept,
    this.diagnosisReference,
    this.type,
    this.onAdmission,
    this.packageCode,
    });

  factory ExplanationOfBenefit_Diagnosis.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_DiagnosisFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_DiagnosisToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Procedure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify procedure entries.
int sequence;

//  When the condition was observed or the relative ranking.
List<CodeableConcept> type;

//  Date and optionally time the procedure was performed.
DateTime date;

//  The code or reference to a Procedure resource which identifies the
// clinical intervention performed.
CodeableConcept procedureCodeableConcept;

//  The code or reference to a Procedure resource which identifies the
// clinical intervention performed.
Reference procedureReference;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

ExplanationOfBenefit_Procedure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.type,
    this.date,
    this.procedureCodeableConcept,
    this.procedureReference,
    this.udi,
    });

  factory ExplanationOfBenefit_Procedure.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_ProcedureFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_ProcedureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Insurance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A flag to indicate that this Coverage is to be used for adjudication
// of this claim when set to true.
bool focal;

//  Reference to the insurance card level information contained in the
// Coverage resource. The coverage issuing insurer will use these details
// to locate the patient's actual coverage within the insurer's
// information system.
Reference coverage;

//  Reference numbers previously provided by the insurer to the provider
// to be quoted on subsequent claims containing services or products
// related to the prior authorization.
List<String> preAuthRef;

ExplanationOfBenefit_Insurance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.focal,
    this.coverage,
    this.preAuthRef,
    });

  factory ExplanationOfBenefit_Insurance.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_InsuranceFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_InsuranceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Accident {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Date of an accident event  related to the products and services
// contained in the claim.
String date;

//  The type or context of the accident event for the purposes of
// selection of potential insurance coverages and determination of
// coordination between insurers.
CodeableConcept type;

//  The physical location of the accident event.
Address locationAddress;

//  The physical location of the accident event.
Reference locationReference;

ExplanationOfBenefit_Accident(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.date,
    this.type,
    this.locationAddress,
    this.locationReference,
    });

  factory ExplanationOfBenefit_Accident.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_AccidentFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_AccidentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify item entries.
int sequence;

//  Care team members related to this service or product.
List<int> careTeamSequence;

//  Diagnoses applicable for this service or product.
List<int> diagnosisSequence;

//  Procedures applicable for this service or product.
List<int> procedureSequence;

//  Exceptions, special conditions and supporting information applicable
// for this service or product.
List<int> informationSequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The date or dates when the service or product was supplied, performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the service or product was supplied, performed
// or completed.
Period servicedPeriod;

//  Where the product or service was provided.
CodeableConcept locationCodeableConcept;

//  Where the product or service was provided.
Address locationAddress;

//  Where the product or service was provided.
Reference locationReference;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

//  Physical service site on the patient (limb, tooth, etc.).
CodeableConcept bodySite;

//  A region or surface of the bodySite, e.g. limb region or tooth
// surface(s).
List<CodeableConcept> subSite;

//  A billed item may include goods or services provided in multiple
// encounters.
List<Reference> encounter;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  If this item is a group then the values here are a summary of the
// adjudication of the detail items. If this item is a simple product or
// service then this is the result of the adjudication of this item.
List<ExplanationOfBenefit_Adjudication> adjudication;

//  Second-tier of goods and services.
List<ExplanationOfBenefit_Detail> detail;

ExplanationOfBenefit_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.careTeamSequence,
    this.diagnosisSequence,
    this.procedureSequence,
    this.informationSequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.servicedDate,
    this.servicedPeriod,
    this.locationCodeableConcept,
    this.locationAddress,
    this.locationReference,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    this.bodySite,
    this.subSite,
    this.encounter,
    this.noteNumber,
    this.adjudication,
    this.detail,
    });

  factory ExplanationOfBenefit_Item.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Adjudication {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code to indicate the information type of this adjudication record.
// Information types may include: the value submitted, maximum values or
// percentages allowed or payable under the plan, amounts that the patient
// is responsible for in-aggregate or pertaining to this item, amounts
// paid by other coverages, and the benefit payable for this item.
CodeableConcept category;

//  A code supporting the understanding of the adjudication result and
// explaining variance from expected amount.
CodeableConcept reason;

//  Monetary amount associated with the category.
Money amount;

//  A non-monetary value associated with the category. Mutually exclusive
// to the amount element above.
double value;

ExplanationOfBenefit_Adjudication(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.reason,
    this.amount,
    this.value,
    });

  factory ExplanationOfBenefit_Adjudication.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_AdjudicationFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_AdjudicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A claim detail line. Either a simple (a product or service) or a
// 'group' of sub-details which are simple items.
int sequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ExplanationOfBenefit_Adjudication> adjudication;

//  Third-tier of goods and services.
List<ExplanationOfBenefit_SubDetail> subDetail;

ExplanationOfBenefit_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    this.noteNumber,
    this.adjudication,
    this.subDetail,
    });

  factory ExplanationOfBenefit_Detail.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_DetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_SubDetail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A claim detail line. Either a simple (a product or service) or a
// 'group' of sub-details which are simple items.
int sequence;

//  The type of revenue or cost center providing the product and/or
// service.
CodeableConcept revenue;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Unique Device Identifiers associated with this line item.
List<Reference> udi;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ExplanationOfBenefit_Adjudication> adjudication;

ExplanationOfBenefit_SubDetail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.revenue,
    this.category,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.udi,
    this.noteNumber,
    this.adjudication,
    });

  factory ExplanationOfBenefit_SubDetail.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_SubDetailFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_SubDetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_AddItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Claim items which this service line is intended to replace.
List<int> itemSequence;

//  The sequence number of the details within the claim item which this
// line is intended to replace.
List<int> detailSequence;

//  The sequence number of the sub-details woithin the details within the
// claim item which this line is intended to replace.
List<int> subDetailSequence;

//  The providers who are authorized for the services rendered to the
// patient.
List<Reference> provider;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  Identifies the program under which this may be recovered.
List<CodeableConcept> programCode;

//  The date or dates when the service or product was supplied, performed
// or completed.
String servicedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or dates when the service or product was supplied, performed
// or completed.
Period servicedPeriod;

//  Where the product or service was provided.
CodeableConcept locationCodeableConcept;

//  Where the product or service was provided.
Address locationAddress;

//  Where the product or service was provided.
Reference locationReference;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  Physical service site on the patient (limb, tooth, etc.).
CodeableConcept bodySite;

//  A region or surface of the bodySite, e.g. limb region or tooth
// surface(s).
List<CodeableConcept> subSite;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ExplanationOfBenefit_Adjudication> adjudication;

//  The second-tier service adjudications for payor added services.
List<ExplanationOfBenefit_Detail1> detail;

ExplanationOfBenefit_AddItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemSequence,
    this.detailSequence,
    this.subDetailSequence,
    this.provider,
    this.productOrService,
    this.modifier,
    this.programCode,
    this.servicedDate,
    this.servicedPeriod,
    this.locationCodeableConcept,
    this.locationAddress,
    this.locationReference,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.bodySite,
    this.subSite,
    this.noteNumber,
    this.adjudication,
    this.detail,
    });

  factory ExplanationOfBenefit_AddItem.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_AddItemFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_AddItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Detail1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ExplanationOfBenefit_Adjudication> adjudication;

//  The third-tier service adjudications for payor added services.
List<ExplanationOfBenefit_SubDetail1> subDetail;

ExplanationOfBenefit_Detail1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.productOrService,
    this.modifier,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.noteNumber,
    this.adjudication,
    this.subDetail,
    });

  factory ExplanationOfBenefit_Detail1.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_Detail1FromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_Detail1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_SubDetail1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  When the value is a group code then this item collects a set of
// related claim details, otherwise this contains the product, service,
// drug or other billing code for the item.
CodeableConcept productOrService;

//  Item typification or modifiers codes to convey additional context for
// the product or service.
List<CodeableConcept> modifier;

//  The number of repetitions of a service or product.
Quantity quantity;

//  If the item is not a group then this is the fee for the product or
// service, otherwise this is the total of the fees for the details of the
// group.
Money unitPrice;

//  A real number that represents a multiplier used in determining the
// overall value of services delivered and/or goods received. The concept
// of a Factor allows for a discount or surcharge multiplier to be applied
// to a monetary amount.
double factor;

//  The quantity times the unit price for an additional service or product
// or charge.
Money net;

//  The numbers associated with notes below which apply to the
// adjudication of this item.
List<int> noteNumber;

//  The adjudication results.
List<ExplanationOfBenefit_Adjudication> adjudication;

ExplanationOfBenefit_SubDetail1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.productOrService,
    this.modifier,
    this.quantity,
    this.unitPrice,
    this.factor,
    this.net,
    this.noteNumber,
    this.adjudication,
    });

  factory ExplanationOfBenefit_SubDetail1.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_SubDetail1FromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_SubDetail1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Total {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code to indicate the information type of this adjudication record.
// Information types may include: the value submitted, maximum values or
// percentages allowed or payable under the plan, amounts that the patient
// is responsible for in aggregate or pertaining to this item, amounts
// paid by other coverages, and the benefit payable for this item.
CodeableConcept category;

//  Monetary total amount associated with the category.
Money amount;

ExplanationOfBenefit_Total(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.amount,
    });

  factory ExplanationOfBenefit_Total.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_TotalFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_TotalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Payment {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether this represents partial or complete payment of the benefits
// payable.
CodeableConcept type;

//  Total amount of all adjustments to this payment included in this
// transaction which are not related to this claim's adjudication.
Money adjustment;

//  Reason for the payment adjustment.
CodeableConcept adjustmentReason;

//  Estimated date the payment will be issued or the actual issue date of
// payment.
String date;

//  Benefits payable less any payment adjustment.
Money amount;

//  Issuer's unique identifier for the payment instrument.
Identifier identifier;

ExplanationOfBenefit_Payment(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.adjustment,
    this.adjustmentReason,
    this.date,
    this.amount,
    this.identifier,
    });

  factory ExplanationOfBenefit_Payment.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_PaymentFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_PaymentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_ProcessNote {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number to uniquely identify a note entry.
int number;

//  The business purpose of the note text.
String type; // <code> enum: display/print/printoper;

//  The explanation or description associated with the processing.
String text;

//  A code to define the language used in the text of the note.
CodeableConcept language;

ExplanationOfBenefit_ProcessNote(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.number,
    this.type,
    this.text,
    this.language,
    });

  factory ExplanationOfBenefit_ProcessNote.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_ProcessNoteFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_ProcessNoteToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_BenefitBalance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Code to identify the general type of benefits under which products and
// services are provided.
CodeableConcept category;

//  True if the indicated class of service is excluded from the plan,
// missing or False indicates the product or service is included in the
// coverage.
bool excluded;

//  A short name or tag for the benefit.
String name;

//  A richer description of the benefit or services covered.
String description;

//  Is a flag to indicate whether the benefits refer to in-network
// providers or out-of-network providers.
CodeableConcept network;

//  Indicates if the benefits apply to an individual or to the family.
CodeableConcept unit;

//  The term or period of the values such as 'maximum lifetime benefit' or
// 'maximum annual visits'.
CodeableConcept term;

//  Benefits Used to date.
List<ExplanationOfBenefit_Financial> financial;

ExplanationOfBenefit_BenefitBalance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.excluded,
    this.name,
    this.description,
    this.network,
    this.unit,
    this.term,
    this.financial,
    });

  factory ExplanationOfBenefit_BenefitBalance.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_BenefitBalanceFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_BenefitBalanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ExplanationOfBenefit_Financial {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Classification of benefit being provided.
CodeableConcept type;

//  The quantity of the benefit which is permitted under the coverage.
int allowedUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The quantity of the benefit which is permitted under the coverage.
String allowedString; //  pattern: ^[ \r\n\t\S]+$

//  The quantity of the benefit which is permitted under the coverage.
Money allowedMoney;

//  The quantity of the benefit which have been consumed to date.
int usedUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The quantity of the benefit which have been consumed to date.
Money usedMoney;

ExplanationOfBenefit_Financial(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.allowedUnsignedInt,
    this.allowedString,
    this.allowedMoney,
    this.usedUnsignedInt,
    this.usedMoney,
    });

  factory ExplanationOfBenefit_Financial.fromJson(Map<String, dynamic> json) => _$ExplanationOfBenefit_FinancialFromJson(json);
  Map<String, dynamic> toJson() => _$ExplanationOfBenefit_FinancialToJson(this);
}

part 'familyMemberHistory.g.dart';

@JsonSerializable(explicitToJson: true)
class FamilyMemberHistory {

//  This is a FamilyMemberHistory resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this family member history by the
// performer or other systems which remain constant as the resource is
// updated and propagates from server to server.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this
// FamilyMemberHistory.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this FamilyMemberHistory.
List<String> instantiatesUri;

//  A code specifying the status of the record of the family history of a
// specific family member.
String status; // <code> enum: partial/completed/entered-in-error/health-unknown;

//  Describes why the family member's history is not available.
CodeableConcept dataAbsentReason;

//  The person who this history concerns.
Reference patient;

//  The date (and possibly time) when the family member history was
// recorded or last updated.
DateTime date;

//  This will either be a name or a description; e.g. "Aunt Susan", "my
// cousin with the red hair".
String name;

//  The type of relationship this person has to the patient (father,
// mother, brother etc.).
CodeableConcept relationship;

//  The birth sex of the family member.
CodeableConcept sex;

//  The actual or approximate date of birth of the relative.
Period bornPeriod;

//  The actual or approximate date of birth of the relative.
String bornDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The actual or approximate date of birth of the relative.
String bornString; //  pattern: ^[ \r\n\t\S]+$

//  The age of the relative at the time the family member history is
// recorded.
Age ageAge;

//  The age of the relative at the time the family member history is
// recorded.
Range ageRange;

//  The age of the relative at the time the family member history is
// recorded.
String ageString; //  pattern: ^[ \r\n\t\S]+$

//  If true, indicates that the age value specified is an estimated value.
bool estimatedAge;

//  Deceased flag or the actual or approximate age of the relative at the
// time of death for the family member history record.
bool deceasedBoolean; //  pattern: ^true|false$

//  Deceased flag or the actual or approximate age of the relative at the
// time of death for the family member history record.
Age deceasedAge;

//  Deceased flag or the actual or approximate age of the relative at the
// time of death for the family member history record.
Range deceasedRange;

//  Deceased flag or the actual or approximate age of the relative at the
// time of death for the family member history record.
String deceasedDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Deceased flag or the actual or approximate age of the relative at the
// time of death for the family member history record.
String deceasedString; //  pattern: ^[ \r\n\t\S]+$

//  Describes why the family member history occurred in coded or textual
// form.
List<CodeableConcept> reasonCode;

//  Indicates a Condition, Observation, AllergyIntolerance, or
// QuestionnaireResponse that justifies this family member history event.
List<Reference> reasonReference;

//  This property allows a non condition-specific note to the made about
// the related person. Ideally, the note would be in the condition
// property, but this is not always possible.
List<Annotation> note;

//  The significant Conditions (or condition) that the family member had.
// This is a repeating section to allow a system to represent more than
// one condition per resource, though there is nothing stopping multiple
// resources - one per condition.
List<FamilyMemberHistory_Condition> condition;

FamilyMemberHistory(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.status,
    this.dataAbsentReason,
    this.patient,
    this.date,
    this.name,
    this.relationship,
    this.sex,
    this.bornPeriod,
    this.bornDate,
    this.bornString,
    this.ageAge,
    this.ageRange,
    this.ageString,
    this.estimatedAge,
    this.deceasedBoolean,
    this.deceasedAge,
    this.deceasedRange,
    this.deceasedDate,
    this.deceasedString,
    this.reasonCode,
    this.reasonReference,
    this.note,
    this.condition,
    });

  factory FamilyMemberHistory.fromJson(Map<String, dynamic> json) => _$FamilyMemberHistoryFromJson(json);
  Map<String, dynamic> toJson() => _$FamilyMemberHistoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class FamilyMemberHistory_Condition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The actual condition specified. Could be a coded condition (like MI or
// Diabetes) or a less specific string like 'cancer' depending on how much
// is known about the condition and the capabilities of the creating
// system.
CodeableConcept code;

//  Indicates what happened following the condition.  If the condition
// resulted in death, deceased date is captured on the relation.
CodeableConcept outcome;

//  This condition contributed to the cause of death of the related
// person. If contributedToDeath is not populated, then it is unknown.
bool contributedToDeath;

//  Either the age of onset, range of approximate age or descriptive
// string can be recorded.  For conditions with multiple occurrences, this
// describes the first known occurrence.
Age onsetAge;

//  Either the age of onset, range of approximate age or descriptive
// string can be recorded.  For conditions with multiple occurrences, this
// describes the first known occurrence.
Range onsetRange;

//  Either the age of onset, range of approximate age or descriptive
// string can be recorded.  For conditions with multiple occurrences, this
// describes the first known occurrence.
Period onsetPeriod;

//  Either the age of onset, range of approximate age or descriptive
// string can be recorded.  For conditions with multiple occurrences, this
// describes the first known occurrence.
String onsetString; //  pattern: ^[ \r\n\t\S]+$

//  An area where general notes can be placed about this specific
// condition.
List<Annotation> note;

FamilyMemberHistory_Condition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.outcome,
    this.contributedToDeath,
    this.onsetAge,
    this.onsetRange,
    this.onsetPeriod,
    this.onsetString,
    this.note,
    });

  factory FamilyMemberHistory_Condition.fromJson(Map<String, dynamic> json) => _$FamilyMemberHistory_ConditionFromJson(json);
  Map<String, dynamic> toJson() => _$FamilyMemberHistory_ConditionToJson(this);
}

part 'flag.g.dart';

@JsonSerializable(explicitToJson: true)
class Flag {

//  This is a Flag resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this flag by the performer or other
// systems which remain constant as the resource is updated and propagates
// from server to server.
List<Identifier> identifier;

//  Supports basic workflow.
String status; // <code> enum: active/inactive/entered-in-error;

//  Allows a flag to be divided into different categories like clinical,
// administrative etc. Intended to be used as a means of filtering which
// flags are displayed to particular user or in a given context.
List<CodeableConcept> category;

//  The coded value or textual component of the flag to display to the
// user.
CodeableConcept code;

//  The patient, location, group, organization, or practitioner etc. this
// is about record this flag is associated with.
Reference subject;

//  The period of time from the activation of the flag to inactivation of
// the flag. If the flag is active, the end of the period should be
// unspecified.
Period period;

//  This alert is only relevant during the encounter.
Reference encounter;

//  The person, organization or device that created the flag.
Reference author;

Flag(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.category,
    this.code,
    this.subject,
    this.period,
    this.encounter,
    this.author,
    });

  factory Flag.fromJson(Map<String, dynamic> json) => _$FlagFromJson(json);
  Map<String, dynamic> toJson() => _$FlagToJson(this);
}

part 'goal.g.dart';

@JsonSerializable(explicitToJson: true)
class Goal {

//  This is a Goal resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this goal by the performer or other
// systems which remain constant as the resource is updated and propagates
// from server to server.
List<Identifier> identifier;

//  The state of the goal throughout its lifecycle.
String lifecycleStatus; // <code> enum: proposed/planned/accepted/active/on-hold/completed/cancelled/entered-in-error/rejected;

//  Describes the progression, or lack thereof, towards the goal against
// the target.
CodeableConcept achievementStatus;

//  Indicates a category the goal falls within.
List<CodeableConcept> category;

//  Identifies the mutually agreed level of importance associated with
// reaching/sustaining the goal.
CodeableConcept priority;

//  Human-readable and/or coded description of a specific desired
// objective of care, such as "control blood pressure" or "negotiate an
// obstacle course" or "dance with child at wedding".
CodeableConcept description;

//  Identifies the patient, group or organization for whom the goal is
// being established.
Reference subject;

//  The date or event after which the goal should begin being pursued.
String startDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The date or event after which the goal should begin being pursued.
CodeableConcept startCodeableConcept;

//  Indicates what should be done by when.
List<Goal_Target> target;

//  Identifies when the current status.  I.e. When initially created, when
// achieved, when cancelled, etc.
String statusDate;

//  Captures the reason for the current status.
String statusReason;

//  Indicates whose goal this is - patient goal, practitioner goal, etc.
Reference expressedBy;

//  The identified conditions and other health record elements that are
// intended to be addressed by the goal.
List<Reference> addresses;

//  Any comments related to the goal.
List<Annotation> note;

//  Identifies the change (or lack of change) at the point when the status
// of the goal is assessed.
List<CodeableConcept> outcomeCode;

//  Details of what's changed (or not changed).
List<Reference> outcomeReference;

Goal(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.lifecycleStatus,
    this.achievementStatus,
    this.category,
    this.priority,
    this.description,
    this.subject,
    this.startDate,
    this.startCodeableConcept,
    this.target,
    this.statusDate,
    this.statusReason,
    this.expressedBy,
    this.addresses,
    this.note,
    this.outcomeCode,
    this.outcomeReference,
    });

  factory Goal.fromJson(Map<String, dynamic> json) => _$GoalFromJson(json);
  Map<String, dynamic> toJson() => _$GoalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Goal_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The parameter whose value is being tracked, e.g. body weight, blood
// pressure, or hemoglobin A1c level.
CodeableConcept measure;

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
Quantity detailQuantity;

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
Range detailRange;

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
CodeableConcept detailCodeableConcept;

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
String detailString; //  pattern: ^[ \r\n\t\S]+$

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
bool detailBoolean; //  pattern: ^true|false$

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
int detailInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The target value of the focus to be achieved to signify the
// fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low
// or both values of the range can be specified. When a low value is
// missing, it indicates that the goal is achieved at any focus value at
// or below the high value. Similarly, if the high value is missing, it
// indicates that the goal is achieved at any focus value at or above the
// low value.
Ratio detailRatio;

//  Indicates either the date or the duration after start by which the
// goal should be met.
String dueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  Indicates either the date or the duration after start by which the
// goal should be met.
Duration dueDuration;

Goal_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.measure,
    this.detailQuantity,
    this.detailRange,
    this.detailCodeableConcept,
    this.detailString,
    this.detailBoolean,
    this.detailInteger,
    this.detailRatio,
    this.dueDate,
    this.dueDuration,
    });

  factory Goal_Target.fromJson(Map<String, dynamic> json) => _$Goal_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$Goal_TargetToJson(this);
}

part 'graphDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class GraphDefinition {

//  This is a GraphDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this graph definition when it
// is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this graph definition is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// graph definition is stored on different servers.
String url;

//  The identifier that is used to identify this version of the graph
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the graph definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the graph definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  The status of this graph definition. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this graph definition is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the graph definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the graph definition changes.
DateTime date;

//  The name of the organization or individual that published the graph
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the graph definition from
// a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate graph definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the graph definition is intended
// to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this graph definition is needed and why it has been
// designed as it has.
String purpose;

//  The type of FHIR resource at which instances of this graph start.
String start;

//  The profile that describes the use of the base resource.
String profile;

//  Links this graph makes rules about.
List<GraphDefinition_Link> link;

GraphDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.start,
    this.profile,
    this.link,
    });

  factory GraphDefinition.fromJson(Map<String, dynamic> json) => _$GraphDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$GraphDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class GraphDefinition_Link {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A FHIR expression that identifies one of FHIR References to other
// resources.
String path;

//  Which slice (if profiled).
String sliceName;

//  Minimum occurrences for this link.
int min;

//  Maximum occurrences for this link.
String max;

//  Information about why this link is of interest in this graph
// definition.
String description;

//  Potential target for the link.
List<GraphDefinition_Target> target;

GraphDefinition_Link(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.sliceName,
    this.min,
    this.max,
    this.description,
    this.target,
    });

  factory GraphDefinition_Link.fromJson(Map<String, dynamic> json) => _$GraphDefinition_LinkFromJson(json);
  Map<String, dynamic> toJson() => _$GraphDefinition_LinkToJson(this);
}

@JsonSerializable(explicitToJson: true)
class GraphDefinition_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of resource this link refers to.
String type;

//  A set of parameters to look up.
String params;

//  Profile for the target resource.
String profile;

//  Compartment Consistency Rules.
List<GraphDefinition_Compartment> compartment;

//  Additional links from target resource.
List<GraphDefinition_Link> link;

GraphDefinition_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.params,
    this.profile,
    this.compartment,
    this.link,
    });

  factory GraphDefinition_Target.fromJson(Map<String, dynamic> json) => _$GraphDefinition_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$GraphDefinition_TargetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class GraphDefinition_Compartment {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Defines how the compartment rule is used - whether it it is used to
// test whether resources are subject to the rule, or whether it is a rule
// that must be followed.
String use; // <code> enum: condition/requirement;

//  Identifies the compartment.
String code;

//  identical | matching | different | no-rule | custom.
String rule; // <code> enum: identical/matching/different/custom;

//  Custom rule, as a FHIRPath expression.
String expression;

//  Documentation for FHIRPath expression.
String description;

GraphDefinition_Compartment(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.use,
    this.code,
    this.rule,
    this.expression,
    this.description,
    });

  factory GraphDefinition_Compartment.fromJson(Map<String, dynamic> json) => _$GraphDefinition_CompartmentFromJson(json);
  Map<String, dynamic> toJson() => _$GraphDefinition_CompartmentToJson(this);
}

part 'group.g.dart';

@JsonSerializable(explicitToJson: true)
class Group {

//  This is a Group resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique business identifier for this group.
List<Identifier> identifier;

//  Indicates whether the record for the group is available for use or is
// merely being retained for historical purposes.
bool active;

//  Identifies the broad classification of the kind of resources the group
// includes.
String type; // <code> enum: person/animal/practitioner/device/medication/substance;

//  If true, indicates that the resource refers to a specific group of
// real individuals.  If false, the group defines a set of intended
// individuals.
bool actual;

//  Provides a specific type of resource the group includes; e.g. "cow",
// "syringe", etc.
CodeableConcept code;

//  A label assigned to the group for human identification and
// communication.
String name;

//  A count of the number of resource instances that are part of the
// group.
int quantity;

//  Entity responsible for defining and maintaining Group characteristics
// and/or registered members.
Reference managingEntity;

//  Identifies traits whose presence r absence is shared by members of the
// group.
List<Group_Characteristic> characteristic;

//  Identifies the resource instances that are members of the group.
List<Group_Member> member;

Group(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.type,
    this.actual,
    this.code,
    this.name,
    this.quantity,
    this.managingEntity,
    this.characteristic,
    this.member,
    });

  factory Group.fromJson(Map<String, dynamic> json) => _$GroupFromJson(json);
  Map<String, dynamic> toJson() => _$GroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Group_Characteristic {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code that identifies the kind of trait being asserted.
CodeableConcept code;

//  The value of the trait that holds (or does not hold - see 'exclude')
// for members of the group.
CodeableConcept valueCodeableConcept;

//  The value of the trait that holds (or does not hold - see 'exclude')
// for members of the group.
bool valueBoolean; //  pattern: ^true|false$

//  The value of the trait that holds (or does not hold - see 'exclude')
// for members of the group.
Quantity valueQuantity;

//  The value of the trait that holds (or does not hold - see 'exclude')
// for members of the group.
Range valueRange;

//  The value of the trait that holds (or does not hold - see 'exclude')
// for members of the group.
Reference valueReference;

//  If true, indicates the characteristic is one that is NOT held by
// members of the group.
bool exclude;

//  The period over which the characteristic is tested; e.g. the patient
// had an operation during the month of June.
Period period;

Group_Characteristic(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.valueCodeableConcept,
    this.valueBoolean,
    this.valueQuantity,
    this.valueRange,
    this.valueReference,
    this.exclude,
    this.period,
    });

  factory Group_Characteristic.fromJson(Map<String, dynamic> json) => _$Group_CharacteristicFromJson(json);
  Map<String, dynamic> toJson() => _$Group_CharacteristicToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Group_Member {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A reference to the entity that is a member of the group. Must be
// consistent with Group.type. If the entity is another group, then the
// type must be the same.
Reference entity;

//  The period that the member was in the group, if known.
Period period;

//  A flag to indicate that the member is no longer in the group, but
// previously may have been a member.
bool inactive;

Group_Member(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.entity,
    this.period,
    this.inactive,
    });

  factory Group_Member.fromJson(Map<String, dynamic> json) => _$Group_MemberFromJson(json);
  Map<String, dynamic> toJson() => _$Group_MemberToJson(this);
}

part 'guidanceResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class GuidanceResponse {

//  This is a GuidanceResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The identifier of the request associated with this response. If an
// identifier was given as part of the request, it will be reproduced here
// to enable the requester to more easily identify the response in a
// multi-request scenario.
Identifier requestIdentifier;

//  Allows a service to provide  unique, business identifiers for the
// response.
List<Identifier> identifier;

//  An identifier, CodeableConcept or canonical reference to the guidance
// that was requested.
String moduleUri; //  pattern: ^\S*$

//  An identifier, CodeableConcept or canonical reference to the guidance
// that was requested.
String moduleCanonical; //  pattern: ^\S*$

//  An identifier, CodeableConcept or canonical reference to the guidance
// that was requested.
CodeableConcept moduleCodeableConcept;

//  The status of the response. If the evaluation is completed
// successfully, the status will indicate success. However, in order to
// complete the evaluation, the engine may require more information. In
// this case, the status will be data-required, and the response will
// contain a description of the additional required information. If the
// evaluation completed successfully, but the engine determines that a
// potentially more accurate response could be provided if more data was
// available, the status will be data-requested, and the response will
// contain a description of the additional requested information.
String status; // <code> enum: success/data-requested/data-required/in-progress/failure/entered-in-error;

//  The patient for which the request was processed.
Reference subject;

//  The encounter during which this response was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  Indicates when the guidance response was processed.
DateTime occurrenceDateTime;

//  Provides a reference to the device that performed the guidance.
Reference performer;

//  Describes the reason for the guidance response in coded or textual
// form.
List<CodeableConcept> reasonCode;

//  Indicates the reason the request was initiated. This is typically
// provided as a parameter to the evaluation and echoed by the service,
// although for some use cases, such as subscription- or event-based
// scenarios, it may provide an indication of the cause for the response.
List<Reference> reasonReference;

//  Provides a mechanism to communicate additional information about the
// response.
List<Annotation> note;

//  Messages resulting from the evaluation of the artifact or artifacts.
// As part of evaluating the request, the engine may produce informational
// or warning messages. These messages will be provided by this element.
List<Reference> evaluationMessage;

//  The output parameters of the evaluation, if any. Many modules will
// result in the return of specific resources such as procedure or
// communication requests that are returned as part of the operation
// result. However, modules may define specific outputs that would be
// returned as the result of the evaluation, and these would be returned
// in this element.
Reference outputParameters;

//  The actions, if any, produced by the evaluation of the artifact.
Reference result;

//  If the evaluation could not be completed due to lack of information,
// or additional information would potentially result in a more accurate
// response, this element will a description of the data required in order
// to proceed with the evaluation. A subsequent request to the service
// should include this data.
List<DataRequirement> dataRequirement;

GuidanceResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.requestIdentifier,
    this.identifier,
    this.moduleUri,
    this.moduleCanonical,
    this.moduleCodeableConcept,
    this.status,
    this.subject,
    this.encounter,
    this.occurrenceDateTime,
    this.performer,
    this.reasonCode,
    this.reasonReference,
    this.note,
    this.evaluationMessage,
    this.outputParameters,
    this.result,
    this.dataRequirement,
    });

  factory GuidanceResponse.fromJson(Map<String, dynamic> json) => _$GuidanceResponseFromJson(json);
  Map<String, dynamic> toJson() => _$GuidanceResponseToJson(this);
}

part 'healthcareService.g.dart';

@JsonSerializable(explicitToJson: true)
class HealthcareService {

//  This is a HealthcareService resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  External identifiers for this item.
List<Identifier> identifier;

//  This flag is used to mark the record to not be used. This is not used
// when a center is closed for maintenance, or for holidays, the
// notAvailable period is to be used for this.
bool active;

//  The organization that provides this healthcare service.
Reference providedBy;

//  Identifies the broad category of service being performed or delivered.
List<CodeableConcept> category;

//  The specific type of service that may be delivered or performed.
List<CodeableConcept> type;

//  Collection of specialties handled by the service site. This is more of
// a medical term.
List<CodeableConcept> specialty;

//  The location(s) where this healthcare service may be provided.
List<Reference> location;

//  Further description of the service as it would be presented to a
// consumer while searching.
String name;

//  Any additional description of the service and/or any specific issues
// not covered by the other attributes, which can be displayed as further
// detail under the serviceName.
String comment;

//  Extra details about the service that can't be placed in the other
// fields.
String extraDetails;

//  If there is a photo/symbol associated with this HealthcareService, it
// may be included here to facilitate quick identification of the service
// in a list.
Attachment photo;

//  List of contacts related to this specific healthcare service.
List<ContactPoint> telecom;

//  The location(s) that this service is available to (not where the
// service is provided).
List<Reference> coverageArea;

//  The code(s) that detail the conditions under which the healthcare
// service is available/offered.
List<CodeableConcept> serviceProvisionCode;

//  Does this service have specific eligibility requirements that need to
// be met in order to use the service?
List<HealthcareService_Eligibility> eligibility;

//  Programs that this service is applicable to.
List<CodeableConcept> program;

//  Collection of characteristics (attributes).
List<CodeableConcept> characteristic;

//  Some services are specifically made available in multiple languages,
// this property permits a directory to declare the languages this is
// offered in. Typically this is only provided where a service operates in
// communities with mixed languages used.
List<CodeableConcept> communication;

//  Ways that the service accepts referrals, if this is not provided then
// it is implied that no referral is required.
List<CodeableConcept> referralMethod;

//  Indicates whether or not a prospective consumer will require an
// appointment for a particular service at a site to be provided by the
// Organization. Indicates if an appointment is required for access to
// this service.
bool appointmentRequired;

//  A collection of times that the Service Site is available.
List<HealthcareService_AvailableTime> availableTime;

//  The HealthcareService is not available during this period of time due
// to the provided reason.
List<HealthcareService_NotAvailable> notAvailable;

//  A description of site availability exceptions, e.g. public holiday
// availability. Succinctly describing all possible exceptions to normal
// site availability as details in the available Times and not available
// Times.
String availabilityExceptions;

//  Technical endpoints providing access to services operated for the
// specific healthcare services defined at this resource.
List<Reference> endpoint;

HealthcareService(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.providedBy,
    this.category,
    this.type,
    this.specialty,
    this.location,
    this.name,
    this.comment,
    this.extraDetails,
    this.photo,
    this.telecom,
    this.coverageArea,
    this.serviceProvisionCode,
    this.eligibility,
    this.program,
    this.characteristic,
    this.communication,
    this.referralMethod,
    this.appointmentRequired,
    this.availableTime,
    this.notAvailable,
    this.availabilityExceptions,
    this.endpoint,
    });

  factory HealthcareService.fromJson(Map<String, dynamic> json) => _$HealthcareServiceFromJson(json);
  Map<String, dynamic> toJson() => _$HealthcareServiceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class HealthcareService_Eligibility {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Coded value for the eligibility.
CodeableConcept code;

//  Describes the eligibility conditions for the service.
String comment;

HealthcareService_Eligibility(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.comment,
    });

  factory HealthcareService_Eligibility.fromJson(Map<String, dynamic> json) => _$HealthcareService_EligibilityFromJson(json);
  Map<String, dynamic> toJson() => _$HealthcareService_EligibilityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class HealthcareService_AvailableTime {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates which days of the week are available between the start and
// end Times.
List<String> daysOfWeek; // <code> enum: mon/tue/wed/thu/fri/sat/sun> daysOfWeek;

//  Is this always available? (hence times are irrelevant) e.g. 24 hour
// service.
bool allDay;

//  The opening time of day. Note: If the AllDay flag is set, then this
// time is ignored.
String availableStartTime;

//  The closing time of day. Note: If the AllDay flag is set, then this
// time is ignored.
String availableEndTime;

HealthcareService_AvailableTime(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.daysOfWeek,
    this.allDay,
    this.availableStartTime,
    this.availableEndTime,
    });

  factory HealthcareService_AvailableTime.fromJson(Map<String, dynamic> json) => _$HealthcareService_AvailableTimeFromJson(json);
  Map<String, dynamic> toJson() => _$HealthcareService_AvailableTimeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class HealthcareService_NotAvailable {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The reason that can be presented to the user as to why this time is
// not available.
String description;

//  Service is not available (seasonally or for a public holiday) from
// this date.
Period during;

HealthcareService_NotAvailable(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.during,
    });

  factory HealthcareService_NotAvailable.fromJson(Map<String, dynamic> json) => _$HealthcareService_NotAvailableFromJson(json);
  Map<String, dynamic> toJson() => _$HealthcareService_NotAvailableToJson(this);
}

part 'imagingStudy.g.dart';

@JsonSerializable(explicitToJson: true)
class ImagingStudy {

//  This is a ImagingStudy resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers for the ImagingStudy such as DICOM Study Instance UID, and
// Accession Number.
List<Identifier> identifier;

//  The current state of the ImagingStudy.
String status; // <code> enum: registered/available/cancelled/entered-in-error/unknown;

//  A list of all the series.modality values that are actual acquisition
// modalities, i.e. those in the DICOM Context Group 29 (value set OID
// 1.2.840.10008.6.1.19).
List<Coding> modality;

//  The subject, typically a patient, of the imaging study.
Reference subject;

//  The healthcare event (e.g. a patient and healthcare provider
// interaction) during which this ImagingStudy is made.
Reference encounter;

//  Date and time the study started.
DateTime started;

//  A list of the diagnostic requests that resulted in this imaging study
// being performed.
List<Reference> basedOn;

//  The requesting/referring physician.
Reference referrer;

//  Who read the study and interpreted the images or other content.
List<Reference> interpreter;

//  The network service providing access (e.g., query, view, or retrieval)
// for the study. See implementation notes for information about using
// DICOM endpoints. A study-level endpoint applies to each series in the
// study, unless overridden by a series-level endpoint with the same
// Endpoint.connectionType.
List<Reference> endpoint;

//  Number of Series in the Study. This value given may be larger than the
// number of series elements this Resource contains due to resource
// availability, security, or other factors. This element should be
// present if any series elements are present.
int numberOfSeries;

//  Number of SOP Instances in Study. This value given may be larger than
// the number of instance elements this resource contains due to resource
// availability, security, or other factors. This element should be
// present if any instance elements are present.
int numberOfInstances;

//  The procedure which this ImagingStudy was part of.
Reference procedureReference;

//  The code for the performed procedure type.
List<CodeableConcept> procedureCode;

//  The principal physical location where the ImagingStudy was performed.
Reference location;

//  Description of clinical condition indicating why the ImagingStudy was
// requested.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies this Study.
List<Reference> reasonReference;

//  Per the recommended DICOM mapping, this element is derived from the
// Study Description attribute (0008,1030). Observations or findings about
// the imaging study should be recorded in another resource, e.g.
// Observation, and not in this element.
List<Annotation> note;

//  The Imaging Manager description of the study. Institution-generated
// description or classification of the Study (component) performed.
String description;

//  Each study has one or more series of images or other content.
List<ImagingStudy_Series> series;

ImagingStudy(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.modality,
    this.subject,
    this.encounter,
    this.started,
    this.basedOn,
    this.referrer,
    this.interpreter,
    this.endpoint,
    this.numberOfSeries,
    this.numberOfInstances,
    this.procedureReference,
    this.procedureCode,
    this.location,
    this.reasonCode,
    this.reasonReference,
    this.note,
    this.description,
    this.series,
    });

  factory ImagingStudy.fromJson(Map<String, dynamic> json) => _$ImagingStudyFromJson(json);
  Map<String, dynamic> toJson() => _$ImagingStudyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImagingStudy_Series {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The DICOM Series Instance UID for the series.
String uid;

//  The numeric identifier of this series in the study.
int number;

//  The modality of this series sequence.
Coding modality;

//  A description of the series.
String description;

//  Number of SOP Instances in the Study. The value given may be larger
// than the number of instance elements this resource contains due to
// resource availability, security, or other factors. This element should
// be present if any instance elements are present.
int numberOfInstances;

//  The network service providing access (e.g., query, view, or retrieval)
// for this series. See implementation notes for information about using
// DICOM endpoints. A series-level endpoint, if present, has precedence
// over a study-level endpoint with the same Endpoint.connectionType.
List<Reference> endpoint;

//  The anatomic structures examined. See DICOM Part 16 Annex L
// (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html)
// for DICOM to SNOMED-CT mappings. The bodySite may indicate the
// laterality of body part imaged; if so, it shall be consistent with any
// content of ImagingStudy.series.laterality.
Coding bodySite;

//  The laterality of the (possibly paired) anatomic structures examined.
// E.g., the left knee, both lungs, or unpaired abdomen. If present, shall
// be consistent with any laterality information indicated in
// ImagingStudy.series.bodySite.
Coding laterality;

//  The specimen imaged, e.g., for whole slide imaging of a biopsy.
List<Reference> specimen;

//  The date and time the series was started.
DateTime started;

//  Indicates who or what performed the series and how they were involved.
List<ImagingStudy_Performer> performer;

//  A single SOP instance within the series, e.g. an image, or
// presentation state.
List<ImagingStudy_Instance> instance;

ImagingStudy_Series(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.uid,
    this.number,
    this.modality,
    this.description,
    this.numberOfInstances,
    this.endpoint,
    this.bodySite,
    this.laterality,
    this.specimen,
    this.started,
    this.performer,
    this.instance,
    });

  factory ImagingStudy_Series.fromJson(Map<String, dynamic> json) => _$ImagingStudy_SeriesFromJson(json);
  Map<String, dynamic> toJson() => _$ImagingStudy_SeriesToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImagingStudy_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Distinguishes the type of involvement of the performer in the series.
CodeableConcept function;

//  Indicates who or what performed the series.
Reference actor;

ImagingStudy_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    });

  factory ImagingStudy_Performer.fromJson(Map<String, dynamic> json) => _$ImagingStudy_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$ImagingStudy_PerformerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImagingStudy_Instance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The DICOM SOP Instance UID for this image or other DICOM content.
String uid;

//  DICOM instance  type.
Coding sopClass;

//  The number of instance in the series.
int number;

//  The description of the instance.
String title;

ImagingStudy_Instance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.uid,
    this.sopClass,
    this.number,
    this.title,
    });

  factory ImagingStudy_Instance.fromJson(Map<String, dynamic> json) => _$ImagingStudy_InstanceFromJson(json);
  Map<String, dynamic> toJson() => _$ImagingStudy_InstanceToJson(this);
}

part 'immunization.g.dart';

@JsonSerializable(explicitToJson: true)
class Immunization {

//  This is a Immunization resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this immunization record.
List<Identifier> identifier;

//  Indicates the current status of the immunization event.
String status;

//  Indicates the reason the immunization event was not performed.
CodeableConcept statusReason;

//  Vaccine that was administered or was to be administered.
CodeableConcept vaccineCode;

//  The patient who either received or did not receive the immunization.
Reference patient;

//  The visit or admission or other contact between patient and health
// care provider the immunization was performed as part of.
Reference encounter;

//  Date vaccine administered or was to be administered.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Date vaccine administered or was to be administered.
String occurrenceString; //  pattern: ^[ \r\n\t\S]+$

//  The date the occurrence of the immunization was first captured in the
// record - potentially significantly after the occurrence of the event.
DateTime recorded;

//  An indication that the content of the record is based on information
// from the person who administered the vaccine. This reflects the context
// under which the data was originally recorded.
bool primarySource;

//  The source of the data when the report of the immunization event is
// not based on information from the person who administered the vaccine.
CodeableConcept reportOrigin;

//  The service delivery location where the vaccine administration
// occurred.
Reference location;

//  Name of vaccine manufacturer.
Reference manufacturer;

//  Lot number of the  vaccine product.
String lotNumber;

//  Date vaccine batch expires.
String expirationDate;

//  Body site where vaccine was administered.
CodeableConcept site;

//  The path by which the vaccine product is taken into the body.
CodeableConcept route;

//  The quantity of vaccine product that was administered.
Quantity doseQuantity;

//  Indicates who performed the immunization event.
List<Immunization_Performer> performer;

//  Extra information about the immunization that is not conveyed by the
// other attributes.
List<Annotation> note;

//  Reasons why the vaccine was administered.
List<CodeableConcept> reasonCode;

//  Condition, Observation or DiagnosticReport that supports why the
// immunization was administered.
List<Reference> reasonReference;

//  Indication if a dose is considered to be subpotent. By default, a dose
// should be considered to be potent.
bool isSubpotent;

//  Reason why a dose is considered to be subpotent.
List<CodeableConcept> subpotentReason;

//  Educational material presented to the patient (or guardian) at the
// time of vaccine administration.
List<Immunization_Education> education;

//  Indicates a patient's eligibility for a funding program.
List<CodeableConcept> programEligibility;

//  Indicates the source of the vaccine actually administered. This may be
// different than the patient eligibility (e.g. the patient may be
// eligible for a publically purchased vaccine but due to inventory
// issues, vaccine purchased with private funds was actually
// administered).
CodeableConcept fundingSource;

//  Categorical data indicating that an adverse event is associated in
// time to an immunization.
List<Immunization_Reaction> reaction;

//  The protocol (set of recommendations) being followed by the provider
// who administered the dose.
List<Immunization_ProtocolApplied> protocolApplied;

Immunization(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.statusReason,
    this.vaccineCode,
    this.patient,
    this.encounter,
    this.occurrenceDateTime,
    this.occurrenceString,
    this.recorded,
    this.primarySource,
    this.reportOrigin,
    this.location,
    this.manufacturer,
    this.lotNumber,
    this.expirationDate,
    this.site,
    this.route,
    this.doseQuantity,
    this.performer,
    this.note,
    this.reasonCode,
    this.reasonReference,
    this.isSubpotent,
    this.subpotentReason,
    this.education,
    this.programEligibility,
    this.fundingSource,
    this.reaction,
    this.protocolApplied,
    });

  factory Immunization.fromJson(Map<String, dynamic> json) => _$ImmunizationFromJson(json);
  Map<String, dynamic> toJson() => _$ImmunizationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Immunization_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the type of performance (e.g. ordering provider,
// administering provider, etc.).
CodeableConcept function;

//  The practitioner or organization who performed the action.
Reference actor;

Immunization_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    });

  factory Immunization_Performer.fromJson(Map<String, dynamic> json) => _$Immunization_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$Immunization_PerformerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Immunization_Education {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier of the material presented to the patient.
String documentType;

//  Reference pointer to the educational material given to the patient if
// the information was on line.
String reference;

//  Date the educational material was published.
DateTime publicationDate;

//  Date the educational material was given to the patient.
DateTime presentationDate;

Immunization_Education(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.documentType,
    this.reference,
    this.publicationDate,
    this.presentationDate,
    });

  factory Immunization_Education.fromJson(Map<String, dynamic> json) => _$Immunization_EducationFromJson(json);
  Map<String, dynamic> toJson() => _$Immunization_EducationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Immunization_Reaction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Date of reaction to the immunization.
DateTime date;

//  Details of the reaction.
Reference detail;

//  Self-reported indicator.
bool reported;

Immunization_Reaction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.date,
    this.detail,
    this.reported,
    });

  factory Immunization_Reaction.fromJson(Map<String, dynamic> json) => _$Immunization_ReactionFromJson(json);
  Map<String, dynamic> toJson() => _$Immunization_ReactionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Immunization_ProtocolApplied {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  One possible path to achieve presumed immunity against a disease -
// within the context of an authority.
String series;

//  Indicates the authority who published the protocol (e.g. ACIP) that is
// being followed.
Reference authority;

//  The vaccine preventable disease the dose is being administered
// against.
List<CodeableConcept> targetDisease;

//  Nominal position in a series.
int doseNumberPositiveInt; //  pattern: ^[1-9][0-9]*$

//  Nominal position in a series.
String doseNumberString; //  pattern: ^[ \r\n\t\S]+$

//  The recommended number of doses to achieve immunity.
int seriesDosesPositiveInt; //  pattern: ^[1-9][0-9]*$

//  The recommended number of doses to achieve immunity.
String seriesDosesString; //  pattern: ^[ \r\n\t\S]+$

Immunization_ProtocolApplied(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.series,
    this.authority,
    this.targetDisease,
    this.doseNumberPositiveInt,
    this.doseNumberString,
    this.seriesDosesPositiveInt,
    this.seriesDosesString,
    });

  factory Immunization_ProtocolApplied.fromJson(Map<String, dynamic> json) => _$Immunization_ProtocolAppliedFromJson(json);
  Map<String, dynamic> toJson() => _$Immunization_ProtocolAppliedToJson(this);
}

part 'immunizationEvaluation.g.dart';

@JsonSerializable(explicitToJson: true)
class ImmunizationEvaluation {

//  This is a ImmunizationEvaluation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this immunization evaluation record.
List<Identifier> identifier;

//  Indicates the current status of the evaluation of the vaccination
// administration event.
String status;

//  The individual for whom the evaluation is being done.
Reference patient;

//  The date the evaluation of the vaccine administration event was
// performed.
DateTime date;

//  Indicates the authority who published the protocol (e.g. ACIP).
Reference authority;

//  The vaccine preventable disease the dose is being evaluated against.
CodeableConcept targetDisease;

//  The vaccine administration event being evaluated.
Reference immunizationEvent;

//  Indicates if the dose is valid or not valid with respect to the
// published recommendations.
CodeableConcept doseStatus;

//  Provides an explanation as to why the vaccine administration event is
// valid or not relative to the published recommendations.
List<CodeableConcept> doseStatusReason;

//  Additional information about the evaluation.
String description;

//  One possible path to achieve presumed immunity against a disease -
// within the context of an authority.
String series;

//  Nominal position in a series.
int doseNumberPositiveInt; //  pattern: ^[1-9][0-9]*$

//  Nominal position in a series.
String doseNumberString; //  pattern: ^[ \r\n\t\S]+$

//  The recommended number of doses to achieve immunity.
int seriesDosesPositiveInt; //  pattern: ^[1-9][0-9]*$

//  The recommended number of doses to achieve immunity.
String seriesDosesString; //  pattern: ^[ \r\n\t\S]+$

ImmunizationEvaluation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.patient,
    this.date,
    this.authority,
    this.targetDisease,
    this.immunizationEvent,
    this.doseStatus,
    this.doseStatusReason,
    this.description,
    this.series,
    this.doseNumberPositiveInt,
    this.doseNumberString,
    this.seriesDosesPositiveInt,
    this.seriesDosesString,
    });

  factory ImmunizationEvaluation.fromJson(Map<String, dynamic> json) => _$ImmunizationEvaluationFromJson(json);
  Map<String, dynamic> toJson() => _$ImmunizationEvaluationToJson(this);
}

part 'immunizationRecommendation.g.dart';

@JsonSerializable(explicitToJson: true)
class ImmunizationRecommendation {

//  This is a ImmunizationRecommendation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this particular recommendation record.
List<Identifier> identifier;

//  The patient the recommendation(s) are for.
Reference patient;

//  The date the immunization recommendation(s) were created.
DateTime date;

//  Indicates the authority who published the protocol (e.g. ACIP).
Reference authority;

//  Vaccine administration recommendations.
List<ImmunizationRecommendation_Recommendation> recommendation;

ImmunizationRecommendation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.patient,
    this.date,
    this.authority,
    this.recommendation,
    });

  factory ImmunizationRecommendation.fromJson(Map<String, dynamic> json) => _$ImmunizationRecommendationFromJson(json);
  Map<String, dynamic> toJson() => _$ImmunizationRecommendationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImmunizationRecommendation_Recommendation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Vaccine(s) or vaccine group that pertain to the recommendation.
List<CodeableConcept> vaccineCode;

//  The targeted disease for the recommendation.
CodeableConcept targetDisease;

//  Vaccine(s) which should not be used to fulfill the recommendation.
List<CodeableConcept> contraindicatedVaccineCode;

//  Indicates the patient status with respect to the path to immunity for
// the target disease.
CodeableConcept forecastStatus;

//  The reason for the assigned forecast status.
List<CodeableConcept> forecastReason;

//  Vaccine date recommendations.  For example, earliest date to
// administer, latest date to administer, etc.
List<ImmunizationRecommendation_DateCriterion> dateCriterion;

//  Contains the description about the protocol under which the vaccine
// was administered.
String description;

//  One possible path to achieve presumed immunity against a disease -
// within the context of an authority.
String series;

//  Nominal position of the recommended dose in a series (e.g. dose 2 is
// the next recommended dose).
int doseNumberPositiveInt; //  pattern: ^[1-9][0-9]*$

//  Nominal position of the recommended dose in a series (e.g. dose 2 is
// the next recommended dose).
String doseNumberString; //  pattern: ^[ \r\n\t\S]+$

//  The recommended number of doses to achieve immunity.
int seriesDosesPositiveInt; //  pattern: ^[1-9][0-9]*$

//  The recommended number of doses to achieve immunity.
String seriesDosesString; //  pattern: ^[ \r\n\t\S]+$

//  Immunization event history and/or evaluation that supports the status
// and recommendation.
List<Reference> supportingImmunization;

//  Patient Information that supports the status and recommendation.  This
// includes patient observations, adverse reactions and
// allergy/intolerance information.
List<Reference> supportingPatientInformation;

ImmunizationRecommendation_Recommendation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.vaccineCode,
    this.targetDisease,
    this.contraindicatedVaccineCode,
    this.forecastStatus,
    this.forecastReason,
    this.dateCriterion,
    this.description,
    this.series,
    this.doseNumberPositiveInt,
    this.doseNumberString,
    this.seriesDosesPositiveInt,
    this.seriesDosesString,
    this.supportingImmunization,
    this.supportingPatientInformation,
    });

  factory ImmunizationRecommendation_Recommendation.fromJson(Map<String, dynamic> json) => _$ImmunizationRecommendation_RecommendationFromJson(json);
  Map<String, dynamic> toJson() => _$ImmunizationRecommendation_RecommendationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImmunizationRecommendation_DateCriterion {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Date classification of recommendation.  For example, earliest date to
// give, latest date to give, etc.
CodeableConcept code;

//  The date whose meaning is specified by dateCriterion.code.
DateTime value;

ImmunizationRecommendation_DateCriterion(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.value,
    });

  factory ImmunizationRecommendation_DateCriterion.fromJson(Map<String, dynamic> json) => _$ImmunizationRecommendation_DateCriterionFromJson(json);
  Map<String, dynamic> toJson() => _$ImmunizationRecommendation_DateCriterionToJson(this);
}

part 'implementationGuide.g.dart';

@JsonSerializable(explicitToJson: true)
class ImplementationGuide {

//  This is a ImplementationGuide resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this implementation guide
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this implementation guide is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the implementation guide is stored on different servers.
String url;

//  The identifier that is used to identify this version of the
// implementation guide when it is referenced in a specification, model,
// design or instance. This is an arbitrary value managed by the
// implementation guide author and is not expected to be globally unique.
// For example, it might be a timestamp (e.g. yyyymmdd) if a managed
// version is not available. There is also no expectation that versions
// can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the implementation guide. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the implementation
// guide.
String title;

//  The status of this implementation guide. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this implementation guide is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the implementation guide was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the implementation guide
// changes.
DateTime date;

//  The name of the organization or individual that published the
// implementation guide.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the implementation guide
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate implementation guide instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the implementation guide is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the implementation guide and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the implementation guide.
String copyright;

//  The NPM package name for this Implementation Guide, used in the NPM
// package distribution, which is the primary mechanism by which FHIR
// based tooling manages IG dependencies. This value must be globally
// unique, and should be assigned with care.
String packageId;

//  The license that applies to this Implementation Guide, using an SPDX
// license code, or 'not-open-source'.
String license; // <code> enum: not-open-source/0BSD/AAL/Abstyles/Adobe-2006/Adobe-Glyph/ADSL/AFL-1.1/AFL-1.2/AFL-2.0/AFL-2.1/AFL-3.0/Afmparse/AGPL-1.0-only/AGPL-1.0-or-later/AGPL-3.0-only/AGPL-3.0-or-later/Aladdin/AMDPLPA/AML/AMPAS/ANTLR-PD/Apache-1.0/Apache-1.1/Apache-2.0/APAFML/APL-1.0/APSL-1.0/APSL-1.1/APSL-1.2/APSL-2.0/Artistic-1.0-cl8/Artistic-1.0-Perl/Artistic-1.0/Artistic-2.0/Bahyph/Barr/Beerware/BitTorrent-1.0/BitTorrent-1.1/Borceux/BSD-1-Clause/BSD-2-Clause-FreeBSD/BSD-2-Clause-NetBSD/BSD-2-Clause-Patent/BSD-2-Clause/BSD-3-Clause-Attribution/BSD-3-Clause-Clear/BSD-3-Clause-LBNL/BSD-3-Clause-No-Nuclear-License-2014/BSD-3-Clause-No-Nuclear-License/BSD-3-Clause-No-Nuclear-Warranty/BSD-3-Clause/BSD-4-Clause-UC/BSD-4-Clause/BSD-Protection/BSD-Source-Code/BSL-1.0/bzip2-1.0.5/bzip2-1.0.6/Caldera/CATOSL-1.1/CC-BY-1.0/CC-BY-2.0/CC-BY-2.5/CC-BY-3.0/CC-BY-4.0/CC-BY-NC-1.0/CC-BY-NC-2.0/CC-BY-NC-2.5/CC-BY-NC-3.0/CC-BY-NC-4.0/CC-BY-NC-ND-1.0/CC-BY-NC-ND-2.0/CC-BY-NC-ND-2.5/CC-BY-NC-ND-3.0/CC-BY-NC-ND-4.0/CC-BY-NC-SA-1.0/CC-BY-NC-SA-2.0/CC-BY-NC-SA-2.5/CC-BY-NC-SA-3.0/CC-BY-NC-SA-4.0/CC-BY-ND-1.0/CC-BY-ND-2.0/CC-BY-ND-2.5/CC-BY-ND-3.0/CC-BY-ND-4.0/CC-BY-SA-1.0/CC-BY-SA-2.0/CC-BY-SA-2.5/CC-BY-SA-3.0/CC-BY-SA-4.0/CC0-1.0/CDDL-1.0/CDDL-1.1/CDLA-Permissive-1.0/CDLA-Sharing-1.0/CECILL-1.0/CECILL-1.1/CECILL-2.0/CECILL-2.1/CECILL-B/CECILL-C/ClArtistic/CNRI-Jython/CNRI-Python-GPL-Compatible/CNRI-Python/Condor-1.1/CPAL-1.0/CPL-1.0/CPOL-1.02/Crossword/CrystalStacker/CUA-OPL-1.0/Cube/curl/D-FSL-1.0/diffmark/DOC/Dotseqn/DSDP/dvipdfm/ECL-1.0/ECL-2.0/EFL-1.0/EFL-2.0/eGenix/Entessa/EPL-1.0/EPL-2.0/ErlPL-1.1/EUDatagrid/EUPL-1.0/EUPL-1.1/EUPL-1.2/Eurosym/Fair/Frameworx-1.0/FreeImage/FSFAP/FSFUL/FSFULLR/FTL/GFDL-1.1-only/GFDL-1.1-or-later/GFDL-1.2-only/GFDL-1.2-or-later/GFDL-1.3-only/GFDL-1.3-or-later/Giftware/GL2PS/Glide/Glulxe/gnuplot/GPL-1.0-only/GPL-1.0-or-later/GPL-2.0-only/GPL-2.0-or-later/GPL-3.0-only/GPL-3.0-or-later/gSOAP-1.3b/HaskellReport/HPND/IBM-pibs/ICU/IJG/ImageMagick/iMatix/Imlib2/Info-ZIP/Intel-ACPI/Intel/Interbase-1.0/IPA/IPL-1.0/ISC/JasPer-2.0/JSON/LAL-1.2/LAL-1.3/Latex2e/Leptonica/LGPL-2.0-only/LGPL-2.0-or-later/LGPL-2.1-only/LGPL-2.1-or-later/LGPL-3.0-only/LGPL-3.0-or-later/LGPLLR/Libpng/libtiff/LiLiQ-P-1.1/LiLiQ-R-1.1/LiLiQ-Rplus-1.1/Linux-OpenIB/LPL-1.0/LPL-1.02/LPPL-1.0/LPPL-1.1/LPPL-1.2/LPPL-1.3a/LPPL-1.3c/MakeIndex/MirOS/MIT-0/MIT-advertising/MIT-CMU/MIT-enna/MIT-feh/MIT/MITNFA/Motosoto/mpich2/MPL-1.0/MPL-1.1/MPL-2.0-no-copyleft-exception/MPL-2.0/MS-PL/MS-RL/MTLL/Multics/Mup/NASA-1.3/Naumen/NBPL-1.0/NCSA/Net-SNMP/NetCDF/Newsletr/NGPL/NLOD-1.0/NLPL/Nokia/NOSL/Noweb/NPL-1.0/NPL-1.1/NPOSL-3.0/NRL/NTP/OCCT-PL/OCLC-2.0/ODbL-1.0/OFL-1.0/OFL-1.1/OGTSL/OLDAP-1.1/OLDAP-1.2/OLDAP-1.3/OLDAP-1.4/OLDAP-2.0.1/OLDAP-2.0/OLDAP-2.1/OLDAP-2.2.1/OLDAP-2.2.2/OLDAP-2.2/OLDAP-2.3/OLDAP-2.4/OLDAP-2.5/OLDAP-2.6/OLDAP-2.7/OLDAP-2.8/OML/OpenSSL/OPL-1.0/OSET-PL-2.1/OSL-1.0/OSL-1.1/OSL-2.0/OSL-2.1/OSL-3.0/PDDL-1.0/PHP-3.0/PHP-3.01/Plexus/PostgreSQL/psfrag/psutils/Python-2.0/Qhull/QPL-1.0/Rdisc/RHeCos-1.1/RPL-1.1/RPL-1.5/RPSL-1.0/RSA-MD/RSCPL/Ruby/SAX-PD/Saxpath/SCEA/Sendmail/SGI-B-1.0/SGI-B-1.1/SGI-B-2.0/SimPL-2.0/SISSL-1.2/SISSL/Sleepycat/SMLNJ/SMPPL/SNIA/Spencer-86/Spencer-94/Spencer-99/SPL-1.0/SugarCRM-1.1.3/SWL/TCL/TCP-wrappers/TMate/TORQUE-1.1/TOSL/Unicode-DFS-2015/Unicode-DFS-2016/Unicode-TOU/Unlicense/UPL-1.0/Vim/VOSTROM/VSL-1.0/W3C-19980720/W3C-20150513/W3C/Watcom-1.0/Wsuipa/WTFPL/X11/Xerox/XFree86-1.1/xinetd/Xnet/xpp/XSkat/YPL-1.0/YPL-1.1/Zed/Zend-2.0/Zimbra-1.3/Zimbra-1.4/zlib-acknowledgement/Zlib/ZPL-1.1/ZPL-2.0/ZPL-2.1;

//  The version(s) of the FHIR specification that this ImplementationGuide
// targets - e.g. describes how to use. The value of this element is the
// formal version of the specification, without the revision number, e.g.
// [publication].[major].[minor], which is 4.0.1. for this version.
List<String> fhirVersion; // <code> enum: 0.01/0.05/0.06/0.11/0.0.80/0.0.81/0.0.82/0.4.0/0.5.0/1.0.0/1.0.1/1.0.2/1.1.0/1.4.0/1.6.0/1.8.0/3.0.0/3.0.1/3.3.0/3.5.0/4.0.0/4.0.1> fhirVersion;

//  Another implementation guide that this implementation depends on.
// Typically, an implementation guide uses value sets, profiles
// etc.defined in other implementation guides.
List<ImplementationGuide_DependsOn> dependsOn;

//  A set of profiles that all resources covered by this implementation
// guide must conform to.
List<ImplementationGuide_Global> global;

//  The information needed by an IG publisher tool to publish the whole
// implementation guide.
ImplementationGuide_Definition definition;

//  Information about an assembled implementation guide, created by the
// publication tooling.
ImplementationGuide_Manifest manifest;

ImplementationGuide(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.packageId,
    this.license,
    this.fhirVersion,
    this.dependsOn,
    this.global,
    this.definition,
    this.manifest,
    });

  factory ImplementationGuide.fromJson(Map<String, dynamic> json) => _$ImplementationGuideFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuideToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_DependsOn {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A canonical reference to the Implementation guide for the dependency.
String uri;

//  The NPM package name for the Implementation Guide that this IG depends
// on.
String packageId;

//  The version of the IG that is depended on, when the correct version is
// required to understand the IG correctly.
String version;

ImplementationGuide_DependsOn(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.uri,
    this.packageId,
    this.version,
    });

  factory ImplementationGuide_DependsOn.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_DependsOnFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_DependsOnToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Global {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of resource that all instances must conform to.
String type;

//  A reference to the profile that all instances must conform to.
String profile;

ImplementationGuide_Global(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.profile,
    });

  factory ImplementationGuide_Global.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_GlobalFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_GlobalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Definition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A logical group of resources. Logical groups can be used when building
// pages.
List<ImplementationGuide_Grouping> grouping;

//  A resource that is part of the implementation guide. Conformance
// resources (value set, structure definition, capability statements etc.)
// are obvious candidates for inclusion, but any kind of resource can be
// included as an example resource.
List<ImplementationGuide_Resource> resource;

//  A page / section in the implementation guide. The root page is the
// implementation guide home page.
ImplementationGuide_Page page;

//  Defines how IG is built by tools.
List<ImplementationGuide_Parameter> parameter;

//  A template for building resources.
List<ImplementationGuide_Template> template;

ImplementationGuide_Definition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.grouping,
    this.resource,
    this.page,
    this.parameter,
    this.template,
    });

  factory ImplementationGuide_Definition.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_DefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_DefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Grouping {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The human-readable title to display for the package of resources when
// rendering the implementation guide.
String name;

//  Human readable text describing the package.
String description;

ImplementationGuide_Grouping(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.description,
    });

  factory ImplementationGuide_Grouping.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_GroupingFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_GroupingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Resource {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Where this resource is found.
Reference reference;

//  Indicates the FHIR Version(s) this artifact is intended to apply to.
// If no versions are specified, the resource is assumed to apply to all
// the versions stated in ImplementationGuide.fhirVersion.
List<String> fhirVersion; // <code> enum: 0.01/0.05/0.06/0.11/0.0.80/0.0.81/0.0.82/0.4.0/0.5.0/1.0.0/1.0.1/1.0.2/1.1.0/1.4.0/1.6.0/1.8.0/3.0.0/3.0.1/3.3.0/3.5.0/4.0.0/4.0.1> fhirVersion;

//  A human assigned name for the resource. All resources SHOULD have a
// name, but the name may be extracted from the resource (e.g.
// ValueSet.name).
String name;

//  A description of the reason that a resource has been included in the
// implementation guide.
String description;

//  If true or a reference, indicates the resource is an example instance.
//  If a reference is present, indicates that the example is an example of
// the specified profile.
bool exampleBoolean; //  pattern: ^true|false$

//  If true or a reference, indicates the resource is an example instance.
//  If a reference is present, indicates that the example is an example of
// the specified profile.
String exampleCanonical; //  pattern: ^\S*$

//  Reference to the id of the grouping this resource appears in.
String groupingId;

ImplementationGuide_Resource(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.reference,
    this.fhirVersion,
    this.name,
    this.description,
    this.exampleBoolean,
    this.exampleCanonical,
    this.groupingId,
    });

  factory ImplementationGuide_Resource.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_ResourceFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_ResourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Page {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The source address for the page.
String nameUrl; //  pattern: ^\S*$

//  The source address for the page.
Reference nameReference;

//  A short title used to represent this page in navigational structures
// such as table of contents, bread crumbs, etc.
String title;

//  A code that indicates how the page is generated.
String generation; // <code> enum: html/markdown/xml/generated;

//  Nested Pages/Sections under this page.
List<ImplementationGuide_Page> page;

ImplementationGuide_Page(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.nameUrl,
    this.nameReference,
    this.title,
    this.generation,
    this.page,
    });

  factory ImplementationGuide_Page.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_PageFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_PageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  apply | path-resource | path-pages | path-tx-cache |
// expansion-parameter | rule-broken-links | generate-xml | generate-json
// | generate-turtle | html-template.
String code; // <code> enum: apply/path-resource/path-pages/path-tx-cache/expansion-parameter/rule-broken-links/generate-xml/generate-json/generate-turtle/html-template;

//  Value for named type.
String value;

ImplementationGuide_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.value,
    });

  factory ImplementationGuide_Parameter.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_ParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Template {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of template specified.
String code;

//  The source location for the template.
String source;

//  The scope in which the template applies.
String scope;

ImplementationGuide_Template(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.source,
    this.scope,
    });

  factory ImplementationGuide_Template.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_TemplateFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_TemplateToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Manifest {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A pointer to official web page, PDF or other rendering of the
// implementation guide.
String rendering;

//  A resource that is part of the implementation guide. Conformance
// resources (value set, structure definition, capability statements etc.)
// are obvious candidates for inclusion, but any kind of resource can be
// included as an example resource.
List<ImplementationGuide_Resource1> resource;

//  Information about a page within the IG.
List<ImplementationGuide_Page1> page;

//  Indicates a relative path to an image that exists within the IG.
List<String> image;

//  Indicates the relative path of an additional non-page, non-image file
// that is part of the IG - e.g. zip, jar and similar files that could be
// the target of a hyperlink in a derived IG.
List<String> other;

ImplementationGuide_Manifest(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.rendering,
    this.resource,
    this.page,
    this.image,
    this.other,
    });

  factory ImplementationGuide_Manifest.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_ManifestFromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_ManifestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Resource1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Where this resource is found.
Reference reference;

//  If true or a reference, indicates the resource is an example instance.
//  If a reference is present, indicates that the example is an example of
// the specified profile.
bool exampleBoolean; //  pattern: ^true|false$

//  If true or a reference, indicates the resource is an example instance.
//  If a reference is present, indicates that the example is an example of
// the specified profile.
String exampleCanonical; //  pattern: ^\S*$

//  The relative path for primary page for this resource within the IG.
String relativePath;

ImplementationGuide_Resource1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.reference,
    this.exampleBoolean,
    this.exampleCanonical,
    this.relativePath,
    });

  factory ImplementationGuide_Resource1.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_Resource1FromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_Resource1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ImplementationGuide_Page1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Relative path to the page.
String name;

//  Label for the page intended for human display.
String title;

//  The name of an anchor available on the page.
List<String> anchor;

ImplementationGuide_Page1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.title,
    this.anchor,
    });

  factory ImplementationGuide_Page1.fromJson(Map<String, dynamic> json) => _$ImplementationGuide_Page1FromJson(json);
  Map<String, dynamic> toJson() => _$ImplementationGuide_Page1ToJson(this);
}

part 'insurancePlan.g.dart';

@JsonSerializable(explicitToJson: true)
class InsurancePlan {

//  This is a InsurancePlan resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this health insurance product which
// remain constant as the resource is updated and propagates from server
// to server.
List<Identifier> identifier;

//  The current state of the health insurance product.
String status; // <code> enum: draft/active/retired/unknown;

//  The kind of health insurance product.
List<CodeableConcept> type;

//  Official name of the health insurance product as designated by the
// owner.
String name;

//  A list of alternate names that the product is known as, or was known
// as in the past.
List<String> alias;

//  The period of time that the health insurance product is available.
Period period;

//  The entity that is providing  the health insurance product and
// underwriting the risk.  This is typically an insurance carriers, other
// third-party payers, or health plan sponsors comonly referred to as
// 'payers'.
Reference ownedBy;

//  An organization which administer other services such as underwriting,
// customer service and/or claims processing on behalf of the health
// insurance product owner.
Reference administeredBy;

//  The geographic region in which a health insurance product's benefits
// apply.
List<Reference> coverageArea;

//  The contact for the health insurance product for a certain purpose.
List<InsurancePlan_Contact> contact;

//  The technical endpoints providing access to services operated for the
// health insurance product.
List<Reference> endpoint;

//  Reference to the network included in the health insurance product.
List<Reference> network;

//  Details about the coverage offered by the insurance product.
List<InsurancePlan_Coverage> coverage;

//  Details about an insurance plan.
List<InsurancePlan_Plan> plan;

InsurancePlan(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.name,
    this.alias,
    this.period,
    this.ownedBy,
    this.administeredBy,
    this.coverageArea,
    this.contact,
    this.endpoint,
    this.network,
    this.coverage,
    this.plan,
    });

  factory InsurancePlan.fromJson(Map<String, dynamic> json) => _$InsurancePlanFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlanToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Contact {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a purpose for which the contact can be reached.
CodeableConcept purpose;

//  A name associated with the contact.
HumanName name;

//  A contact detail (e.g. a telephone number or an email address) by
// which the party may be contacted.
List<ContactPoint> telecom;

//  Visiting or postal addresses for the contact.
Address address;

InsurancePlan_Contact(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.purpose,
    this.name,
    this.telecom,
    this.address,
    });

  factory InsurancePlan_Contact.fromJson(Map<String, dynamic> json) => _$InsurancePlan_ContactFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_ContactToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Coverage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of coverage  (Medical; Dental; Mental Health; Substance Abuse;
// Vision; Drug; Short Term; Long Term Care; Hospice; Home Health).
CodeableConcept type;

//  Reference to the network that providing the type of coverage.
List<Reference> network;

//  Specific benefits under this type of coverage.
List<InsurancePlan_Benefit> benefit;

InsurancePlan_Coverage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.network,
    this.benefit,
    });

  factory InsurancePlan_Coverage.fromJson(Map<String, dynamic> json) => _$InsurancePlan_CoverageFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_CoverageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Benefit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of benefit (primary care; speciality care; inpatient;
// outpatient).
CodeableConcept type;

//  The referral requirements to have access/coverage for this benefit.
String requirement;

//  The specific limits on the benefit.
List<InsurancePlan_Limit> limit;

InsurancePlan_Benefit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.requirement,
    this.limit,
    });

  factory InsurancePlan_Benefit.fromJson(Map<String, dynamic> json) => _$InsurancePlan_BenefitFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_BenefitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Limit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The maximum amount of a service item a plan will pay for a covered
// benefit.  For examples. wellness visits, or eyeglasses.
Quantity value;

//  The specific limit on the benefit.
CodeableConcept code;

InsurancePlan_Limit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.value,
    this.code,
    });

  factory InsurancePlan_Limit.fromJson(Map<String, dynamic> json) => _$InsurancePlan_LimitFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_LimitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Plan {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this health insurance plan which
// remain constant as the resource is updated and propagates from server
// to server.
List<Identifier> identifier;

//  Type of plan. For example, "Platinum" or "High Deductable".
CodeableConcept type;

//  The geographic region in which a health insurance plan's benefits
// apply.
List<Reference> coverageArea;

//  Reference to the network that providing the type of coverage.
List<Reference> network;

//  Overall costs associated with the plan.
List<InsurancePlan_GeneralCost> generalCost;

//  Costs associated with the coverage provided by the product.
List<InsurancePlan_SpecificCost> specificCost;

InsurancePlan_Plan(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.coverageArea,
    this.network,
    this.generalCost,
    this.specificCost,
    });

  factory InsurancePlan_Plan.fromJson(Map<String, dynamic> json) => _$InsurancePlan_PlanFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_PlanToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_GeneralCost {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of cost.
CodeableConcept type;

//  Number of participants enrolled in the plan.
int groupSize;

//  Value of the cost.
Money cost;

//  Additional information about the general costs associated with this
// plan.
String comment;

InsurancePlan_GeneralCost(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.groupSize,
    this.cost,
    this.comment,
    });

  factory InsurancePlan_GeneralCost.fromJson(Map<String, dynamic> json) => _$InsurancePlan_GeneralCostFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_GeneralCostToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_SpecificCost {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  General category of benefit (Medical; Dental; Vision; Drug; Mental
// Health; Substance Abuse; Hospice, Home Health).
CodeableConcept category;

//  List of the specific benefits under this category of benefit.
List<InsurancePlan_Benefit1> benefit;

InsurancePlan_SpecificCost(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.benefit,
    });

  factory InsurancePlan_SpecificCost.fromJson(Map<String, dynamic> json) => _$InsurancePlan_SpecificCostFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_SpecificCostToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Benefit1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of specific benefit (preventative; primary care office visit;
// speciality office visit; hospitalization; emergency room; urgent care).
CodeableConcept type;

//  List of the costs associated with a specific benefit.
List<InsurancePlan_Cost> cost;

InsurancePlan_Benefit1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.cost,
    });

  factory InsurancePlan_Benefit1.fromJson(Map<String, dynamic> json) => _$InsurancePlan_Benefit1FromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_Benefit1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class InsurancePlan_Cost {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of cost (copay; individual cap; family cap; coinsurance;
// deductible).
CodeableConcept type;

//  Whether the cost applies to in-network or out-of-network providers
// (in-network; out-of-network; other).
CodeableConcept applicability;

//  Additional information about the cost, such as information about
// funding sources (e.g. HSA, HRA, FSA, RRA).
List<CodeableConcept> qualifiers;

//  The actual cost value. (some of the costs may be represented as
// percentages rather than currency, e.g. 10% coinsurance).
Quantity value;

InsurancePlan_Cost(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.applicability,
    this.qualifiers,
    this.value,
    });

  factory InsurancePlan_Cost.fromJson(Map<String, dynamic> json) => _$InsurancePlan_CostFromJson(json);
  Map<String, dynamic> toJson() => _$InsurancePlan_CostToJson(this);
}

part 'invoice.g.dart';

@JsonSerializable(explicitToJson: true)
class Invoice {

//  This is a Invoice resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier of this Invoice, often used for reference in correspondence
// about this invoice or for tracking of payments.
List<Identifier> identifier;

//  The current state of the Invoice.
String status; // <code> enum: draft/issued/balanced/cancelled/entered-in-error;

//  In case of Invoice cancellation a reason must be given (entered in
// error, superseded by corrected invoice etc.).
String cancelledReason;

//  Type of Invoice depending on domain, realm an usage (e.g.
// internal/external, dental, preliminary).
CodeableConcept type;

//  The individual or set of individuals receiving the goods and services
// billed in this invoice.
Reference subject;

//  The individual or Organization responsible for balancing of this
// invoice.
Reference recipient;

//  Date/time(s) of when this Invoice was posted.
DateTime date;

//  Indicates who or what performed or participated in the charged
// service.
List<Invoice_Participant> participant;

//  The organizationissuing the Invoice.
Reference issuer;

//  Account which is supposed to be balanced with this Invoice.
Reference account;

//  Each line item represents one charge for goods and services rendered.
// Details such as date, code and amount are found in the referenced
// ChargeItem resource.
List<Invoice_LineItem> lineItem;

//  The total amount for the Invoice may be calculated as the sum of the
// line items with surcharges/deductions that apply in certain conditions.
//  The priceComponent element can be used to offer transparency to the
// recipient of the Invoice of how the total price was calculated.
List<Invoice_PriceComponent> totalPriceComponent;

//  Invoice total , taxes excluded.
Money totalNet;

//  Invoice total, tax included.
Money totalGross;

//  Payment details such as banking details, period of payment,
// deductibles, methods of payment.
String paymentTerms;

//  Comments made about the invoice by the issuer, subject, or other
// participants.
List<Annotation> note;

Invoice(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.cancelledReason,
    this.type,
    this.subject,
    this.recipient,
    this.date,
    this.participant,
    this.issuer,
    this.account,
    this.lineItem,
    this.totalPriceComponent,
    this.totalNet,
    this.totalGross,
    this.paymentTerms,
    this.note,
    });

  factory Invoice.fromJson(Map<String, dynamic> json) => _$InvoiceFromJson(json);
  Map<String, dynamic> toJson() => _$InvoiceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Invoice_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes the type of involvement (e.g. transcriptionist, creator
// etc.). If the invoice has been created automatically, the Participant
// may be a billing engine or another kind of device.
CodeableConcept role;

//  The device, practitioner, etc. who performed or participated in the
// service.
Reference actor;

Invoice_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.role,
    this.actor,
    });

  factory Invoice_Participant.fromJson(Map<String, dynamic> json) => _$Invoice_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$Invoice_ParticipantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Invoice_LineItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Sequence in which the items appear on the invoice.
int sequence;

//  The ChargeItem contains information such as the billing code, date,
// amount etc. If no further details are required for the lineItem, inline
// billing codes can be added using the CodeableConcept data type instead
// of the Reference.
Reference chargeItemReference;

//  The ChargeItem contains information such as the billing code, date,
// amount etc. If no further details are required for the lineItem, inline
// billing codes can be added using the CodeableConcept data type instead
// of the Reference.
CodeableConcept chargeItemCodeableConcept;

//  The price for a ChargeItem may be calculated as a base price with
// surcharges/deductions that apply in certain conditions. A
// ChargeItemDefinition resource that defines the prices, factors and
// conditions that apply to a billing code is currently under development.
// The priceComponent element can be used to offer transparency to the
// recipient of the Invoice as to how the prices have been calculated.
List<Invoice_PriceComponent> priceComponent;

Invoice_LineItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.sequence,
    this.chargeItemReference,
    this.chargeItemCodeableConcept,
    this.priceComponent,
    });

  factory Invoice_LineItem.fromJson(Map<String, dynamic> json) => _$Invoice_LineItemFromJson(json);
  Map<String, dynamic> toJson() => _$Invoice_LineItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Invoice_PriceComponent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  This code identifies the type of the component.
String type; // <code> enum: base/surcharge/deduction/discount/tax/informational;

//  A code that identifies the component. Codes may be used to
// differentiate between kinds of taxes, surcharges, discounts etc.
CodeableConcept code;

//  The factor that has been applied on the base price for calculating
// this component.
double factor;

//  The amount calculated for this component.
Money amount;

Invoice_PriceComponent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.code,
    this.factor,
    this.amount,
    });

  factory Invoice_PriceComponent.fromJson(Map<String, dynamic> json) => _$Invoice_PriceComponentFromJson(json);
  Map<String, dynamic> toJson() => _$Invoice_PriceComponentToJson(this);
}

part 'library.g.dart';

@JsonSerializable(explicitToJson: true)
class Library {

//  This is a Library resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this library when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this library is (or will be) published. This URL can be the target
// of a canonical reference. It SHALL remain the same when the library is
// stored on different servers.
String url;

//  A formal identifier that is used to identify this library when it is
// represented in other formats, or referenced in a specification, model,
// design or an instance. e.g. CMS or NQF identifiers for a measure
// artifact. Note that at least one identifier is required for
// non-experimental active artifacts.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the library
// when it is referenced in a specification, model, design or instance.
// This is an arbitrary value managed by the library author and is not
// expected to be globally unique. For example, it might be a timestamp
// (e.g. yyyymmdd) if a managed version is not available. There is also no
// expectation that versions can be placed in a lexicographical sequence.
// To provide a version consistent with the Decision Support Service
// specification, use the format Major.Minor.Revision (e.g. 1.0.0). For
// more information on versioning knowledge assets, refer to the Decision
// Support Service specification. Note that a version is required for
// non-experimental active artifacts.
String version;

//  A natural language name identifying the library. This name should be
// usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the library.
String title;

//  An explanatory or alternate title for the library giving additional
// information about its content.
String subtitle;

//  The status of this library. Enables tracking the life-cycle of the
// content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this library is authored for testing
// purposes (or education/evaluation/marketing) and is not intended to be
// used for genuine usage.
bool experimental;

//  Identifies the type of library such as a Logic Library, Model
// Definition, Asset Collection, or Module Definition.
CodeableConcept type;

//  A code or group definition that describes the intended subject of the
// contents of the library.
CodeableConcept subjectCodeableConcept;

//  A code or group definition that describes the intended subject of the
// contents of the library.
Reference subjectReference;

//  The date  (and optionally time) when the library was published. The
// date must change when the business version changes and it must change
// if the status code changes. In addition, it should change when the
// substantive content of the library changes.
DateTime date;

//  The name of the organization or individual that published the library.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the library from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate library instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the library is intended to be
// used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this library is needed and why it has been designed
// as it has.
String purpose;

//  A detailed description of how the library is used from a clinical
// perspective.
String usage;

//  A copyright statement relating to the library and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the library.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the library content was or is planned to be in
// active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the library. Topics
// provide a high-level categorization of the library that can be useful
// for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  The parameter element defines parameters used by the library.
List<ParameterDefinition> parameter;

//  Describes a set of data that must be provided in order to be able to
// successfully perform the computations defined by the library.
List<DataRequirement> dataRequirement;

//  The content of the library as an Attachment. The content may be a
// reference to a url, or may be directly embedded as a base-64 string.
// Either way, the contentType of the attachment determines how to
// interpret the content.
List<Attachment> content;

Library(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.subtitle,
    this.status,
    this.experimental,
    this.type,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.parameter,
    this.dataRequirement,
    this.content,
    });

  factory Library.fromJson(Map<String, dynamic> json) => _$LibraryFromJson(json);
  Map<String, dynamic> toJson() => _$LibraryToJson(this);
}

part 'linkage.g.dart';

@JsonSerializable(explicitToJson: true)
class Linkage {

//  This is a Linkage resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates whether the asserted set of linkages are considered to be
// "in effect".
bool active;

//  Identifies the user or organization responsible for asserting the
// linkages as well as the user or organization who establishes the
// context in which the nature of each linkage is evaluated.
Reference author;

//  Identifies which record considered as the reference to the same
// real-world occurrence as well as how the items should be evaluated
// within the collection of linked items.
List<Linkage_Item> item;

Linkage(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.active,
    this.author,
    this.item,
    });

  factory Linkage.fromJson(Map<String, dynamic> json) => _$LinkageFromJson(json);
  Map<String, dynamic> toJson() => _$LinkageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Linkage_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Distinguishes which item is "source of truth" (if any) and which items
// are no longer considered to be current representations.
String type; // <code> enum: source/alternate/historical;

//  The resource instance being linked as part of the group.
Reference resource;

Linkage_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.resource,
    });

  factory Linkage_Item.fromJson(Map<String, dynamic> json) => _$Linkage_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$Linkage_ItemToJson(this);
}

part 'list.g.dart';

@JsonSerializable(explicitToJson: true)
class List {

//  This is a List resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the List assigned for business purposes outside the
// context of FHIR.
List<Identifier> identifier;

//  Indicates the current state of this list.
String status; // <code> enum: current/retired/entered-in-error;

//  How this list was prepared - whether it is a working list that is
// suitable for being maintained on an ongoing basis, or if it represents
// a snapshot of a list of items from another source, or whether it is a
// prepared list where items may be marked as added, modified or deleted.
String mode; // <code> enum: working/snapshot/changes;

//  A label for the list assigned by the author.
String title;

//  This code defines the purpose of the list - why it was created.
CodeableConcept code;

//  The common subject (or patient) of the resources that are in the list
// if there is one.
Reference subject;

//  The encounter that is the context in which this list was created.
Reference encounter;

//  The date that the list was prepared.
DateTime date;

//  The entity responsible for deciding what the contents of the list
// were. Where the list was created by a human, this is the same as the
// author of the list.
Reference source;

//  What order applies to the items in the list.
CodeableConcept orderedBy;

//  Comments that apply to the overall list.
List<Annotation> note;

//  Entries in this list.
List<List_Entry> entry;

//  If the list is empty, why the list is empty.
CodeableConcept emptyReason;

List(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.mode,
    this.title,
    this.code,
    this.subject,
    this.encounter,
    this.date,
    this.source,
    this.orderedBy,
    this.note,
    this.entry,
    this.emptyReason,
    });

  factory List.fromJson(Map<String, dynamic> json) => _$ListFromJson(json);
  Map<String, dynamic> toJson() => _$ListToJson(this);
}

@JsonSerializable(explicitToJson: true)
class List_Entry {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The flag allows the system constructing the list to indicate the role
// and significance of the item in the list.
CodeableConcept flag;

//  True if this item is marked as deleted in the list.
bool deleted;

//  When this item was added to the list.
DateTime date;

//  A reference to the actual resource from which data was derived.
Reference item;

List_Entry(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.flag,
    this.deleted,
    this.date,
    this.item,
    });

  factory List_Entry.fromJson(Map<String, dynamic> json) => _$List_EntryFromJson(json);
  Map<String, dynamic> toJson() => _$List_EntryToJson(this);
}

part 'location.g.dart';

@JsonSerializable(explicitToJson: true)
class Location {

//  This is a Location resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique code or number identifying the location to its users.
List<Identifier> identifier;

//  The status property covers the general availability of the resource,
// not the current value which may be covered by the operationStatus, or
// by a schedule/slots if they are configured for the location.
String status; // <code> enum: active/suspended/inactive;

//  The operational status covers operation values most relevant to beds
// (but can also apply to rooms/units/chairs/etc. such as an isolation
// unit/dialysis chair). This typically covers concepts such as
// contamination, housekeeping, and other activities like maintenance.
Coding operationalStatus;

//  Name of the location as used by humans. Does not need to be unique.
String name;

//  A list of alternate names that the location is known as, or was known
// as, in the past.
List<String> alias;

//  Description of the Location, which helps in finding or referencing the
// place.
String description;

//  Indicates whether a resource instance represents a specific location
// or a class of locations.
String mode; // <code> enum: instance/kind;

//  Indicates the type of function performed at the location.
List<CodeableConcept> type;

//  The contact details of communication devices available at the
// location. This can include phone numbers, fax numbers, mobile numbers,
// email addresses and web sites.
List<ContactPoint> telecom;

//  Physical location.
Address address;

//  Physical form of the location, e.g. building, room, vehicle, road.
CodeableConcept physicalType;

//  The absolute geographic location of the Location, expressed using the
// WGS84 datum (This is the same co-ordinate system used in KML).
Location_Position position;

//  The organization responsible for the provisioning and upkeep of the
// location.
Reference managingOrganization;

//  Another Location of which this Location is physically a part of.
Reference partOf;

//  What days/times during a week is this location usually open.
List<Location_HoursOfOperation> hoursOfOperation;

//  A description of when the locations opening ours are different to
// normal, e.g. public holiday availability. Succinctly describing all
// possible exceptions to normal site availability as detailed in the
// opening hours Times.
String availabilityExceptions;

//  Technical endpoints providing access to services operated for the
// location.
List<Reference> endpoint;

Location(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.operationalStatus,
    this.name,
    this.alias,
    this.description,
    this.mode,
    this.type,
    this.telecom,
    this.address,
    this.physicalType,
    this.position,
    this.managingOrganization,
    this.partOf,
    this.hoursOfOperation,
    this.availabilityExceptions,
    this.endpoint,
    });

  factory Location.fromJson(Map<String, dynamic> json) => _$LocationFromJson(json);
  Map<String, dynamic> toJson() => _$LocationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Location_Position {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Longitude. The value domain and the interpretation are the same as for
// the text of the longitude element in KML (see notes below).
double longitude;

//  Latitude. The value domain and the interpretation are the same as for
// the text of the latitude element in KML (see notes below).
double latitude;

//  Altitude. The value domain and the interpretation are the same as for
// the text of the altitude element in KML (see notes below).
double altitude;

Location_Position(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.longitude,
    this.latitude,
    this.altitude,
    });

  factory Location_Position.fromJson(Map<String, dynamic> json) => _$Location_PositionFromJson(json);
  Map<String, dynamic> toJson() => _$Location_PositionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Location_HoursOfOperation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates which days of the week are available between the start and
// end Times.
List<String> daysOfWeek;

//  The Location is open all day.
bool allDay;

//  Time that the Location opens.
String openingTime;

//  Time that the Location closes.
String closingTime;

Location_HoursOfOperation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.daysOfWeek,
    this.allDay,
    this.openingTime,
    this.closingTime,
    });

  factory Location_HoursOfOperation.fromJson(Map<String, dynamic> json) => _$Location_HoursOfOperationFromJson(json);
  Map<String, dynamic> toJson() => _$Location_HoursOfOperationToJson(this);
}

part 'measure.g.dart';

@JsonSerializable(explicitToJson: true)
class Measure {

//  This is a Measure resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this measure when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this measure is (or will be) published. This URL can be the target
// of a canonical reference. It SHALL remain the same when the measure is
// stored on different servers.
String url;

//  A formal identifier that is used to identify this measure when it is
// represented in other formats, or referenced in a specification, model,
// design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the measure
// when it is referenced in a specification, model, design or instance.
// This is an arbitrary value managed by the measure author and is not
// expected to be globally unique. For example, it might be a timestamp
// (e.g. yyyymmdd) if a managed version is not available. There is also no
// expectation that versions can be placed in a lexicographical sequence.
// To provide a version consistent with the Decision Support Service
// specification, use the format Major.Minor.Revision (e.g. 1.0.0). For
// more information on versioning knowledge assets, refer to the Decision
// Support Service specification. Note that a version is required for
// non-experimental active artifacts.
String version;

//  A natural language name identifying the measure. This name should be
// usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the measure.
String title;

//  An explanatory or alternate title for the measure giving additional
// information about its content.
String subtitle;

//  The status of this measure. Enables tracking the life-cycle of the
// content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this measure is authored for testing
// purposes (or education/evaluation/marketing) and is not intended to be
// used for genuine usage.
bool experimental;

//  The intended subjects for the measure. If this element is not
// provided, a Patient subject is assumed, but the subject of the measure
// can be anything.
CodeableConcept subjectCodeableConcept;

//  The intended subjects for the measure. If this element is not
// provided, a Patient subject is assumed, but the subject of the measure
// can be anything.
Reference subjectReference;

//  The date  (and optionally time) when the measure was published. The
// date must change when the business version changes and it must change
// if the status code changes. In addition, it should change when the
// substantive content of the measure changes.
DateTime date;

//  The name of the organization or individual that published the measure.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the measure from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate measure instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the measure is intended to be
// used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this measure is needed and why it has been designed
// as it has.
String purpose;

//  A detailed description, from a clinical perspective, of how the
// measure is used.
String usage;

//  A copyright statement relating to the measure and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the measure.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the measure content was or is planned to be in
// active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the measure. Topics
// provide a high-level categorization grouping types of measures that can
// be useful for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a Library resource containing the formal logic used by
// the measure.
List<String> library;

//  Notices and disclaimers regarding the use of the measure or related to
// intellectual property (such as code systems) referenced by the measure.
String disclaimer;

//  Indicates how the calculation is performed for the measure, including
// proportion, ratio, continuous-variable, and cohort. The value set is
// extensible, allowing additional measure scoring types to be
// represented.
CodeableConcept scoring;

//  If this is a composite measure, the scoring method used to combine the
// component measures to determine the composite score.
CodeableConcept compositeScoring;

//  Indicates whether the measure is used to examine a process, an outcome
// over time, a patient-reported outcome, or a structure measure such as
// utilization.
List<CodeableConcept> type;

//  A description of the risk adjustment factors that may impact the
// resulting score for the measure and how they may be accounted for when
// computing and reporting measure results.
String riskAdjustment;

//  Describes how to combine the information calculated, based on logic in
// each of several populations, into one summarized result.
String rateAggregation;

//  Provides a succinct statement of the need for the measure. Usually
// includes statements pertaining to importance criterion: impact, gap in
// care, and evidence.
String rationale;

//  Provides a summary of relevant clinical guidelines or other clinical
// recommendations supporting the measure.
String clinicalRecommendationStatement;

//  Information on whether an increase or decrease in score is the
// preferred result (e.g., a higher score indicates better quality OR a
// lower score indicates better quality OR quality is within a range).
CodeableConcept improvementNotation;

//  Provides a description of an individual term used within the measure.
List<String> definition;

//  Additional guidance for the measure including how it can be used in a
// clinical context, and the intent of the measure.
String guidance;

//  A group of population criteria for the measure.
List<Measure_Group> group;

//  The supplemental data criteria for the measure report, specified as
// either the name of a valid CQL expression within a referenced library,
// or a valid FHIR Resource Path.
List<Measure_SupplementalData> supplementalData;

Measure(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.subtitle,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.library,
    this.disclaimer,
    this.scoring,
    this.compositeScoring,
    this.type,
    this.riskAdjustment,
    this.rateAggregation,
    this.rationale,
    this.clinicalRecommendationStatement,
    this.improvementNotation,
    this.definition,
    this.guidance,
    this.group,
    this.supplementalData,
    });

  factory Measure.fromJson(Map<String, dynamic> json) => _$MeasureFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Measure_Group {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a meaning for the group. This can be as simple as a unique
// identifier, or it can establish meaning in a broader context by drawing
// from a terminology, allowing groups to be correlated across measures.
CodeableConcept code;

//  The human readable description of this population group.
String description;

//  A population criteria for the measure.
List<Measure_Population> population;

//  The stratifier criteria for the measure report, specified as either
// the name of a valid CQL expression defined within a referenced library
// or a valid FHIR Resource Path.
List<Measure_Stratifier> stratifier;

Measure_Group(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.description,
    this.population,
    this.stratifier,
    });

  factory Measure_Group.fromJson(Map<String, dynamic> json) => _$Measure_GroupFromJson(json);
  Map<String, dynamic> toJson() => _$Measure_GroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Measure_Population {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of population criteria.
CodeableConcept code;

//  The human readable description of this population criteria.
String description;

//  An expression that specifies the criteria for the population,
// typically the name of an expression in a library.
Expression criteria;

Measure_Population(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.description,
    this.criteria,
    });

  factory Measure_Population.fromJson(Map<String, dynamic> json) => _$Measure_PopulationFromJson(json);
  Map<String, dynamic> toJson() => _$Measure_PopulationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Measure_Stratifier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a meaning for the stratifier. This can be as simple as a
// unique identifier, or it can establish meaning in a broader context by
// drawing from a terminology, allowing stratifiers to be correlated
// across measures.
CodeableConcept code;

//  The human readable description of this stratifier criteria.
String description;

//  An expression that specifies the criteria for the stratifier. This is
// typically the name of an expression defined within a referenced
// library, but it may also be a path to a stratifier element.
Expression criteria;

//  A component of the stratifier criteria for the measure report,
// specified as either the name of a valid CQL expression defined within a
// referenced library or a valid FHIR Resource Path.
List<Measure_Component> component;

Measure_Stratifier(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.description,
    this.criteria,
    this.component,
    });

  factory Measure_Stratifier.fromJson(Map<String, dynamic> json) => _$Measure_StratifierFromJson(json);
  Map<String, dynamic> toJson() => _$Measure_StratifierToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Measure_Component {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a meaning for the stratifier component. This can be as
// simple as a unique identifier, or it can establish meaning in a broader
// context by drawing from a terminology, allowing stratifiers to be
// correlated across measures.
CodeableConcept code;

//  The human readable description of this stratifier criteria component.
String description;

//  An expression that specifies the criteria for this component of the
// stratifier. This is typically the name of an expression defined within
// a referenced library, but it may also be a path to a stratifier
// element.
Expression criteria;

Measure_Component(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.description,
    this.criteria,
    });

  factory Measure_Component.fromJson(Map<String, dynamic> json) => _$Measure_ComponentFromJson(json);
  Map<String, dynamic> toJson() => _$Measure_ComponentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Measure_SupplementalData {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a meaning for the supplemental data. This can be as simple
// as a unique identifier, or it can establish meaning in a broader
// context by drawing from a terminology, allowing supplemental data to be
// correlated across measures.
CodeableConcept code;

//  An indicator of the intended usage for the supplemental data element.
// Supplemental data indicates the data is additional information
// requested to augment the measure information. Risk adjustment factor
// indicates the data is additional information used to calculate risk
// adjustment factors when applying a risk model to the measure
// calculation.
List<CodeableConcept> usage;

//  The human readable description of this supplemental data.
String description;

//  The criteria for the supplemental data. This is typically the name of
// a valid expression defined within a referenced library, but it may also
// be a path to a specific data element. The criteria defines the data to
// be returned for this element.
Expression criteria;

Measure_SupplementalData(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.usage,
    this.description,
    this.criteria,
    });

  factory Measure_SupplementalData.fromJson(Map<String, dynamic> json) => _$Measure_SupplementalDataFromJson(json);
  Map<String, dynamic> toJson() => _$Measure_SupplementalDataToJson(this);
}

part 'measureReport.g.dart';

@JsonSerializable(explicitToJson: true)
class MeasureReport {

//  This is a MeasureReport resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A formal identifier that is used to identify this MeasureReport when
// it is represented in other formats or referenced in a specification,
// model, design or an instance.
List<Identifier> identifier;

//  The MeasureReport status. No data will be available until the
// MeasureReport status is complete.
String status; // <code> enum: complete/pending/error;

//  The type of measure report. This may be an individual report, which
// provides the score for the measure for an individual member of the
// population; a subject-listing, which returns the list of members that
// meet the various criteria in the measure; a summary report, which
// returns a population count for each of the criteria in the measure; or
// a data-collection, which enables the MeasureReport to be used to
// exchange the data-of-interest for a quality measure.
String type; // <code> enum: individual/subject-list/summary/data-collection;

//  A reference to the Measure that was calculated to produce this report.
String measure;

//  Optional subject identifying the individual or individuals the report
// is for.
Reference subject;

//  The date this measure report was generated.
DateTime date;

//  The individual, location, or organization that is reporting the data.
Reference reporter;

//  The reporting period for which the report was calculated.
Period period;

//  Whether improvement in the measure is noted by an increase or decrease
// in the measure score.
CodeableConcept improvementNotation;

//  The results of the calculation, one for each population group in the
// measure.
List<MeasureReport_Group> group;

//  A reference to a Bundle containing the Resources that were used in the
// calculation of this measure.
List<Reference> evaluatedResource;

MeasureReport(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.type,
    this.measure,
    this.subject,
    this.date,
    this.reporter,
    this.period,
    this.improvementNotation,
    this.group,
    this.evaluatedResource,
    });

  factory MeasureReport.fromJson(Map<String, dynamic> json) => _$MeasureReportFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReportToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Group {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The meaning of the population group as defined in the measure
// definition.
CodeableConcept code;

//  The populations that make up the population group, one for each type
// of population appropriate for the measure.
List<MeasureReport_Population> population;

//  The measure score for this population group, calculated as appropriate
// for the measure type and scoring method, and based on the contents of
// the populations defined in the group.
Quantity measureScore;

//  When a measure includes multiple stratifiers, there will be a
// stratifier group for each stratifier defined by the measure.
List<MeasureReport_Stratifier> stratifier;

MeasureReport_Group(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.population,
    this.measureScore,
    this.stratifier,
    });

  factory MeasureReport_Group.fromJson(Map<String, dynamic> json) => _$MeasureReport_GroupFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_GroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Population {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of the population.
CodeableConcept code;

//  The number of members of the population.
int count;

//  This element refers to a List of subject level MeasureReport
// resources, one for each subject in this population.
Reference subjectResults;

MeasureReport_Population(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.count,
    this.subjectResults,
    });

  factory MeasureReport_Population.fromJson(Map<String, dynamic> json) => _$MeasureReport_PopulationFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_PopulationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Stratifier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The meaning of this stratifier, as defined in the measure definition.
List<CodeableConcept> code;

//  This element contains the results for a single stratum within the
// stratifier. For example, when stratifying on administrative gender,
// there will be four strata, one for each possible gender value.
List<MeasureReport_Stratum> stratum;

MeasureReport_Stratifier(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.stratum,
    });

  factory MeasureReport_Stratifier.fromJson(Map<String, dynamic> json) => _$MeasureReport_StratifierFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_StratifierToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Stratum {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The value for this stratum, expressed as a CodeableConcept. When
// defining stratifiers on complex values, the value must be rendered such
// that the value for each stratum within the stratifier is unique.
CodeableConcept value;

//  A stratifier component value.
List<MeasureReport_Component> component;

//  The populations that make up the stratum, one for each type of
// population appropriate to the measure.
List<MeasureReport_Population1> population;

//  The measure score for this stratum, calculated as appropriate for the
// measure type and scoring method, and based on only the members of this
// stratum.
Quantity measureScore;

MeasureReport_Stratum(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.value,
    this.component,
    this.population,
    this.measureScore,
    });

  factory MeasureReport_Stratum.fromJson(Map<String, dynamic> json) => _$MeasureReport_StratumFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_StratumToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Component {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The code for the stratum component value.
CodeableConcept code;

//  The stratum component value.
CodeableConcept value;

MeasureReport_Component(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.value,
    });

  factory MeasureReport_Component.fromJson(Map<String, dynamic> json) => _$MeasureReport_ComponentFromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_ComponentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MeasureReport_Population1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of the population.
CodeableConcept code;

//  The number of members of the population in this stratum.
int count;

//  This element refers to a List of subject level MeasureReport
// resources, one for each subject in this population in this stratum.
Reference subjectResults;

MeasureReport_Population1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.count,
    this.subjectResults,
    });

  factory MeasureReport_Population1.fromJson(Map<String, dynamic> json) => _$MeasureReport_Population1FromJson(json);
  Map<String, dynamic> toJson() => _$MeasureReport_Population1ToJson(this);
}

part 'media.g.dart';

@JsonSerializable(explicitToJson: true)
class Media {

//  This is a Media resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers associated with the image - these may include identifiers
// for the image itself, identifiers for the context of its collection
// (e.g. series ids) and context ids such as accession numbers or other
// workflow identifiers.
List<Identifier> identifier;

//  A procedure that is fulfilled in whole or in part by the creation of
// this media.
List<Reference> basedOn;

//  A larger event of which this particular event is a component or step.
List<Reference> partOf;

//  The current state of the {{title}}.
String status;

//  A code that classifies whether the media is an image, video or audio
// recording or some other media category.
CodeableConcept type;

//  Details of the type of the media - usually, how it was acquired (what
// type of device). If images sourced from a DICOM system, are wrapped in
// a Media resource, then this is the modality.
CodeableConcept modality;

//  The name of the imaging view e.g. Lateral or Antero-posterior (AP).
CodeableConcept view;

//  Who/What this Media is a record of.
Reference subject;

//  The encounter that establishes the context for this media.
Reference encounter;

//  The date and time(s) at which the media was collected.
String createdDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date and time(s) at which the media was collected.
Period createdPeriod;

//  The date and time this version of the media was made available to
// providers, typically after having been reviewed.
DateTime issued;

//  The person who administered the collection of the image.
Reference operator;

//  Describes why the event occurred in coded or textual form.
List<CodeableConcept> reasonCode;

//  Indicates the site on the subject's body where the observation was
// made (i.e. the target site).
CodeableConcept bodySite;

//  The name of the device / manufacturer of the device  that was used to
// make the recording.
String deviceName;

//  The device used to collect the media.
Reference device;

//  Height of the image in pixels (photo/video).
int height;

//  Width of the image in pixels (photo/video).
int width;

//  The number of frames in a photo. This is used with a multi-page fax,
// or an imaging acquisition context that takes multiple slices in a
// single image, or an animated gif. If there is more than one frame, this
// SHALL have a value in order to alert interface software that a
// multi-frame capable rendering widget is required.
int frames;

//  The duration of the recording in seconds - for audio and video.
double duration;

//  The actual content of the media - inline or by direct reference to the
// media source file.
Attachment content;

//  Comments made about the media by the performer, subject or other
// participants.
List<Annotation> note;

Media(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.partOf,
    this.status,
    this.type,
    this.modality,
    this.view,
    this.subject,
    this.encounter,
    this.createdDateTime,
    this.createdPeriod,
    this.issued,
    this.operator,
    this.reasonCode,
    this.bodySite,
    this.deviceName,
    this.device,
    this.height,
    this.width,
    this.frames,
    this.duration,
    this.content,
    this.note,
    });

  factory Media.fromJson(Map<String, dynamic> json) => _$MediaFromJson(json);
  Map<String, dynamic> toJson() => _$MediaToJson(this);
}

part 'medication.g.dart';

@JsonSerializable(explicitToJson: true)
class Medication {

//  This is a Medication resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifier for this medication.
List<Identifier> identifier;

//  A code (or set of codes) that specify this medication, or a textual
// description if no code is available. Usage note: This could be a
// standard medication code such as a code from RxNorm, SNOMED CT, IDMP
// etc. It could also be a national or local formulary code, optionally
// with translations to other code systems.
CodeableConcept code;

//  A code to indicate if the medication is in active use.
String status;

//  Describes the details of the manufacturer of the medication product. 
// This is not intended to represent the distributor of a medication
// product.
Reference manufacturer;

//  Describes the form of the item.  Powder; tablets; capsule.
CodeableConcept form;

//  Specific amount of the drug in the packaged product.  For example,
// when specifying a product that has the same strength (For example,
// Insulin glargine 100 unit per mL solution for injection), this
// attribute provides additional clarification of the package amount (For
// example, 3 mL, 10mL, etc.).
Ratio amount;

//  Identifies a particular constituent of interest in the product.
List<Medication_Ingredient> ingredient;

//  Information that only applies to packages (not products).
Medication_Batch batch;

Medication(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.code,
    this.status,
    this.manufacturer,
    this.form,
    this.amount,
    this.ingredient,
    this.batch,
    });

  factory Medication.fromJson(Map<String, dynamic> json) => _$MedicationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Medication_Ingredient {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The actual ingredient - either a substance (simple ingredient) or
// another medication of a medication.
CodeableConcept itemCodeableConcept;

//  The actual ingredient - either a substance (simple ingredient) or
// another medication of a medication.
Reference itemReference;

//  Indication of whether this ingredient affects the therapeutic action
// of the drug.
bool isActive;

//  Specifies how many (or how much) of the items there are in this
// Medication.  For example, 250 mg per tablet.  This is expressed as a
// ratio where the numerator is 250mg and the denominator is 1 tablet.
Ratio strength;

Medication_Ingredient(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemCodeableConcept,
    this.itemReference,
    this.isActive,
    this.strength,
    });

  factory Medication_Ingredient.fromJson(Map<String, dynamic> json) => _$Medication_IngredientFromJson(json);
  Map<String, dynamic> toJson() => _$Medication_IngredientToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Medication_Batch {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The assigned lot number of a batch of the specified product.
String lotNumber;

//  When this specific batch of product will expire.
DateTime expirationDate;

Medication_Batch(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.lotNumber,
    this.expirationDate,
    });

  factory Medication_Batch.fromJson(Map<String, dynamic> json) => _$Medication_BatchFromJson(json);
  Map<String, dynamic> toJson() => _$Medication_BatchToJson(this);
}

part 'medicationAdministration.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicationAdministration {

//  This is a MedicationAdministration resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers associated with this Medication Administration that are
// defined by business processes and/or used to refer to it when a direct
// URL reference to the resource itself is not appropriate. They are
// business identifiers assigned to this resource by the performer or
// other systems and remain constant as the resource is updated and
// propagates from server to server.
List<Identifier> identifier;

//  A protocol, guideline, orderset, or other definition that was adhered
// to in whole or in part by this event.
List<String> instantiates;

//  A larger event of which this particular event is a component or step.
List<Reference> partOf;

//  Will generally be set to show that the administration has been
// completed.  For some long running administrations such as infusions, it
// is possible for an administration to be started but not completed or it
// may be paused while some other process is under way.
String status;

//  A code indicating why the administration was not performed.
List<CodeableConcept> statusReason;

//  Indicates where the medication is expected to be consumed or
// administered.
CodeableConcept category;

//  Identifies the medication that was administered. This is either a link
// to a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
CodeableConcept medicationCodeableConcept;

//  Identifies the medication that was administered. This is either a link
// to a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
Reference medicationReference;

//  The person or animal or group receiving the medication.
Reference subject;

//  The visit, admission, or other contact between patient and health care
// provider during which the medication administration was performed.
Reference context;

//  Additional information (for example, patient height and weight) that
// supports the administration of the medication.
List<Reference> supportingInformation;

//  A specific date/time or interval of time during which the
// administration took place (or did not take place, when the 'notGiven'
// attribute is true). For many administrations, such as swallowing a
// tablet the use of dateTime is more appropriate.
String effectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  A specific date/time or interval of time during which the
// administration took place (or did not take place, when the 'notGiven'
// attribute is true). For many administrations, such as swallowing a
// tablet the use of dateTime is more appropriate.
Period effectivePeriod;

//  Indicates who or what performed the medication administration and how
// they were involved.
List<MedicationAdministration_Performer> performer;

//  A code indicating why the medication was given.
List<CodeableConcept> reasonCode;

//  Condition or observation that supports why the medication was
// administered.
List<Reference> reasonReference;

//  The original request, instruction or authority to perform the
// administration.
Reference request;

//  The device used in administering the medication to the patient.  For
// example, a particular infusion pump.
List<Reference> device;

//  Extra information about the medication administration that is not
// conveyed by the other attributes.
List<Annotation> note;

//  Describes the medication dosage information details e.g. dose, rate,
// site, route, etc.
MedicationAdministration_Dosage dosage;

//  A summary of the events of interest that have occurred, such as when
// the administration was verified.
List<Reference> eventHistory;

MedicationAdministration(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiates,
    this.partOf,
    this.status,
    this.statusReason,
    this.category,
    this.medicationCodeableConcept,
    this.medicationReference,
    this.subject,
    this.context,
    this.supportingInformation,
    this.effectiveDateTime,
    this.effectivePeriod,
    this.performer,
    this.reasonCode,
    this.reasonReference,
    this.request,
    this.device,
    this.note,
    this.dosage,
    this.eventHistory,
    });

  factory MedicationAdministration.fromJson(Map<String, dynamic> json) => _$MedicationAdministrationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationAdministrationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationAdministration_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Distinguishes the type of involvement of the performer in the
// medication administration.
CodeableConcept function;

//  Indicates who or what performed the medication administration.
Reference actor;

MedicationAdministration_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    });

  factory MedicationAdministration_Performer.fromJson(Map<String, dynamic> json) => _$MedicationAdministration_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationAdministration_PerformerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationAdministration_Dosage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Free text dosage can be used for cases where the dosage administered
// is too complex to code. When coded dosage is present, the free text
// dosage may still be present for display to humans.The dosage
// instructions should reflect the dosage of the medication that was
// administered.
String text;

//  A coded specification of the anatomic site where the medication first
// entered the body.  For example, "left arm".
CodeableConcept site;

//  A code specifying the route or physiological path of administration of
// a therapeutic agent into or onto the patient.  For example, topical,
// intravenous, etc.
CodeableConcept route;

//  A coded value indicating the method by which the medication is
// intended to be or was introduced into or on the body.  This attribute
// will most often NOT be populated.  It is most commonly used for
// injections.  For example, Slow Push, Deep IV.
CodeableConcept method;

//  The amount of the medication given at one administration event.   Use
// this value when the administration is essentially an instantaneous
// event such as a swallowing a tablet or giving an injection.
Quantity dose;

//  Identifies the speed with which the medication was or will be
// introduced into the patient.  Typically, the rate for an infusion e.g.
// 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per
// unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or
// 200 mcg/1 minute; 1 liter/8 hours.
Ratio rateRatio;

//  Identifies the speed with which the medication was or will be
// introduced into the patient.  Typically, the rate for an infusion e.g.
// 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per
// unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or
// 200 mcg/1 minute; 1 liter/8 hours.
Quantity rateQuantity;

MedicationAdministration_Dosage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.text,
    this.site,
    this.route,
    this.method,
    this.dose,
    this.rateRatio,
    this.rateQuantity,
    });

  factory MedicationAdministration_Dosage.fromJson(Map<String, dynamic> json) => _$MedicationAdministration_DosageFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationAdministration_DosageToJson(this);
}

part 'medicationDispense.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicationDispense {

//  This is a MedicationDispense resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers associated with this Medication Dispense that are defined
// by business processes and/or used to refer to it when a direct URL
// reference to the resource itself is not appropriate. They are business
// identifiers assigned to this resource by the performer or other systems
// and remain constant as the resource is updated and propagates from
// server to server.
List<Identifier> identifier;

//  The procedure that trigger the dispense.
List<Reference> partOf;

//  A code specifying the state of the set of dispense events.
String status;

//  Indicates the reason why a dispense was not performed.
CodeableConcept statusReasonCodeableConcept;

//  Indicates the reason why a dispense was not performed.
Reference statusReasonReference;

//  Indicates the type of medication dispense (for example, where the
// medication is expected to be consumed or administered (i.e. inpatient
// or outpatient)).
CodeableConcept category;

//  Identifies the medication being administered. This is either a link to
// a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
CodeableConcept medicationCodeableConcept;

//  Identifies the medication being administered. This is either a link to
// a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
Reference medicationReference;

//  A link to a resource representing the person or the group to whom the
// medication will be given.
Reference subject;

//  The encounter or episode of care that establishes the context for this
// event.
Reference context;

//  Additional information that supports the medication being dispensed.
List<Reference> supportingInformation;

//  Indicates who or what performed the event.
List<MedicationDispense_Performer> performer;

//  The principal physical location where the dispense was performed.
Reference location;

//  Indicates the medication order that is being dispensed against.
List<Reference> authorizingPrescription;

//  Indicates the type of dispensing event that is performed. For example,
// Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples,
// etc.
CodeableConcept type;

//  The amount of medication that has been dispensed. Includes unit of
// measure.
Quantity quantity;

//  The amount of medication expressed as a timing amount.
Quantity daysSupply;

//  The time when the dispensed product was packaged and reviewed.
DateTime whenPrepared;

//  The time the dispensed product was provided to the patient or their
// representative.
DateTime whenHandedOver;

//  Identification of the facility/location where the medication was
// shipped to, as part of the dispense event.
Reference destination;

//  Identifies the person who picked up the medication.  This will usually
// be a patient or their caregiver, but some cases exist where it can be a
// healthcare professional.
List<Reference> receiver;

//  Extra information about the dispense that could not be conveyed in the
// other attributes.
List<Annotation> note;

//  Indicates how the medication is to be used by the patient.
List<Dosage> dosageInstruction;

//  Indicates whether or not substitution was made as part of the
// dispense.  In some cases, substitution will be expected but does not
// happen, in other cases substitution is not expected but does happen. 
// This block explains what substitution did or did not happen and why. 
// If nothing is specified, substitution was not done.
MedicationDispense_Substitution substitution;

//  Indicates an actual or potential clinical issue with or between one or
// more active or proposed clinical actions for a patient; e.g. drug-drug
// interaction, duplicate therapy, dosage alert etc.
List<Reference> detectedIssue;

//  A summary of the events of interest that have occurred, such as when
// the dispense was verified.
List<Reference> eventHistory;

MedicationDispense(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.partOf,
    this.status,
    this.statusReasonCodeableConcept,
    this.statusReasonReference,
    this.category,
    this.medicationCodeableConcept,
    this.medicationReference,
    this.subject,
    this.context,
    this.supportingInformation,
    this.performer,
    this.location,
    this.authorizingPrescription,
    this.type,
    this.quantity,
    this.daysSupply,
    this.whenPrepared,
    this.whenHandedOver,
    this.destination,
    this.receiver,
    this.note,
    this.dosageInstruction,
    this.substitution,
    this.detectedIssue,
    this.eventHistory,
    });

  factory MedicationDispense.fromJson(Map<String, dynamic> json) => _$MedicationDispenseFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationDispenseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationDispense_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Distinguishes the type of performer in the dispense.  For example,
// date enterer, packager, final checker.
CodeableConcept function;

//  The device, practitioner, etc. who performed the action.  It should be
// assumed that the actor is the dispenser of the medication.
Reference actor;

MedicationDispense_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    });

  factory MedicationDispense_Performer.fromJson(Map<String, dynamic> json) => _$MedicationDispense_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationDispense_PerformerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationDispense_Substitution {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  True if the dispenser dispensed a different drug or product from what
// was prescribed.
bool wasSubstituted;

//  A code signifying whether a different drug was dispensed from what was
// prescribed.
CodeableConcept type;

//  Indicates the reason for the substitution (or lack of substitution)
// from what was prescribed.
List<CodeableConcept> reason;

//  The person or organization that has primary responsibility for the
// substitution.
List<Reference> responsibleParty;

MedicationDispense_Substitution(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.wasSubstituted,
    this.type,
    this.reason,
    this.responsibleParty,
    });

  factory MedicationDispense_Substitution.fromJson(Map<String, dynamic> json) => _$MedicationDispense_SubstitutionFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationDispense_SubstitutionToJson(this);
}

part 'medicationKnowledge.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge {

//  This is a MedicationKnowledge resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A code that specifies this medication, or a textual description if no
// code is available. Usage note: This could be a standard medication code
// such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a
// national or local formulary code, optionally with translations to other
// code systems.
CodeableConcept code;

//  A code to indicate if the medication is in active use.  The status
// refers to the validity about the information of the medication and not
// to its medicinal properties.
String status;

//  Describes the details of the manufacturer of the medication product. 
// This is not intended to represent the distributor of a medication
// product.
Reference manufacturer;

//  Describes the form of the item.  Powder; tablets; capsule.
CodeableConcept doseForm;

//  Specific amount of the drug in the packaged product.  For example,
// when specifying a product that has the same strength (For example,
// Insulin glargine 100 unit per mL solution for injection), this
// attribute provides additional clarification of the package amount (For
// example, 3 mL, 10mL, etc.).
Quantity amount;

//  Additional names for a medication, for example, the name(s) given to a
// medication in different countries.  For example, acetaminophen and
// paracetamol or salbutamol and albuterol.
List<String> synonym;

//  Associated or related knowledge about a medication.
List<MedicationKnowledge_RelatedMedicationKnowledge> relatedMedicationKnowledge;

//  Associated or related medications.  For example, if the medication is
// a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g.
// Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin),
// this would link to a branded product (e.g. Crestor).
List<Reference> associatedMedication;

//  Category of the medication or product (e.g. branded product,
// therapeutic moeity, generic product, innovator product, etc.).
List<CodeableConcept> productType;

//  Associated documentation about the medication.
List<MedicationKnowledge_Monograph> monograph;

//  Identifies a particular constituent of interest in the product.
List<MedicationKnowledge_Ingredient> ingredient;

//  The instructions for preparing the medication.
String preparationInstruction;

//  The intended or approved route of administration.
List<CodeableConcept> intendedRoute;

//  The price of the medication.
List<MedicationKnowledge_Cost> cost;

//  The program under which the medication is reviewed.
List<MedicationKnowledge_MonitoringProgram> monitoringProgram;

//  Guidelines for the administration of the medication.
List<MedicationKnowledge_AdministrationGuidelines> administrationGuidelines;

//  Categorization of the medication within a formulary or classification
// system.
List<MedicationKnowledge_MedicineClassification> medicineClassification;

//  Information that only applies to packages (not products).
MedicationKnowledge_Packaging packaging;

//  Specifies descriptive properties of the medicine, such as color,
// shape, imprints, etc.
List<MedicationKnowledge_DrugCharacteristic> drugCharacteristic;

//  Potential clinical issue with or between medication(s) (for example,
// drug-drug interaction, drug-disease contraindication, drug-allergy
// interaction, etc.).
List<Reference> contraindication;

//  Regulatory information about a medication.
List<MedicationKnowledge_Regulatory> regulatory;

//  The time course of drug absorption, distribution, metabolism and
// excretion of a medication from the body.
List<MedicationKnowledge_Kinetics> kinetics;

MedicationKnowledge(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.code,
    this.status,
    this.manufacturer,
    this.doseForm,
    this.amount,
    this.synonym,
    this.relatedMedicationKnowledge,
    this.associatedMedication,
    this.productType,
    this.monograph,
    this.ingredient,
    this.preparationInstruction,
    this.intendedRoute,
    this.cost,
    this.monitoringProgram,
    this.administrationGuidelines,
    this.medicineClassification,
    this.packaging,
    this.drugCharacteristic,
    this.contraindication,
    this.regulatory,
    this.kinetics,
    });

  factory MedicationKnowledge.fromJson(Map<String, dynamic> json) => _$MedicationKnowledgeFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledgeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_RelatedMedicationKnowledge {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The category of the associated medication knowledge reference.
CodeableConcept type;

//  Associated documentation about the associated medication knowledge.
List<Reference> reference;

MedicationKnowledge_RelatedMedicationKnowledge(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.reference,
    });

  factory MedicationKnowledge_RelatedMedicationKnowledge.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_RelatedMedicationKnowledgeFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_RelatedMedicationKnowledgeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Monograph {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The category of documentation about the medication. (e.g. professional
// monograph, patient education monograph).
CodeableConcept type;

//  Associated documentation about the medication.
Reference source;

MedicationKnowledge_Monograph(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.source,
    });

  factory MedicationKnowledge_Monograph.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_MonographFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_MonographToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Ingredient {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The actual ingredient - either a substance (simple ingredient) or
// another medication.
CodeableConcept itemCodeableConcept;

//  The actual ingredient - either a substance (simple ingredient) or
// another medication.
Reference itemReference;

//  Indication of whether this ingredient affects the therapeutic action
// of the drug.
bool isActive;

//  Specifies how many (or how much) of the items there are in this
// Medication.  For example, 250 mg per tablet.  This is expressed as a
// ratio where the numerator is 250mg and the denominator is 1 tablet.
Ratio strength;

MedicationKnowledge_Ingredient(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemCodeableConcept,
    this.itemReference,
    this.isActive,
    this.strength,
    });

  factory MedicationKnowledge_Ingredient.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_IngredientFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_IngredientToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Cost {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The category of the cost information.  For example, manufacturers'
// cost, patient cost, claim reimbursement cost, actual acquisition cost.
CodeableConcept type;

//  The source or owner that assigns the price to the medication.
String source;

//  The price of the medication.
Money cost;

MedicationKnowledge_Cost(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.source,
    this.cost,
    });

  factory MedicationKnowledge_Cost.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_CostFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_CostToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_MonitoringProgram {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of program under which the medication is monitored.
CodeableConcept type;

//  Name of the reviewing program.
String name;

MedicationKnowledge_MonitoringProgram(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.name,
    });

  factory MedicationKnowledge_MonitoringProgram.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_MonitoringProgramFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_MonitoringProgramToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_AdministrationGuidelines {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Dosage for the medication for the specific guidelines.
List<MedicationKnowledge_Dosage> dosage;

//  Indication for use that apply to the specific administration
// guidelines.
CodeableConcept indicationCodeableConcept;

//  Indication for use that apply to the specific administration
// guidelines.
Reference indicationReference;

//  Characteristics of the patient that are relevant to the administration
// guidelines (for example, height, weight, gender, etc.).
List<MedicationKnowledge_PatientCharacteristics> patientCharacteristics;

MedicationKnowledge_AdministrationGuidelines(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.dosage,
    this.indicationCodeableConcept,
    this.indicationReference,
    this.patientCharacteristics,
    });

  factory MedicationKnowledge_AdministrationGuidelines.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_AdministrationGuidelinesFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_AdministrationGuidelinesToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Dosage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of dosage (for example, prophylaxis, maintenance,
// therapeutic, etc.).
CodeableConcept type;

//  Dosage for the medication for the specific guidelines.
List<Dosage> dosage;

MedicationKnowledge_Dosage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.dosage,
    });

  factory MedicationKnowledge_Dosage.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_DosageFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_DosageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_PatientCharacteristics {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specific characteristic that is relevant to the administration
// guideline (e.g. height, weight, gender).
CodeableConcept characteristicCodeableConcept;

//  Specific characteristic that is relevant to the administration
// guideline (e.g. height, weight, gender).
Quantity characteristicQuantity;

//  The specific characteristic (e.g. height, weight, gender, etc.).
List<String> value;

MedicationKnowledge_PatientCharacteristics(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.characteristicCodeableConcept,
    this.characteristicQuantity,
    this.value,
    });

  factory MedicationKnowledge_PatientCharacteristics.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_PatientCharacteristicsFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_PatientCharacteristicsToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_MedicineClassification {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of category for the medication (for example, therapeutic
// classification, therapeutic sub-classification).
CodeableConcept type;

//  Specific category assigned to the medication (e.g. anti-infective,
// anti-hypertensive, antibiotic, etc.).
List<CodeableConcept> classification;

MedicationKnowledge_MedicineClassification(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.classification,
    });

  factory MedicationKnowledge_MedicineClassification.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_MedicineClassificationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_MedicineClassificationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Packaging {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code that defines the specific type of packaging that the medication
// can be found in (e.g. blister sleeve, tube, bottle).
CodeableConcept type;

//  The number of product units the package would contain if fully loaded.
Quantity quantity;

MedicationKnowledge_Packaging(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.quantity,
    });

  factory MedicationKnowledge_Packaging.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_PackagingFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_PackagingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_DrugCharacteristic {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code specifying which characteristic of the medicine is being
// described (for example, colour, shape, imprint).
CodeableConcept type;

//  Description of the characteristic.
CodeableConcept valueCodeableConcept;

//  Description of the characteristic.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Description of the characteristic.
Quantity valueQuantity;

//  Description of the characteristic.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

MedicationKnowledge_DrugCharacteristic(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueCodeableConcept,
    this.valueString,
    this.valueQuantity,
    this.valueBase64Binary,
    });

  factory MedicationKnowledge_DrugCharacteristic.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_DrugCharacteristicFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_DrugCharacteristicToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Regulatory {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The authority that is specifying the regulations.
Reference regulatoryAuthority;

//  Specifies if changes are allowed when dispensing a medication from a
// regulatory perspective.
List<MedicationKnowledge_Substitution> substitution;

//  Specifies the schedule of a medication in jurisdiction.
List<MedicationKnowledge_Schedule> schedule;

//  The maximum number of units of the medication that can be dispensed in
// a period.
MedicationKnowledge_MaxDispense maxDispense;

MedicationKnowledge_Regulatory(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.regulatoryAuthority,
    this.substitution,
    this.schedule,
    this.maxDispense,
    });

  factory MedicationKnowledge_Regulatory.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_RegulatoryFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_RegulatoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Substitution {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specifies the type of substitution allowed.
CodeableConcept type;

//  Specifies if regulation allows for changes in the medication when
// dispensing.
bool allowed;

MedicationKnowledge_Substitution(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.allowed,
    });

  factory MedicationKnowledge_Substitution.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_SubstitutionFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_SubstitutionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Schedule {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specifies the specific drug schedule.
CodeableConcept schedule;

MedicationKnowledge_Schedule(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.schedule,
    });

  factory MedicationKnowledge_Schedule.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_ScheduleFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_ScheduleToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_MaxDispense {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The maximum number of units of the medication that can be dispensed.
Quantity quantity;

//  The period that applies to the maximum number of units.
Duration period;

MedicationKnowledge_MaxDispense(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.quantity,
    this.period,
    });

  factory MedicationKnowledge_MaxDispense.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_MaxDispenseFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_MaxDispenseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationKnowledge_Kinetics {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The drug concentration measured at certain discrete points in time.
List<Quantity> areaUnderCurve;

//  The median lethal dose of a drug.
List<Quantity> lethalDose50;

//  The time required for any specified property (e.g., the concentration
// of a substance in the body) to decrease by half.
Duration halfLifePeriod;

MedicationKnowledge_Kinetics(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.areaUnderCurve,
    this.lethalDose50,
    this.halfLifePeriod,
    });

  factory MedicationKnowledge_Kinetics.fromJson(Map<String, dynamic> json) => _$MedicationKnowledge_KineticsFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationKnowledge_KineticsToJson(this);
}

part 'medicationRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicationRequest {

//  This is a MedicationRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers associated with this medication request that are defined
// by business processes and/or used to refer to it when a direct URL
// reference to the resource itself is not appropriate. They are business
// identifiers assigned to this resource by the performer or other systems
// and remain constant as the resource is updated and propagates from
// server to server.
List<Identifier> identifier;

//  A code specifying the current state of the order.  Generally, this
// will be active or completed state.
String status;

//  Captures the reason for the current state of the MedicationRequest.
CodeableConcept statusReason;

//  Whether the request is a proposal, plan, or an original order.
String intent;

//  Indicates the type of medication request (for example, where the
// medication is expected to be consumed or administered (i.e. inpatient
// or outpatient)).
List<CodeableConcept> category;

//  Indicates how quickly the Medication Request should be addressed with
// respect to other requests.
String priority;

//  If true indicates that the provider is asking for the medication
// request not to occur.
bool doNotPerform;

//  Indicates if this record was captured as a secondary 'reported' record
// rather than as an original primary source-of-truth record.  It may also
// indicate the source of the report.
bool reportedBoolean; //  pattern: ^true|false$

//  Indicates if this record was captured as a secondary 'reported' record
// rather than as an original primary source-of-truth record.  It may also
// indicate the source of the report.
Reference reportedReference;

//  Identifies the medication being requested. This is a link to a
// resource that represents the medication which may be the details of the
// medication or simply an attribute carrying a code that identifies the
// medication from a known list of medications.
CodeableConcept medicationCodeableConcept;

//  Identifies the medication being requested. This is a link to a
// resource that represents the medication which may be the details of the
// medication or simply an attribute carrying a code that identifies the
// medication from a known list of medications.
Reference medicationReference;

//  A link to a resource representing the person or set of individuals to
// whom the medication will be given.
Reference subject;

//  The Encounter during which this [x] was created or to which the
// creation of this record is tightly associated.
Reference encounter;

//  Include additional information (for example, patient height and
// weight) that supports the ordering of the medication.
List<Reference> supportingInformation;

//  The date (and perhaps time) when the prescription was initially
// written or authored on.
DateTime authoredOn;

//  The individual, organization, or device that initiated the request and
// has responsibility for its activation.
Reference requester;

//  The specified desired performer of the medication treatment (e.g. the
// performer of the medication administration).
Reference performer;

//  Indicates the type of performer of the administration of the
// medication.
CodeableConcept performerType;

//  The person who entered the order on behalf of another individual for
// example in the case of a verbal or a telephone order.
Reference recorder;

//  The reason or the indication for ordering or not ordering the
// medication.
List<CodeableConcept> reasonCode;

//  Condition or observation that supports why the medication was ordered.
List<Reference> reasonReference;

//  The URL pointing to a protocol, guideline, orderset, or other
// definition that is adhered to in whole or in part by this
// MedicationRequest.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this MedicationRequest.
List<String> instantiatesUri;

//  A plan or request that is fulfilled in whole or in part by this
// medication request.
List<Reference> basedOn;

//  A shared identifier common to all requests that were authorized more
// or less simultaneously by a single author, representing the identifier
// of the requisition or prescription.
Identifier groupIdentifier;

//  The description of the overall patte3rn of the administration of the
// medication to the patient.
CodeableConcept courseOfTherapyType;

//  Insurance plans, coverage extensions, pre-authorizations and/or
// pre-determinations that may be required for delivering the requested
// service.
List<Reference> insurance;

//  Extra information about the prescription that could not be conveyed by
// the other attributes.
List<Annotation> note;

//  Indicates how the medication is to be used by the patient.
List<Dosage> dosageInstruction;

//  Indicates the specific details for the dispense or medication supply
// part of a medication request (also known as a Medication Prescription
// or Medication Order).  Note that this information is not always sent
// with the order.  There may be in some settings (e.g. hospitals)
// institutional or system support for completing the dispense details in
// the pharmacy department.
MedicationRequest_DispenseRequest dispenseRequest;

//  Indicates whether or not substitution can or should be part of the
// dispense. In some cases, substitution must happen, in other cases
// substitution must not happen. This block explains the prescriber's
// intent. If nothing is specified substitution may be done.
MedicationRequest_Substitution substitution;

//  A link to a resource representing an earlier order related order or
// prescription.
Reference priorPrescription;

//  Indicates an actual or potential clinical issue with or between one or
// more active or proposed clinical actions for a patient; e.g. Drug-drug
// interaction, duplicate therapy, dosage alert etc.
List<Reference> detectedIssue;

//  Links to Provenance records for past versions of this resource or
// fulfilling request or event resources that identify key state
// transitions or updates that are likely to be relevant to a user looking
// at the current version of the resource.
List<Reference> eventHistory;

MedicationRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.statusReason,
    this.intent,
    this.category,
    this.priority,
    this.doNotPerform,
    this.reportedBoolean,
    this.reportedReference,
    this.medicationCodeableConcept,
    this.medicationReference,
    this.subject,
    this.encounter,
    this.supportingInformation,
    this.authoredOn,
    this.requester,
    this.performer,
    this.performerType,
    this.recorder,
    this.reasonCode,
    this.reasonReference,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.groupIdentifier,
    this.courseOfTherapyType,
    this.insurance,
    this.note,
    this.dosageInstruction,
    this.dispenseRequest,
    this.substitution,
    this.priorPrescription,
    this.detectedIssue,
    this.eventHistory,
    });

  factory MedicationRequest.fromJson(Map<String, dynamic> json) => _$MedicationRequestFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationRequest_DispenseRequest {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates the quantity or duration for the first dispense of the
// medication.
MedicationRequest_InitialFill initialFill;

//  The minimum period of time that must occur between dispenses of the
// medication.
Duration dispenseInterval;

//  This indicates the validity period of a prescription (stale dating the
// Prescription).
Period validityPeriod;

//  An integer indicating the number of times, in addition to the original
// dispense, (aka refills or repeats) that the patient can receive the
// prescribed medication. Usage Notes: This integer does not include the
// original order dispense. This means that if an order indicates dispense
// 30 tablets plus "3 repeats", then the order can be dispensed a total of
// 4 times and the patient can receive a total of 120 tablets.  A
// prescriber may explicitly say that zero refills are permitted after the
// initial dispense.
int numberOfRepeatsAllowed;

//  The amount that is to be dispensed for one fill.
Quantity quantity;

//  Identifies the period time over which the supplied product is expected
// to be used, or the length of time the dispense is expected to last.
Duration expectedSupplyDuration;

//  Indicates the intended dispensing Organization specified by the
// prescriber.
Reference performer;

MedicationRequest_DispenseRequest(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.initialFill,
    this.dispenseInterval,
    this.validityPeriod,
    this.numberOfRepeatsAllowed,
    this.quantity,
    this.expectedSupplyDuration,
    this.performer,
    });

  factory MedicationRequest_DispenseRequest.fromJson(Map<String, dynamic> json) => _$MedicationRequest_DispenseRequestFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationRequest_DispenseRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationRequest_InitialFill {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The amount or quantity to provide as part of the first dispense.
Quantity quantity;

//  The length of time that the first dispense is expected to last.
Duration duration;

MedicationRequest_InitialFill(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.quantity,
    this.duration,
    });

  factory MedicationRequest_InitialFill.fromJson(Map<String, dynamic> json) => _$MedicationRequest_InitialFillFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationRequest_InitialFillToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicationRequest_Substitution {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  True if the prescriber allows a different drug to be dispensed from
// what was prescribed.
bool allowedBoolean; //  pattern: ^true|false$

//  True if the prescriber allows a different drug to be dispensed from
// what was prescribed.
CodeableConcept allowedCodeableConcept;

//  Indicates the reason for the substitution, or why substitution must or
// must not be performed.
CodeableConcept reason;

MedicationRequest_Substitution(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.allowedBoolean,
    this.allowedCodeableConcept,
    this.reason,
    });

  factory MedicationRequest_Substitution.fromJson(Map<String, dynamic> json) => _$MedicationRequest_SubstitutionFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationRequest_SubstitutionToJson(this);
}

part 'medicationStatement.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicationStatement {

//  This is a MedicationStatement resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers associated with this Medication Statement that are defined
// by business processes and/or used to refer to it when a direct URL
// reference to the resource itself is not appropriate. They are business
// identifiers assigned to this resource by the performer or other systems
// and remain constant as the resource is updated and propagates from
// server to server.
List<Identifier> identifier;

//  A plan, proposal or order that is fulfilled in whole or in part by
// this event.
List<Reference> basedOn;

//  A larger event of which this particular event is a component or step.
List<Reference> partOf;

//  A code representing the patient or other source's judgment about the
// state of the medication used that this statement is about.  Generally,
// this will be active or completed.
String status;

//  Captures the reason for the current state of the MedicationStatement.
List<CodeableConcept> statusReason;

//  Indicates where the medication is expected to be consumed or
// administered.
CodeableConcept category;

//  Identifies the medication being administered. This is either a link to
// a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
CodeableConcept medicationCodeableConcept;

//  Identifies the medication being administered. This is either a link to
// a resource representing the details of the medication or a simple
// attribute carrying a code that identifies the medication from a known
// list of medications.
Reference medicationReference;

//  The person, animal or group who is/was taking the medication.
Reference subject;

//  The encounter or episode of care that establishes the context for this
// MedicationStatement.
Reference context;

//  The interval of time during which it is being asserted that the
// patient is/was/will be taking the medication (or was not taking, when
// the MedicationStatement.taken element is No).
String effectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The interval of time during which it is being asserted that the
// patient is/was/will be taking the medication (or was not taking, when
// the MedicationStatement.taken element is No).
Period effectivePeriod;

//  The date when the medication statement was asserted by the information
// source.
DateTime dateAsserted;

//  The person or organization that provided the information about the
// taking of this medication. Note: Use derivedFrom when a
// MedicationStatement is derived from other resources, e.g. Claim or
// MedicationRequest.
Reference informationSource;

//  Allows linking the MedicationStatement to the underlying
// MedicationRequest, or to other information that supports or is used to
// derive the MedicationStatement.
List<Reference> derivedFrom;

//  A reason for why the medication is being/was taken.
List<CodeableConcept> reasonCode;

//  Condition or observation that supports why the medication is being/was
// taken.
List<Reference> reasonReference;

//  Provides extra information about the medication statement that is not
// conveyed by the other attributes.
List<Annotation> note;

//  Indicates how the medication is/was or should be taken by the patient.
List<Dosage> dosage;

MedicationStatement(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.partOf,
    this.status,
    this.statusReason,
    this.category,
    this.medicationCodeableConcept,
    this.medicationReference,
    this.subject,
    this.context,
    this.effectiveDateTime,
    this.effectivePeriod,
    this.dateAsserted,
    this.informationSource,
    this.derivedFrom,
    this.reasonCode,
    this.reasonReference,
    this.note,
    this.dosage,
    });

  factory MedicationStatement.fromJson(Map<String, dynamic> json) => _$MedicationStatementFromJson(json);
  Map<String, dynamic> toJson() => _$MedicationStatementToJson(this);
}

part 'medicinalProduct.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProduct {

//  This is a MedicinalProduct resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifier for this product. Could be an MPID.
List<Identifier> identifier;

//  Regulatory type, e.g. Investigational or Authorized.
CodeableConcept type;

//  If this medicine applies to human or veterinary uses.
Coding domain;

//  The dose form for a single part product, or combined form of a
// multiple part product.
CodeableConcept combinedPharmaceuticalDoseForm;

//  The legal status of supply of the medicinal product as classified by
// the regulator.
CodeableConcept legalStatusOfSupply;

//  Whether the Medicinal Product is subject to additional monitoring for
// regulatory reasons.
CodeableConcept additionalMonitoringIndicator;

//  Whether the Medicinal Product is subject to special measures for
// regulatory reasons.
List<String> specialMeasures;

//  If authorised for use in children.
CodeableConcept paediatricUseIndicator;

//  Allows the product to be classified by various systems.
List<CodeableConcept> productClassification;

//  Marketing status of the medicinal product, in contrast to marketing
// authorizaton.
List<MarketingStatus> marketingStatus;

//  Pharmaceutical aspects of product.
List<Reference> pharmaceuticalProduct;

//  Package representation for the product.
List<Reference> packagedMedicinalProduct;

//  Supporting documentation, typically for regulatory submission.
List<Reference> attachedDocument;

//  A master file for to the medicinal product (e.g. Pharmacovigilance
// System Master File).
List<Reference> masterFile;

//  A product specific contact, person (in a role), or an organization.
List<Reference> contact;

//  Clinical trials or studies that this product is involved in.
List<Reference> clinicalTrial;

//  The product's name, including full name and possibly coded parts.
List<MedicinalProduct_Name> name;

//  Reference to another product, e.g. for linking authorised to
// investigational product.
List<Identifier> crossReference;

//  An operation applied to the product, for manufacturing or
// adminsitrative purpose.
List<MedicinalProduct_ManufacturingBusinessOperation> manufacturingBusinessOperation;

//  Indicates if the medicinal product has an orphan designation for the
// treatment of a rare disease.
List<MedicinalProduct_SpecialDesignation> specialDesignation;

MedicinalProduct(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.domain,
    this.combinedPharmaceuticalDoseForm,
    this.legalStatusOfSupply,
    this.additionalMonitoringIndicator,
    this.specialMeasures,
    this.paediatricUseIndicator,
    this.productClassification,
    this.marketingStatus,
    this.pharmaceuticalProduct,
    this.packagedMedicinalProduct,
    this.attachedDocument,
    this.masterFile,
    this.contact,
    this.clinicalTrial,
    this.name,
    this.crossReference,
    this.manufacturingBusinessOperation,
    this.specialDesignation,
    });

  factory MedicinalProduct.fromJson(Map<String, dynamic> json) => _$MedicinalProductFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProduct_Name {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The full product name.
String productName;

//  Coding words or phrases of the name.
List<MedicinalProduct_NamePart> namePart;

//  Country where the name applies.
List<MedicinalProduct_CountryLanguage> countryLanguage;

MedicinalProduct_Name(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.productName,
    this.namePart,
    this.countryLanguage,
    });

  factory MedicinalProduct_Name.fromJson(Map<String, dynamic> json) => _$MedicinalProduct_NameFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProduct_NameToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProduct_NamePart {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A fragment of a product name.
String part;

//  Idenifying type for this part of the name (e.g. strength part).
Coding type;

MedicinalProduct_NamePart(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.part,
    this.type,
    });

  factory MedicinalProduct_NamePart.fromJson(Map<String, dynamic> json) => _$MedicinalProduct_NamePartFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProduct_NamePartToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProduct_CountryLanguage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Country code for where this name applies.
CodeableConcept country;

//  Jurisdiction code for where this name applies.
CodeableConcept jurisdiction;

//  Language code for this name.
CodeableConcept language;

MedicinalProduct_CountryLanguage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.country,
    this.jurisdiction,
    this.language,
    });

  factory MedicinalProduct_CountryLanguage.fromJson(Map<String, dynamic> json) => _$MedicinalProduct_CountryLanguageFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProduct_CountryLanguageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProduct_ManufacturingBusinessOperation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of manufacturing operation.
CodeableConcept operationType;

//  Regulatory authorization reference number.
Identifier authorisationReferenceNumber;

//  Regulatory authorization date.
DateTime effectiveDate;

//  To indicate if this proces is commercially confidential.
CodeableConcept confidentialityIndicator;

//  The manufacturer or establishment associated with the process.
List<Reference> manufacturer;

//  A regulator which oversees the operation.
Reference regulator;

MedicinalProduct_ManufacturingBusinessOperation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operationType,
    this.authorisationReferenceNumber,
    this.effectiveDate,
    this.confidentialityIndicator,
    this.manufacturer,
    this.regulator,
    });

  factory MedicinalProduct_ManufacturingBusinessOperation.fromJson(Map<String, dynamic> json) => _$MedicinalProduct_ManufacturingBusinessOperationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProduct_ManufacturingBusinessOperationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProduct_SpecialDesignation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the designation, or procedure number.
List<Identifier> identifier;

//  The type of special designation, e.g. orphan drug, minor use.
CodeableConcept type;

//  The intended use of the product, e.g. prevention, treatment.
CodeableConcept intendedUse;

//  Condition for which the medicinal use applies.
CodeableConcept indicationCodeableConcept;

//  Condition for which the medicinal use applies.
Reference indicationReference;

//  For example granted, pending, expired or withdrawn.
CodeableConcept status;

//  Date when the designation was granted.
DateTime date;

//  Animal species for which this applies.
CodeableConcept species;

MedicinalProduct_SpecialDesignation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.intendedUse,
    this.indicationCodeableConcept,
    this.indicationReference,
    this.status,
    this.date,
    this.species,
    });

  factory MedicinalProduct_SpecialDesignation.fromJson(Map<String, dynamic> json) => _$MedicinalProduct_SpecialDesignationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProduct_SpecialDesignationToJson(this);
}

part 'medicinalProductAuthorization.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductAuthorization {

//  This is a MedicinalProductAuthorization resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifier for the marketing authorization, as assigned by a
// regulator.
List<Identifier> identifier;

//  The medicinal product that is being authorized.
Reference subject;

//  The country in which the marketing authorization has been granted.
List<CodeableConcept> country;

//  Jurisdiction within a country.
List<CodeableConcept> jurisdiction;

//  The status of the marketing authorization.
CodeableConcept status;

//  The date at which the given status has become applicable.
DateTime statusDate;

//  The date when a suspended the marketing or the marketing authorization
// of the product is anticipated to be restored.
DateTime restoreDate;

//  The beginning of the time period in which the marketing authorization
// is in the specific status shall be specified A complete date consisting
// of day, month and year shall be specified using the ISO 8601 date
// format.
Period validityPeriod;

//  A period of time after authorization before generic product
// applicatiosn can be submitted.
Period dataExclusivityPeriod;

//  The date when the first authorization was granted by a Medicines
// Regulatory Agency.
DateTime dateOfFirstAuthorization;

//  Date of first marketing authorization for a company's new medicinal
// product in any country in the World.
DateTime internationalBirthDate;

//  The legal framework against which this authorization is granted.
CodeableConcept legalBasis;

//  Authorization in areas within a country.
List<MedicinalProductAuthorization_JurisdictionalAuthorization> jurisdictionalAuthorization;

//  Marketing Authorization Holder.
Reference holder;

//  Medicines Regulatory Agency.
Reference regulator;

//  The regulatory procedure for granting or amending a marketing
// authorization.
MedicinalProductAuthorization_Procedure procedure;

MedicinalProductAuthorization(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.subject,
    this.country,
    this.jurisdiction,
    this.status,
    this.statusDate,
    this.restoreDate,
    this.validityPeriod,
    this.dataExclusivityPeriod,
    this.dateOfFirstAuthorization,
    this.internationalBirthDate,
    this.legalBasis,
    this.jurisdictionalAuthorization,
    this.holder,
    this.regulator,
    this.procedure,
    });

  factory MedicinalProductAuthorization.fromJson(Map<String, dynamic> json) => _$MedicinalProductAuthorizationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductAuthorizationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductAuthorization_JurisdictionalAuthorization {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The assigned number for the marketing authorization.
List<Identifier> identifier;

//  Country of authorization.
CodeableConcept country;

//  Jurisdiction within a country.
List<CodeableConcept> jurisdiction;

//  The legal status of supply in a jurisdiction or region.
CodeableConcept legalStatusOfSupply;

//  The start and expected end date of the authorization.
Period validityPeriod;

MedicinalProductAuthorization_JurisdictionalAuthorization(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.country,
    this.jurisdiction,
    this.legalStatusOfSupply,
    this.validityPeriod,
    });

  factory MedicinalProductAuthorization_JurisdictionalAuthorization.fromJson(Map<String, dynamic> json) => _$MedicinalProductAuthorization_JurisdictionalAuthorizationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductAuthorization_JurisdictionalAuthorizationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductAuthorization_Procedure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for this procedure.
Identifier identifier;

//  Type of procedure.
CodeableConcept type;

//  Date of procedure.
Period datePeriod;

//  Date of procedure.
String dateDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Applcations submitted to obtain a marketing authorization.
List<MedicinalProductAuthorization_Procedure> application;

MedicinalProductAuthorization_Procedure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.datePeriod,
    this.dateDateTime,
    this.application,
    });

  factory MedicinalProductAuthorization_Procedure.fromJson(Map<String, dynamic> json) => _$MedicinalProductAuthorization_ProcedureFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductAuthorization_ProcedureToJson(this);
}

part 'medicinalProductContraindication.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductContraindication {

//  This is a MedicinalProductContraindication resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The medication for which this is an indication.
List<Reference> subject;

//  The disease, symptom or procedure for the contraindication.
CodeableConcept disease;

//  The status of the disease or symptom for the contraindication.
CodeableConcept diseaseStatus;

//  A comorbidity (concurrent condition) or coinfection.
List<CodeableConcept> comorbidity;

//  Information about the use of the medicinal product in relation to
// other therapies as part of the indication.
List<Reference> therapeuticIndication;

//  Information about the use of the medicinal product in relation to
// other therapies described as part of the indication.
List<MedicinalProductContraindication_OtherTherapy> otherTherapy;

//  The population group to which this applies.
List<Population> population;

MedicinalProductContraindication(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.subject,
    this.disease,
    this.diseaseStatus,
    this.comorbidity,
    this.therapeuticIndication,
    this.otherTherapy,
    this.population,
    });

  factory MedicinalProductContraindication.fromJson(Map<String, dynamic> json) => _$MedicinalProductContraindicationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductContraindicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductContraindication_OtherTherapy {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of relationship between the medicinal product indication or
// contraindication and another therapy.
CodeableConcept therapyRelationshipType;

//  Reference to a specific medication (active substance, medicinal
// product or class of products) as part of an indication or
// contraindication.
CodeableConcept medicationCodeableConcept;

//  Reference to a specific medication (active substance, medicinal
// product or class of products) as part of an indication or
// contraindication.
Reference medicationReference;

MedicinalProductContraindication_OtherTherapy(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.therapyRelationshipType,
    this.medicationCodeableConcept,
    this.medicationReference,
    });

  factory MedicinalProductContraindication_OtherTherapy.fromJson(Map<String, dynamic> json) => _$MedicinalProductContraindication_OtherTherapyFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductContraindication_OtherTherapyToJson(this);
}

part 'medicinalProductIndication.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductIndication {

//  This is a MedicinalProductIndication resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The medication for which this is an indication.
List<Reference> subject;

//  The disease, symptom or procedure that is the indication for
// treatment.
CodeableConcept diseaseSymptomProcedure;

//  The status of the disease or symptom for which the indication applies.
CodeableConcept diseaseStatus;

//  Comorbidity (concurrent condition) or co-infection as part of the
// indication.
List<CodeableConcept> comorbidity;

//  The intended effect, aim or strategy to be achieved by the indication.
CodeableConcept intendedEffect;

//  Timing or duration information as part of the indication.
Quantity duration;

//  Information about the use of the medicinal product in relation to
// other therapies described as part of the indication.
List<MedicinalProductIndication_OtherTherapy> otherTherapy;

//  Describe the undesirable effects of the medicinal product.
List<Reference> undesirableEffect;

//  The population group to which this applies.
List<Population> population;

MedicinalProductIndication(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.subject,
    this.diseaseSymptomProcedure,
    this.diseaseStatus,
    this.comorbidity,
    this.intendedEffect,
    this.duration,
    this.otherTherapy,
    this.undesirableEffect,
    this.population,
    });

  factory MedicinalProductIndication.fromJson(Map<String, dynamic> json) => _$MedicinalProductIndicationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIndicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductIndication_OtherTherapy {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of relationship between the medicinal product indication or
// contraindication and another therapy.
CodeableConcept therapyRelationshipType;

//  Reference to a specific medication (active substance, medicinal
// product or class of products) as part of an indication or
// contraindication.
CodeableConcept medicationCodeableConcept;

//  Reference to a specific medication (active substance, medicinal
// product or class of products) as part of an indication or
// contraindication.
Reference medicationReference;

MedicinalProductIndication_OtherTherapy(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.therapyRelationshipType,
    this.medicationCodeableConcept,
    this.medicationReference,
    });

  factory MedicinalProductIndication_OtherTherapy.fromJson(Map<String, dynamic> json) => _$MedicinalProductIndication_OtherTherapyFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIndication_OtherTherapyToJson(this);
}

part 'medicinalProductIngredient.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductIngredient {

//  This is a MedicinalProductIngredient resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The identifier(s) of this Ingredient that are assigned by business
// processes and/or used to refer to it when a direct URL reference to the
// resource itself is not appropriate.
Identifier identifier;

//  Ingredient role e.g. Active ingredient, excipient.
CodeableConcept role;

//  If the ingredient is a known or suspected allergen.
bool allergenicIndicator;

//  Manufacturer of this Ingredient.
List<Reference> manufacturer;

//  A specified substance that comprises this ingredient.
List<MedicinalProductIngredient_SpecifiedSubstance> specifiedSubstance;

//  The ingredient substance.
MedicinalProductIngredient_Substance substance;

MedicinalProductIngredient(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.role,
    this.allergenicIndicator,
    this.manufacturer,
    this.specifiedSubstance,
    this.substance,
    });

  factory MedicinalProductIngredient.fromJson(Map<String, dynamic> json) => _$MedicinalProductIngredientFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIngredientToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductIngredient_SpecifiedSubstance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The specified substance.
CodeableConcept code;

//  The group of specified substance, e.g. group 1 to 4.
CodeableConcept group;

//  Confidentiality level of the specified substance as the ingredient.
CodeableConcept confidentiality;

//  Quantity of the substance or specified substance present in the
// manufactured item or pharmaceutical product.
List<MedicinalProductIngredient_Strength> strength;

MedicinalProductIngredient_SpecifiedSubstance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.group,
    this.confidentiality,
    this.strength,
    });

  factory MedicinalProductIngredient_SpecifiedSubstance.fromJson(Map<String, dynamic> json) => _$MedicinalProductIngredient_SpecifiedSubstanceFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIngredient_SpecifiedSubstanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductIngredient_Strength {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The quantity of substance in the unit of presentation, or in the
// volume (or mass) of the single pharmaceutical product or manufactured
// item.
Ratio presentation;

//  A lower limit for the quantity of substance in the unit of
// presentation. For use when there is a range of strengths, this is the
// lower limit, with the presentation attribute becoming the upper limit.
Ratio presentationLowLimit;

//  The strength per unitary volume (or mass).
Ratio concentration;

//  A lower limit for the strength per unitary volume (or mass), for when
// there is a range. The concentration attribute then becomes the upper
// limit.
Ratio concentrationLowLimit;

//  For when strength is measured at a particular point or distance.
String measurementPoint;

//  The country or countries for which the strength range applies.
List<CodeableConcept> country;

//  Strength expressed in terms of a reference substance.
List<MedicinalProductIngredient_ReferenceStrength> referenceStrength;

MedicinalProductIngredient_Strength(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.presentation,
    this.presentationLowLimit,
    this.concentration,
    this.concentrationLowLimit,
    this.measurementPoint,
    this.country,
    this.referenceStrength,
    });

  factory MedicinalProductIngredient_Strength.fromJson(Map<String, dynamic> json) => _$MedicinalProductIngredient_StrengthFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIngredient_StrengthToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductIngredient_ReferenceStrength {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Relevant reference substance.
CodeableConcept substance;

//  Strength expressed in terms of a reference substance.
Ratio strength;

//  Strength expressed in terms of a reference substance.
Ratio strengthLowLimit;

//  For when strength is measured at a particular point or distance.
String measurementPoint;

//  The country or countries for which the strength range applies.
List<CodeableConcept> country;

MedicinalProductIngredient_ReferenceStrength(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.substance,
    this.strength,
    this.strengthLowLimit,
    this.measurementPoint,
    this.country,
    });

  factory MedicinalProductIngredient_ReferenceStrength.fromJson(Map<String, dynamic> json) => _$MedicinalProductIngredient_ReferenceStrengthFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIngredient_ReferenceStrengthToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductIngredient_Substance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The ingredient substance.
CodeableConcept code;

//  Quantity of the substance or specified substance present in the
// manufactured item or pharmaceutical product.
List<MedicinalProductIngredient_Strength> strength;

MedicinalProductIngredient_Substance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.strength,
    });

  factory MedicinalProductIngredient_Substance.fromJson(Map<String, dynamic> json) => _$MedicinalProductIngredient_SubstanceFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductIngredient_SubstanceToJson(this);
}

part 'medicinalProductInteraction.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductInteraction {

//  This is a MedicinalProductInteraction resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The medication for which this is a described interaction.
List<Reference> subject;

//  The interaction described.
String description;

//  The specific medication, food or laboratory test that interacts.
List<MedicinalProductInteraction_Interactant> interactant;

//  The type of the interaction e.g. drug-drug interaction, drug-food
// interaction, drug-lab test interaction.
CodeableConcept type;

//  The effect of the interaction, for example "reduced gastric absorption
// of primary medication".
CodeableConcept effect;

//  The incidence of the interaction, e.g. theoretical, observed.
CodeableConcept incidence;

//  Actions for managing the interaction.
CodeableConcept management;

MedicinalProductInteraction(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.subject,
    this.description,
    this.interactant,
    this.type,
    this.effect,
    this.incidence,
    this.management,
    });

  factory MedicinalProductInteraction.fromJson(Map<String, dynamic> json) => _$MedicinalProductInteractionFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductInteractionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductInteraction_Interactant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The specific medication, food or laboratory test that interacts.
Reference itemReference;

//  The specific medication, food or laboratory test that interacts.
CodeableConcept itemCodeableConcept;

MedicinalProductInteraction_Interactant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.itemReference,
    this.itemCodeableConcept,
    });

  factory MedicinalProductInteraction_Interactant.fromJson(Map<String, dynamic> json) => _$MedicinalProductInteraction_InteractantFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductInteraction_InteractantToJson(this);
}

part 'medicinalProductManufactured.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductManufactured {

//  This is a MedicinalProductManufactured resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Dose form as manufactured and before any transformation into the
// pharmaceutical product.
CodeableConcept manufacturedDoseForm;

//  The real world units in which the quantity of the manufactured item
// is described.
CodeableConcept unitOfPresentation;

//  The quantity or "count number" of the manufactured item.
Quantity quantity;

//  Manufacturer of the item (Note that this should be named
// "manufacturer" but it currently causes technical issues).
List<Reference> manufacturer;

//  Ingredient.
List<Reference> ingredient;

//  Dimensions, color etc.
ProdCharacteristic physicalCharacteristics;

//  Other codeable characteristics.
List<CodeableConcept> otherCharacteristics;

MedicinalProductManufactured(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.manufacturedDoseForm,
    this.unitOfPresentation,
    this.quantity,
    this.manufacturer,
    this.ingredient,
    this.physicalCharacteristics,
    this.otherCharacteristics,
    });

  factory MedicinalProductManufactured.fromJson(Map<String, dynamic> json) => _$MedicinalProductManufacturedFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductManufacturedToJson(this);
}

part 'medicinalProductPackaged.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductPackaged {

//  This is a MedicinalProductPackaged resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier.
List<Identifier> identifier;

//  The product with this is a pack for.
List<Reference> subject;

//  Textual description.
String description;

//  The legal status of supply of the medicinal product as classified by
// the regulator.
CodeableConcept legalStatusOfSupply;

//  Marketing information.
List<MarketingStatus> marketingStatus;

//  Manufacturer of this Package Item.
Reference marketingAuthorization;

//  Manufacturer of this Package Item.
List<Reference> manufacturer;

//  Batch numbering.
List<MedicinalProductPackaged_BatchIdentifier> batchIdentifier;

//  A packaging item, as a contained for medicine, possibly with other
// packaging items within.
List<MedicinalProductPackaged_PackageItem> packageItem;

MedicinalProductPackaged(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.subject,
    this.description,
    this.legalStatusOfSupply,
    this.marketingStatus,
    this.marketingAuthorization,
    this.manufacturer,
    this.batchIdentifier,
    this.packageItem,
    });

  factory MedicinalProductPackaged.fromJson(Map<String, dynamic> json) => _$MedicinalProductPackagedFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPackagedToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPackaged_BatchIdentifier {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A number appearing on the outer packaging of a specific batch.
Identifier outerPackaging;

//  A number appearing on the immediate packaging (and not the outer
// packaging).
Identifier immediatePackaging;

MedicinalProductPackaged_BatchIdentifier(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.outerPackaging,
    this.immediatePackaging,
    });

  factory MedicinalProductPackaged_BatchIdentifier.fromJson(Map<String, dynamic> json) => _$MedicinalProductPackaged_BatchIdentifierFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPackaged_BatchIdentifierToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPackaged_PackageItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Including possibly Data Carrier Identifier.
List<Identifier> identifier;

//  The physical type of the container of the medicine.
CodeableConcept type;

//  The quantity of this package in the medicinal product, at the current
// level of packaging. The outermost is always 1.
Quantity quantity;

//  Material type of the package item.
List<CodeableConcept> material;

//  A possible alternate material for the packaging.
List<CodeableConcept> alternateMaterial;

//  A device accompanying a medicinal product.
List<Reference> device;

//  The manufactured item as contained in the packaged medicinal product.
List<Reference> manufacturedItem;

//  Allows containers within containers.
List<MedicinalProductPackaged_PackageItem> packageItem;

//  Dimensions, color etc.
ProdCharacteristic physicalCharacteristics;

//  Other codeable characteristics.
List<CodeableConcept> otherCharacteristics;

//  Shelf Life and storage information.
List<ProductShelfLife> shelfLifeStorage;

//  Manufacturer of this Package Item.
List<Reference> manufacturer;

MedicinalProductPackaged_PackageItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.quantity,
    this.material,
    this.alternateMaterial,
    this.device,
    this.manufacturedItem,
    this.packageItem,
    this.physicalCharacteristics,
    this.otherCharacteristics,
    this.shelfLifeStorage,
    this.manufacturer,
    });

  factory MedicinalProductPackaged_PackageItem.fromJson(Map<String, dynamic> json) => _$MedicinalProductPackaged_PackageItemFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPackaged_PackageItemToJson(this);
}

part 'medicinalProductPharmaceutical.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductPharmaceutical {

//  This is a MedicinalProductPharmaceutical resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier for the pharmaceutical medicinal product.
List<Identifier> identifier;

//  The administrable dose form, after necessary reconstitution.
CodeableConcept administrableDoseForm;

//  Todo.
CodeableConcept unitOfPresentation;

//  Ingredient.
List<Reference> ingredient;

//  Accompanying device.
List<Reference> device;

//  Characteristics e.g. a products onset of action.
List<MedicinalProductPharmaceutical_Characteristics> characteristics;

//  The path by which the pharmaceutical product is taken into or makes
// contact with the body.
List<MedicinalProductPharmaceutical_RouteOfAdministration> routeOfAdministration;

MedicinalProductPharmaceutical(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.administrableDoseForm,
    this.unitOfPresentation,
    this.ingredient,
    this.device,
    this.characteristics,
    this.routeOfAdministration,
    });

  factory MedicinalProductPharmaceutical.fromJson(Map<String, dynamic> json) => _$MedicinalProductPharmaceuticalFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPharmaceuticalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPharmaceutical_Characteristics {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A coded characteristic.
CodeableConcept code;

//  The status of characteristic e.g. assigned or pending.
CodeableConcept status;

MedicinalProductPharmaceutical_Characteristics(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.status,
    });

  factory MedicinalProductPharmaceutical_Characteristics.fromJson(Map<String, dynamic> json) => _$MedicinalProductPharmaceutical_CharacteristicsFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPharmaceutical_CharacteristicsToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPharmaceutical_RouteOfAdministration {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Coded expression for the route.
CodeableConcept code;

//  The first dose (dose quantity) administered in humans can be
// specified, for a product under investigation, using a numerical value
// and its unit of measurement.
Quantity firstDose;

//  The maximum single dose that can be administered as per the protocol
// of a clinical trial can be specified using a numerical value and its
// unit of measurement.
Quantity maxSingleDose;

//  The maximum dose per day (maximum dose quantity to be administered in
// any one 24-h period) that can be administered as per the protocol
// referenced in the clinical trial authorisation.
Quantity maxDosePerDay;

//  The maximum dose per treatment period that can be administered as per
// the protocol referenced in the clinical trial authorisation.
Ratio maxDosePerTreatmentPeriod;

//  The maximum treatment period during which an Investigational Medicinal
// Product can be administered as per the protocol referenced in the
// clinical trial authorisation.
Duration maxTreatmentPeriod;

//  A species for which this route applies.
List<MedicinalProductPharmaceutical_TargetSpecies> targetSpecies;

MedicinalProductPharmaceutical_RouteOfAdministration(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.firstDose,
    this.maxSingleDose,
    this.maxDosePerDay,
    this.maxDosePerTreatmentPeriod,
    this.maxTreatmentPeriod,
    this.targetSpecies,
    });

  factory MedicinalProductPharmaceutical_RouteOfAdministration.fromJson(Map<String, dynamic> json) => _$MedicinalProductPharmaceutical_RouteOfAdministrationFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPharmaceutical_RouteOfAdministrationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPharmaceutical_TargetSpecies {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Coded expression for the species.
CodeableConcept code;

//  A species specific time during which consumption of animal product is
// not appropriate.
List<MedicinalProductPharmaceutical_WithdrawalPeriod> withdrawalPeriod;

MedicinalProductPharmaceutical_TargetSpecies(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.withdrawalPeriod,
    });

  factory MedicinalProductPharmaceutical_TargetSpecies.fromJson(Map<String, dynamic> json) => _$MedicinalProductPharmaceutical_TargetSpeciesFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPharmaceutical_TargetSpeciesToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MedicinalProductPharmaceutical_WithdrawalPeriod {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Coded expression for the type of tissue for which the withdrawal
// period applues, e.g. meat, milk.
CodeableConcept tissue;

//  A value for the time.
Quantity value;

//  Extra information about the withdrawal period.
String supportingInformation;

MedicinalProductPharmaceutical_WithdrawalPeriod(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.tissue,
    this.value,
    this.supportingInformation,
    });

  factory MedicinalProductPharmaceutical_WithdrawalPeriod.fromJson(Map<String, dynamic> json) => _$MedicinalProductPharmaceutical_WithdrawalPeriodFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductPharmaceutical_WithdrawalPeriodToJson(this);
}

part 'medicinalProductUndesirableEffect.g.dart';

@JsonSerializable(explicitToJson: true)
class MedicinalProductUndesirableEffect {

//  This is a MedicinalProductUndesirableEffect resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The medication for which this is an indication.
List<Reference> subject;

//  The symptom, condition or undesirable effect.
CodeableConcept symptomConditionEffect;

//  Classification of the effect.
CodeableConcept classification;

//  The frequency of occurrence of the effect.
CodeableConcept frequencyOfOccurrence;

//  The population group to which this applies.
List<Population> population;

MedicinalProductUndesirableEffect(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.subject,
    this.symptomConditionEffect,
    this.classification,
    this.frequencyOfOccurrence,
    this.population,
    });

  factory MedicinalProductUndesirableEffect.fromJson(Map<String, dynamic> json) => _$MedicinalProductUndesirableEffectFromJson(json);
  Map<String, dynamic> toJson() => _$MedicinalProductUndesirableEffectToJson(this);
}

part 'messageDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class MessageDefinition {

//  This is a MessageDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The business identifier that is used to reference the
// MessageDefinition and *is* expected to be consistent from server to
// server.
String url;

//  A formal identifier that is used to identify this message definition
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the message
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the message definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the message definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the message definition.
String title;

//  A MessageDefinition that is superseded by this definition.
List<String> replaces;

//  The status of this message definition. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this message definition is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the message definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the message definition changes.
DateTime date;

//  The name of the organization or individual that published the message
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the message definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate message definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the message definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this message definition is needed and why it has
// been designed as it has.
String purpose;

//  A copyright statement relating to the message definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the message definition.
String copyright;

//  The MessageDefinition that is the basis for the contents of this
// resource.
String base;

//  Identifies a protocol or workflow that this MessageDefinition
// represents a step in.
List<String> parent;

//  Event code or link to the EventDefinition.
Coding eventCoding;

//  Event code or link to the EventDefinition.
String eventUri; //  pattern: ^\S*$

//  The impact of the content of the message.
String category; // <code> enum: consequence/currency/notification;

//  Identifies the resource (or resources) that are being addressed by the
// event.  For example, the Encounter for an admit message or two Account
// records for a merge.
List<MessageDefinition_Focus> focus;

//  Declare at a message definition level whether a response is required
// or only upon error or success, or never.
String responseRequired; // <code> enum: always/on-error/never/on-success;

//  Indicates what types of messages may be sent as an application-level
// response to this message.
List<MessageDefinition_AllowedResponse> allowedResponse;

//  Canonical reference to a GraphDefinition. If a URL is provided, it is
// the canonical reference to a [[[GraphDefinition]]] that it controls
// what resources are to be added to the bundle when building the
// document. The GraphDefinition can also specify profiles that apply to
// the various resources.
List<String> graph;

MessageDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.replaces,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.base,
    this.parent,
    this.eventCoding,
    this.eventUri,
    this.category,
    this.focus,
    this.responseRequired,
    this.allowedResponse,
    this.graph,
    });

  factory MessageDefinition.fromJson(Map<String, dynamic> json) => _$MessageDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$MessageDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MessageDefinition_Focus {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of resource that must be the focus for this message.
String code;

//  A profile that reflects constraints for the focal resource (and
// potentially for related resources).
String profile;

//  Identifies the minimum number of resources of this type that must be
// pointed to by a message in order for it to be valid against this
// MessageDefinition.
int min;

//  Identifies the maximum number of resources of this type that must be
// pointed to by a message in order for it to be valid against this
// MessageDefinition.
String max;

MessageDefinition_Focus(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.profile,
    this.min,
    this.max,
    });

  factory MessageDefinition_Focus.fromJson(Map<String, dynamic> json) => _$MessageDefinition_FocusFromJson(json);
  Map<String, dynamic> toJson() => _$MessageDefinition_FocusToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MessageDefinition_AllowedResponse {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A reference to the message definition that must be adhered to by this
// supported response.
String message;

//  Provides a description of the circumstances in which this response
// should be used (as opposed to one of the alternative responses).
String situation;

MessageDefinition_AllowedResponse(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.message,
    this.situation,
    });

  factory MessageDefinition_AllowedResponse.fromJson(Map<String, dynamic> json) => _$MessageDefinition_AllowedResponseFromJson(json);
  Map<String, dynamic> toJson() => _$MessageDefinition_AllowedResponseToJson(this);
}

part 'messageHeader.g.dart';

@JsonSerializable(explicitToJson: true)
class MessageHeader {

//  This is a MessageHeader resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Code that identifies the event this message represents and connects it
// with its definition. Events defined as part of the FHIR specification
// have the system value
// "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively
// uri to the EventDefinition.
Coding eventCoding;

//  Code that identifies the event this message represents and connects it
// with its definition. Events defined as part of the FHIR specification
// have the system value
// "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively
// uri to the EventDefinition.
String eventUri; //  pattern: ^\S*$

//  The destination application which the message is intended for.
List<MessageHeader_Destination> destination;

//  Identifies the sending system to allow the use of a trust
// relationship.
Reference sender;

//  The person or device that performed the data entry leading to this
// message. When there is more than one candidate, pick the most proximal
// to the message. Can provide other enterers in extensions.
Reference enterer;

//  The logical author of the message - the person or device that decided
// the described event should happen. When there is more than one
// candidate, pick the most proximal to the MessageHeader. Can provide
// other authors in extensions.
Reference author;

//  The source application from which this message originated.
MessageHeader_Source source;

//  The person or organization that accepts overall responsibility for the
// contents of the message. The implication is that the message event
// happened under the policies of the responsible party.
Reference responsible;

//  Coded indication of the cause for the event - indicates  a reason for
// the occurrence of the event that is a focus of this message.
CodeableConcept reason;

//  Information about the message that this message is a response to. 
// Only present if this message is a response.
MessageHeader_Response response;

//  The actual data of the message - a reference to the root/focus class
// of the event.
List<Reference> focus;

//  Permanent link to the MessageDefinition for this message.
String definition;

MessageHeader(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.eventCoding,
    this.eventUri,
    this.destination,
    this.sender,
    this.enterer,
    this.author,
    this.source,
    this.responsible,
    this.reason,
    this.response,
    this.focus,
    this.definition,
    });

  factory MessageHeader.fromJson(Map<String, dynamic> json) => _$MessageHeaderFromJson(json);
  Map<String, dynamic> toJson() => _$MessageHeaderToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MessageHeader_Destination {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable name for the target system.
String name;

//  Identifies the target end system in situations where the initial
// message transmission is to an intermediary system.
Reference target;

//  Indicates where the message should be routed to.
String endpoint;

//  Allows data conveyed by a message to be addressed to a particular
// person or department when routing to a specific application isn't
// sufficient.
Reference receiver;

MessageHeader_Destination(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.target,
    this.endpoint,
    this.receiver,
    });

  factory MessageHeader_Destination.fromJson(Map<String, dynamic> json) => _$MessageHeader_DestinationFromJson(json);
  Map<String, dynamic> toJson() => _$MessageHeader_DestinationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MessageHeader_Source {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable name for the source system.
String name;

//  May include configuration or other information useful in debugging.
String software;

//  Can convey versions of multiple systems in situations where a message
// passes through multiple hands.
String version;

//  An e-mail, phone, website or other contact point to use to resolve
// issues with message communications.
ContactPoint contact;

//  Identifies the routing target to send acknowledgements to.
String endpoint;

MessageHeader_Source(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.software,
    this.version,
    this.contact,
    this.endpoint,
    });

  factory MessageHeader_Source.fromJson(Map<String, dynamic> json) => _$MessageHeader_SourceFromJson(json);
  Map<String, dynamic> toJson() => _$MessageHeader_SourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MessageHeader_Response {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The MessageHeader.id of the message to which this message is a
// response.
String identifier;

//  Code that identifies the type of response to the message - whether it
// was successful or not, and whether it should be resent or not.
String code; // <code> enum: ok/transient-error/fatal-error;

//  Full details of any issues found in the message.
Reference details;

MessageHeader_Response(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.code,
    this.details,
    });

  factory MessageHeader_Response.fromJson(Map<String, dynamic> json) => _$MessageHeader_ResponseFromJson(json);
  Map<String, dynamic> toJson() => _$MessageHeader_ResponseToJson(this);
}

part 'molecularSequence.g.dart';

@JsonSerializable(explicitToJson: true)
class MolecularSequence {

//  This is a MolecularSequence resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier for this particular sequence instance. This is a
// FHIR-defined id.
List<Identifier> identifier;

//  Amino Acid Sequence/ DNA Sequence / RNA Sequence.
String type; // <code> enum: aa/dna/rna;

//  Whether the sequence is numbered starting at 0 (0-based numbering or
// coordinates, inclusive start, exclusive end) or starting at 1 (1-based
// numbering, inclusive start and inclusive end).
int coordinateSystem;

//  The patient whose sequencing results are described by this resource.
Reference patient;

//  Specimen used for sequencing.
Reference specimen;

//  The method for sequencing, for example, chip information.
Reference device;

//  The organization or lab that should be responsible for this result.
Reference performer;

//  The number of copies of the sequence of interest. (RNASeq).
Quantity quantity;

//  A sequence that is used as a reference to describe variants that are
// present in a sequence analyzed.
MolecularSequence_ReferenceSeq referenceSeq;

//  The definition of variant here originates from Sequence ontology
// ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)).
// This element can represent amino acid or nucleic sequence
// change(including insertion,deletion,SNP,etc.)  It can represent some
// complex mutation or segment variation with the assist of CIGAR string.
List<MolecularSequence_Variant> variant;

//  Sequence that was observed. It is the result marked by referenceSeq
// along with variant records on referenceSeq. This shall start from
// referenceSeq.windowStart and end by referenceSeq.windowEnd.
String observedSeq;

//  An experimental feature attribute that defines the quality of the
// feature in a quantitative way, such as a phred quality score
// ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
List<MolecularSequence_Quality> quality;

//  Coverage (read depth or depth) is the average number of reads
// representing a given nucleotide in the reconstructed sequence.
int readCoverage;

//  Configurations of the external repository. The repository shall store
// target's observedSeq or records related with target's observedSeq.
List<MolecularSequence_Repository> repository;

//  Pointer to next atomic sequence which at most contains one variant.
List<Reference> pointer;

//  Information about chromosome structure variation.
List<MolecularSequence_StructureVariant> structureVariant;

MolecularSequence(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.coordinateSystem,
    this.patient,
    this.specimen,
    this.device,
    this.performer,
    this.quantity,
    this.referenceSeq,
    this.variant,
    this.observedSeq,
    this.quality,
    this.readCoverage,
    this.repository,
    this.pointer,
    this.structureVariant,
    });

  factory MolecularSequence.fromJson(Map<String, dynamic> json) => _$MolecularSequenceFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequenceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_ReferenceSeq {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Structural unit composed of a nucleic acid molecule which controls its
// own replication through the interaction of specific proteins at one or
// more origins of replication
// ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
CodeableConcept chromosome;

//  The Genome Build used for reference, following GRCh build versions
// e.g. 'GRCh 37'.  Version number must be included if a versioned release
// of a primary build was used.
String genomeBuild;

//  A relative reference to a DNA strand based on gene orientation. The
// strand that contains the open reading frame of the gene is the "sense"
// strand, and the opposite complementary strand is the "antisense"
// strand.
String orientation; // <code> enum: sense/antisense;

//  Reference identifier of reference sequence submitted to NCBI. It must
// match the type in the MolecularSequence.type field. For example, the
// prefix, NG_ identifies reference sequence for genes, NM_ for
// messenger RNA transcripts, and NP_ for amino acid sequences.
CodeableConcept referenceSeqId;

//  A pointer to another MolecularSequence entity as reference sequence.
Reference referenceSeqPointer;

//  A string like "ACGT".
String referenceSeqString;

//  An absolute reference to a strand. The Watson strand is the strand
// whose 5'-end is on the short arm of the chromosome, and the Crick
// strand as the one whose 5'-end is on the long arm.
String strand; // <code> enum: watson/crick;

//  Start position of the window on the reference sequence. If the
// coordinate system is either 0-based or 1-based, then start position is
// inclusive.
int windowStart;

//  End position of the window on the reference sequence. If the
// coordinate system is 0-based then end is exclusive and does not include
// the last position. If the coordinate system is 1-base, then end is
// inclusive and includes the last position.
int windowEnd;

MolecularSequence_ReferenceSeq(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.chromosome,
    this.genomeBuild,
    this.orientation,
    this.referenceSeqId,
    this.referenceSeqPointer,
    this.referenceSeqString,
    this.strand,
    this.windowStart,
    this.windowEnd,
    });

  factory MolecularSequence_ReferenceSeq.fromJson(Map<String, dynamic> json) => _$MolecularSequence_ReferenceSeqFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_ReferenceSeqToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Variant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Start position of the variant on the  reference sequence. If the
// coordinate system is either 0-based or 1-based, then start position is
// inclusive.
int start;

//  End position of the variant on the reference sequence. If the
// coordinate system is 0-based then end is exclusive and does not include
// the last position. If the coordinate system is 1-base, then end is
// inclusive and includes the last position.
int end;

//  An allele is one of a set of coexisting sequence variants of a gene
// ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
//  Nucleotide(s)/amino acids from start position of sequence to stop
// position of sequence on the positive (+) strand of the observed 
// sequence. When the sequence  type is DNA, it should be the sequence on
// the positive (+) strand. This will lay in the range between
// variant.start and variant.end.
String observedAllele;

//  An allele is one of a set of coexisting sequence variants of a gene
// ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
// Nucleotide(s)/amino acids from start position of sequence to stop
// position of sequence on the positive (+) strand of the reference
// sequence. When the sequence  type is DNA, it should be the sequence on
// the positive (+) strand. This will lay in the range between
// variant.start and variant.end.
String referenceAllele;

//  Extended CIGAR string for aligning the sequence with reference bases.
// See detailed documentation
// [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
String cigar;

//  A pointer to an Observation containing variant information.
Reference variantPointer;

MolecularSequence_Variant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.start,
    this.end,
    this.observedAllele,
    this.referenceAllele,
    this.cigar,
    this.variantPointer,
    });

  factory MolecularSequence_Variant.fromJson(Map<String, dynamic> json) => _$MolecularSequence_VariantFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_VariantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Quality {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  INDEL / SNP / Undefined variant.
String type; // <code> enum: indel/snp/unknown;

//  Gold standard sequence used for comparing against.
CodeableConcept standardSequence;

//  Start position of the sequence. If the coordinate system is either
// 0-based or 1-based, then start position is inclusive.
int start;

//  End position of the sequence. If the coordinate system is 0-based then
// end is exclusive and does not include the last position. If the
// coordinate system is 1-base, then end is inclusive and includes the
// last position.
int end;

//  The score of an experimentally derived feature such as a p-value
// ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
Quantity score;

//  Which method is used to get sequence quality.
CodeableConcept method;

//  True positives, from the perspective of the truth data, i.e. the
// number of sites in the Truth Call Set for which there are paths through
// the Query Call Set that are consistent with all of the alleles at this
// site, and for which there is an accurate genotype call for the event.
double truthTP;

//  True positives, from the perspective of the query data, i.e. the
// number of sites in the Query Call Set for which there are paths through
// the Truth Call Set that are consistent with all of the alleles at this
// site, and for which there is an accurate genotype call for the event.
double queryTP;

//  False negatives, i.e. the number of sites in the Truth Call Set for
// which there is no path through the Query Call Set that is consistent
// with all of the alleles at this site, or sites for which there is an
// inaccurate genotype call for the event. Sites with correct variant but
// incorrect genotype are counted here.
double truthFN;

//  False positives, i.e. the number of sites in the Query Call Set for
// which there is no path through the Truth Call Set that is consistent
// with this site. Sites with correct variant but incorrect genotype are
// counted here.
double queryFP;

//  The number of false positives where the non-REF alleles in the Truth
// and Query Call Sets match (i.e. cases where the truth is 1/1 and the
// query is 0/1 or similar).
double gtFP;

//  QUERY.TP / (QUERY.TP + QUERY.FP).
double precision;

//  TRUTH.TP / (TRUTH.TP + TRUTH.FN).
double recall;

//  Harmonic mean of Recall and Precision, computed as: 2 * precision *
// recall / (precision + recall).
double fScore;

//  Receiver Operator Characteristic (ROC) Curve  to give
// sensitivity/specificity tradeoff.
MolecularSequence_Roc roc;

MolecularSequence_Quality(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.standardSequence,
    this.start,
    this.end,
    this.score,
    this.method,
    this.truthTP,
    this.queryTP,
    this.truthFN,
    this.queryFP,
    this.gtFP,
    this.precision,
    this.recall,
    this.fScore,
    this.roc,
    });

  factory MolecularSequence_Quality.fromJson(Map<String, dynamic> json) => _$MolecularSequence_QualityFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_QualityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Roc {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Invidual data point representing the GQ (genotype quality) score
// threshold.
List<int> score;

//  The number of true positives if the GQ score threshold was set to
// "score" field value.
List<int> numTP;

//  The number of false positives if the GQ score threshold was set to
// "score" field value.
List<int> numFP;

//  The number of false negatives if the GQ score threshold was set to
// "score" field value.
List<int> numFN;

//  Calculated precision if the GQ score threshold was set to "score"
// field value.
List<double> precision;

//  Calculated sensitivity if the GQ score threshold was set to "score"
// field value.
List<double> sensitivity;

//  Calculated fScore if the GQ score threshold was set to "score" field
// value.
List<double> fMeasure;

MolecularSequence_Roc(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.score,
    this.numTP,
    this.numFP,
    this.numFN,
    this.precision,
    this.sensitivity,
    this.fMeasure,
    });

  factory MolecularSequence_Roc.fromJson(Map<String, dynamic> json) => _$MolecularSequence_RocFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_RocToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Repository {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Click and see / RESTful API / Need login to see / RESTful API with
// authentication / Other ways to see resource.
String type; // <code> enum: directlink/openapi/login/oauth/other;

//  URI of an external repository which contains further details about the
// genetics data.
String url;

//  URI of an external repository which contains further details about the
// genetics data.
String name;

//  Id of the variant in this external repository. The server will
// understand how to use this id to call for more info about datasets in
// external repository.
String datasetId;

//  Id of the variantset in this external repository. The server will
// understand how to use this id to call for more info about variantsets
// in external repository.
String variantsetId;

//  Id of the read in this external repository.
String readsetId;

MolecularSequence_Repository(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.url,
    this.name,
    this.datasetId,
    this.variantsetId,
    this.readsetId,
    });

  factory MolecularSequence_Repository.fromJson(Map<String, dynamic> json) => _$MolecularSequence_RepositoryFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_RepositoryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_StructureVariant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Information about chromosome structure variation DNA change type.
CodeableConcept variantType;

//  Used to indicate if the outer and inner start-end values have the same
// meaning.
bool exact;

//  Length of the variant chromosome.
int length;

//  Structural variant outer.
MolecularSequence_Outer outer;

//  Structural variant inner.
MolecularSequence_Inner inner;

MolecularSequence_StructureVariant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.variantType,
    this.exact,
    this.length,
    this.outer,
    this.inner,
    });

  factory MolecularSequence_StructureVariant.fromJson(Map<String, dynamic> json) => _$MolecularSequence_StructureVariantFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_StructureVariantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Outer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Structural variant outer start. If the coordinate system is either
// 0-based or 1-based, then start position is inclusive.
int start;

//  Structural variant outer end. If the coordinate system is 0-based then
// end is exclusive and does not include the last position. If the
// coordinate system is 1-base, then end is inclusive and includes the
// last position.
int end;

MolecularSequence_Outer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.start,
    this.end,
    });

  factory MolecularSequence_Outer.fromJson(Map<String, dynamic> json) => _$MolecularSequence_OuterFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_OuterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class MolecularSequence_Inner {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Structural variant inner start. If the coordinate system is either
// 0-based or 1-based, then start position is inclusive.
int start;

//  Structural variant inner end. If the coordinate system is 0-based then
// end is exclusive and does not include the last position. If the
// coordinate system is 1-base, then end is inclusive and includes the
// last position.
int end;

MolecularSequence_Inner(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.start,
    this.end,
    });

  factory MolecularSequence_Inner.fromJson(Map<String, dynamic> json) => _$MolecularSequence_InnerFromJson(json);
  Map<String, dynamic> toJson() => _$MolecularSequence_InnerToJson(this);
}

part 'namingSystem.g.dart';

@JsonSerializable(explicitToJson: true)
class NamingSystem {

//  This is a NamingSystem resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A natural language name identifying the naming system. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  The status of this naming system. Enables tracking the life-cycle of
// the content.
String status; // <code> enum: draft/active/retired/unknown;

//  Indicates the purpose for the naming system - what kinds of things
// does it make unique?
String kind; // <code> enum: codesystem/identifier/root;

//  The date  (and optionally time) when the naming system was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the naming system changes.
DateTime date;

//  The name of the organization or individual that published the naming
// system.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  The name of the organization that is responsible for issuing
// identifiers or codes for this namespace and ensuring their
// non-collision.
String responsible;

//  Categorizes a naming system for easier search by grouping related
// naming systems.
CodeableConcept type;

//  A free text natural language description of the naming system from a
// consumer's perspective. Details about what the namespace identifies
// including scope, granularity, version labeling, etc.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate naming system instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the naming system is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Provides guidance on the use of the namespace, including the handling
// of formatting characters, use of upper vs. lower case, etc.
String usage;

//  Indicates how the system may be identified when referenced in
// electronic exchange.
List<NamingSystem_UniqueId> uniqueId;

NamingSystem(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.name,
    this.status,
    this.kind,
    this.date,
    this.publisher,
    this.contact,
    this.responsible,
    this.type,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.usage,
    this.uniqueId,
    });

  factory NamingSystem.fromJson(Map<String, dynamic> json) => _$NamingSystemFromJson(json);
  Map<String, dynamic> toJson() => _$NamingSystemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NamingSystem_UniqueId {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies the unique identifier scheme used for this particular
// identifier.
String type; // <code> enum: oid/uuid/uri/other;

//  The string that should be sent over the wire to identify the code
// system or identifier system.
String value;

//  Indicates whether this identifier is the "preferred" identifier of
// this type.
bool preferred;

//  Notes about the past or intended usage of this identifier.
String comment;

//  Identifies the period of time over which this identifier is considered
// appropriate to refer to the naming system.  Outside of this window, the
// identifier might be non-deterministic.
Period period;

NamingSystem_UniqueId(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.value,
    this.preferred,
    this.comment,
    this.period,
    });

  factory NamingSystem_UniqueId.fromJson(Map<String, dynamic> json) => _$NamingSystem_UniqueIdFromJson(json);
  Map<String, dynamic> toJson() => _$NamingSystem_UniqueIdToJson(this);
}

part 'nutritionOrder.g.dart';

@JsonSerializable(explicitToJson: true)
class NutritionOrder {

//  This is a NutritionOrder resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this order by the order sender or by the order
// receiver.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this
// NutritionOrder.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this NutritionOrder.
List<String> instantiatesUri;

//  The URL pointing to a protocol, guideline, orderset or other
// definition that is adhered to in whole or in part by this
// NutritionOrder.
List<String> instantiates;

//  The workflow status of the nutrition order/request.
String status;

//  Indicates the level of authority/intentionality associated with the
// NutrionOrder and where the request fits into the workflow chain.
String intent;

//  The person (patient) who needs the nutrition order for an oral diet,
// nutritional supplement and/or enteral or formula feeding.
Reference patient;

//  An encounter that provides additional information about the healthcare
// context in which this request is made.
Reference encounter;

//  The date and time that this nutrition order was requested.
DateTime dateTime;

//  The practitioner that holds legal responsibility for ordering the
// diet, nutritional supplement, or formula feedings.
Reference orderer;

//  A link to a record of allergies or intolerances  which should be
// included in the nutrition order.
List<Reference> allergyIntolerance;

//  This modifier is used to convey order-specific modifiers about the
// type of food that should be given. These can be derived from patient
// allergies, intolerances, or preferences such as Halal, Vegan or Kosher.
// This modifier applies to the entire nutrition order inclusive of the
// oral diet, nutritional supplements and enteral formula feedings.
List<CodeableConcept> foodPreferenceModifier;

//  This modifier is used to convey Order-specific modifier about the type
// of oral food or oral fluids that should not be given. These can be
// derived from patient allergies, intolerances, or preferences such as No
// Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be
// necessary to repeat allergy or intolerance information captured in the
// referenced AllergyIntolerance resource in the excludeFoodModifier, this
// element may be used to convey additional specificity related to foods
// that should be eliminated from the patients diet for any reason.  This
// modifier applies to the entire nutrition order inclusive of the oral
// diet, nutritional supplements and enteral formula feedings.
List<CodeableConcept> excludeFoodModifier;

//  Diet given orally in contrast to enteral (tube) feeding.
NutritionOrder_OralDiet oralDiet;

//  Oral nutritional products given in order to add further nutritional
// value to the patient's diet.
List<NutritionOrder_Supplement> supplement;

//  Feeding provided through the gastrointestinal tract via a tube,
// catheter, or stoma that delivers nutrition distal to the oral cavity.
NutritionOrder_EnteralFormula enteralFormula;

//  Comments made about the {{title}} by the requester, performer, subject
// or other participants.
List<Annotation> note;

NutritionOrder(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.instantiates,
    this.status,
    this.intent,
    this.patient,
    this.encounter,
    this.dateTime,
    this.orderer,
    this.allergyIntolerance,
    this.foodPreferenceModifier,
    this.excludeFoodModifier,
    this.oralDiet,
    this.supplement,
    this.enteralFormula,
    this.note,
    });

  factory NutritionOrder.fromJson(Map<String, dynamic> json) => _$NutritionOrderFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrderToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_OralDiet {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of diet or dietary restriction such as fiber restricted diet
// or diabetic diet.
List<CodeableConcept> type;

//  The time period and frequency at which the diet should be given.  The
// diet should be given for the combination of all schedules if more than
// one schedule is present.
List<Timing> schedule;

//  Class that defines the quantity and type of nutrient modifications
// (for example carbohydrate, fiber or sodium) required for the oral diet.
List<NutritionOrder_Nutrient> nutrient;

//  Class that describes any texture modifications required for the
// patient to safely consume various types of solid foods.
List<NutritionOrder_Texture> texture;

//  The required consistency (e.g. honey-thick, nectar-thick, thin,
// thickened.) of liquids or fluids served to the patient.
List<CodeableConcept> fluidConsistencyType;

//  Free text or additional instructions or information pertaining to the
// oral diet.
String instruction;

NutritionOrder_OralDiet(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.schedule,
    this.nutrient,
    this.texture,
    this.fluidConsistencyType,
    this.instruction,
    });

  factory NutritionOrder_OralDiet.fromJson(Map<String, dynamic> json) => _$NutritionOrder_OralDietFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_OralDietToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_Nutrient {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The nutrient that is being modified such as carbohydrate or sodium.
CodeableConcept modifier;

//  The quantity of the specified nutrient to include in diet.
Quantity amount;

NutritionOrder_Nutrient(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.modifier,
    this.amount,
    });

  factory NutritionOrder_Nutrient.fromJson(Map<String, dynamic> json) => _$NutritionOrder_NutrientFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_NutrientToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_Texture {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Any texture modifications (for solid foods) that should be made, e.g.
// easy to chew, chopped, ground, and pureed.
CodeableConcept modifier;

//  The food type(s) (e.g. meats, all foods)  that the texture
// modification applies to.  This could be all foods types.
CodeableConcept foodType;

NutritionOrder_Texture(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.modifier,
    this.foodType,
    });

  factory NutritionOrder_Texture.fromJson(Map<String, dynamic> json) => _$NutritionOrder_TextureFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_TextureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_Supplement {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of nutritional supplement product required such as a high
// protein or pediatric clear liquid supplement.
CodeableConcept type;

//  The product or brand name of the nutritional supplement such as "Acme
// Protein Shake".
String productName;

//  The time period and frequency at which the supplement(s) should be
// given.  The supplement should be given for the combination of all
// schedules if more than one schedule is present.
List<Timing> schedule;

//  The amount of the nutritional supplement to be given.
Quantity quantity;

//  Free text or additional instructions or information pertaining to the
// oral supplement.
String instruction;

NutritionOrder_Supplement(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.productName,
    this.schedule,
    this.quantity,
    this.instruction,
    });

  factory NutritionOrder_Supplement.fromJson(Map<String, dynamic> json) => _$NutritionOrder_SupplementFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_SupplementToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_EnteralFormula {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of enteral or infant formula such as an adult standard
// formula with fiber or a soy-based infant formula.
CodeableConcept baseFormulaType;

//  The product or brand name of the enteral or infant formula product
// such as "ACME Adult Standard Formula".
String baseFormulaProductName;

//  Indicates the type of modular component such as protein, carbohydrate,
// fat or fiber to be provided in addition to or mixed with the base
// formula.
CodeableConcept additiveType;

//  The product or brand name of the type of modular component to be added
// to the formula.
String additiveProductName;

//  The amount of energy (calories) that the formula should provide per
// specified volume, typically per mL or fluid oz.  For example, an infant
// may require a formula that provides 24 calories per fluid ounce or an
// adult may require an enteral formula that provides 1.5 calorie/mL.
Quantity caloricDensity;

//  The route or physiological path of administration into the patient's
// gastrointestinal  tract for purposes of providing the formula feeding,
// e.g. nasogastric tube.
CodeableConcept routeofAdministration;

//  Formula administration instructions as structured data.  This
// repeating structure allows for changing the administration rate or
// volume over time for both bolus and continuous feeding.  An example of
// this would be an instruction to increase the rate of continuous feeding
// every 2 hours.
List<NutritionOrder_Administration> administration;

//  The maximum total quantity of formula that may be administered to a
// subject over the period of time, e.g. 1440 mL over 24 hours.
Quantity maxVolumeToDeliver;

//  Free text formula administration, feeding instructions or additional
// instructions or information.
String administrationInstruction;

NutritionOrder_EnteralFormula(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.baseFormulaType,
    this.baseFormulaProductName,
    this.additiveType,
    this.additiveProductName,
    this.caloricDensity,
    this.routeofAdministration,
    this.administration,
    this.maxVolumeToDeliver,
    this.administrationInstruction,
    });

  factory NutritionOrder_EnteralFormula.fromJson(Map<String, dynamic> json) => _$NutritionOrder_EnteralFormulaFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_EnteralFormulaToJson(this);
}

@JsonSerializable(explicitToJson: true)
class NutritionOrder_Administration {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The time period and frequency at which the enteral formula should be
// delivered to the patient.
Timing schedule;

//  The volume of formula to provide to the patient per the specified
// administration schedule.
Quantity quantity;

//  The rate of administration of formula via a feeding pump, e.g. 60 mL
// per hour, according to the specified schedule.
Quantity rateQuantity;

//  The rate of administration of formula via a feeding pump, e.g. 60 mL
// per hour, according to the specified schedule.
Ratio rateRatio;

NutritionOrder_Administration(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.schedule,
    this.quantity,
    this.rateQuantity,
    this.rateRatio,
    });

  factory NutritionOrder_Administration.fromJson(Map<String, dynamic> json) => _$NutritionOrder_AdministrationFromJson(json);
  Map<String, dynamic> toJson() => _$NutritionOrder_AdministrationToJson(this);
}

part 'observation.g.dart';

@JsonSerializable(explicitToJson: true)
class Observation {

//  This is a Observation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this observation.
List<Identifier> identifier;

//  A plan, proposal or order that is fulfilled in whole or in part by
// this event.  For example, a MedicationRequest may require a patient to
// have laboratory test performed before  it is dispensed.
List<Reference> basedOn;

//  A larger event of which this particular Observation is a component or
// step.  For example,  an observation as part of a procedure.
List<Reference> partOf;

//  The status of the result value.
String status; // <code> enum: registered/preliminary/final/amended/corrected/cancelled/entered-in-error/unknown;

//  A code that classifies the general type of observation being made.
List<CodeableConcept> category;

//  Describes what was observed. Sometimes this is called the observation
// "name".
CodeableConcept code;

//  The patient, or group of patients, location, or device this
// observation is about and into whose record the observation is placed.
// If the actual focus of the observation is different from the subject
// (or a sample of, part, or region of the subject), the `focus` element
// or the `code` itself specifies the actual focus of the observation.
Reference subject;

//  The actual focus of an observation when it is not the patient of
// record representing something or someone associated with the patient
// such as a spouse, parent, fetus, or donor. For example, fetus
// observations in a mother's record.  The focus of an observation could
// also be an existing condition,  an intervention, the subject's diet, 
// another observation of the subject,  or a body structure such as tumor
// or implanted device.   An example use case would be using the
// Observation resource to capture whether the mother is trained to change
// her child's tracheostomy tube. In this example, the child is the
// patient of record and the mother is the focus.
List<Reference> focus;

//  The healthcare event  (e.g. a patient and healthcare provider
// interaction) during which this observation is made.
Reference encounter;

//  The time or time-period the observed value is asserted as being true.
// For biological subjects - e.g. human patients - this is usually called
// the "physiologically relevant time". This is usually either the time of
// the procedure or of specimen collection, but very often the source of
// the date/time is not known, only the date/time itself.
String effectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The time or time-period the observed value is asserted as being true.
// For biological subjects - e.g. human patients - this is usually called
// the "physiologically relevant time". This is usually either the time of
// the procedure or of specimen collection, but very often the source of
// the date/time is not known, only the date/time itself.
Period effectivePeriod;

//  The time or time-period the observed value is asserted as being true.
// For biological subjects - e.g. human patients - this is usually called
// the "physiologically relevant time". This is usually either the time of
// the procedure or of specimen collection, but very often the source of
// the date/time is not known, only the date/time itself.
Timing effectiveTiming;

//  The time or time-period the observed value is asserted as being true.
// For biological subjects - e.g. human patients - this is usually called
// the "physiologically relevant time". This is usually either the time of
// the procedure or of specimen collection, but very often the source of
// the date/time is not known, only the date/time itself.
String effectiveInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The date and time this version of the observation was made available
// to providers, typically after the results have been reviewed and
// verified.
DateTime issued;

//  Who was responsible for asserting the observed value as "true".
List<Reference> performer;

//  The information determined as a result of making the observation, if
// the information has a simple value.
Quantity valueQuantity;

//  The information determined as a result of making the observation, if
// the information has a simple value.
CodeableConcept valueCodeableConcept;

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The information determined as a result of making the observation, if
// the information has a simple value.
bool valueBoolean; //  pattern: ^true|false$

//  The information determined as a result of making the observation, if
// the information has a simple value.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The information determined as a result of making the observation, if
// the information has a simple value.
Range valueRange;

//  The information determined as a result of making the observation, if
// the information has a simple value.
Ratio valueRatio;

//  The information determined as a result of making the observation, if
// the information has a simple value.
SampledData valueSampledData;

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The information determined as a result of making the observation, if
// the information has a simple value.
Period valuePeriod;

//  Provides a reason why the expected value in the element
// Observation.value[x] is missing.
CodeableConcept dataAbsentReason;

//  A categorical assessment of an observation value.  For example, high,
// low, normal.
List<CodeableConcept> interpretation;

//  Comments about the observation or the results.
List<Annotation> note;

//  Indicates the site on the subject's body where the observation was
// made (i.e. the target site).
CodeableConcept bodySite;

//  Indicates the mechanism used to perform the observation.
CodeableConcept method;

//  The specimen that was used when this observation was made.
Reference specimen;

//  The device used to generate the observation data.
Reference device;

//  Guidance on how to interpret the value by comparison to a normal or
// recommended range.  Multiple reference ranges are interpreted as an
// "OR".   In other words, to represent two distinct target populations,
// two `referenceRange` elements would be used.
List<Observation_ReferenceRange> referenceRange;

//  This observation is a group observation (e.g. a battery, a panel of
// tests, a set of vital sign measurements) that includes the target as a
// member of the group.
List<Reference> hasMember;

//  The target resource that represents a measurement from which this
// observation value is derived. For example, a calculated anion gap or a
// fetal measurement based on an ultrasound image.
List<Reference> derivedFrom;

//  Some observations have multiple component observations.  These
// component observations are expressed as separate code value pairs that
// share the same attributes.  Examples include systolic and diastolic
// component observations for blood pressure measurement and multiple
// component observations for genetics observations.
List<Observation_Component> component;

Observation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.partOf,
    this.status,
    this.category,
    this.code,
    this.subject,
    this.focus,
    this.encounter,
    this.effectiveDateTime,
    this.effectivePeriod,
    this.effectiveTiming,
    this.effectiveInstant,
    this.issued,
    this.performer,
    this.valueQuantity,
    this.valueCodeableConcept,
    this.valueString,
    this.valueBoolean,
    this.valueInteger,
    this.valueRange,
    this.valueRatio,
    this.valueSampledData,
    this.valueTime,
    this.valueDateTime,
    this.valuePeriod,
    this.dataAbsentReason,
    this.interpretation,
    this.note,
    this.bodySite,
    this.method,
    this.specimen,
    this.device,
    this.referenceRange,
    this.hasMember,
    this.derivedFrom,
    this.component,
    });

  factory Observation.fromJson(Map<String, dynamic> json) => _$ObservationFromJson(json);
  Map<String, dynamic> toJson() => _$ObservationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Observation_ReferenceRange {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The value of the low bound of the reference range.  The low bound of
// the reference range endpoint is inclusive of the value (e.g.  reference
// range is >=5 - <=9). If the low bound is omitted,  it is assumed to be
// meaningless (e.g. reference range is <=2.3).
Quantity low;

//  The value of the high bound of the reference range.  The high bound of
// the reference range endpoint is inclusive of the value (e.g.  reference
// range is >=5 - <=9). If the high bound is omitted,  it is assumed to be
// meaningless (e.g. reference range is >= 2.3).
Quantity high;

//  Codes to indicate the what part of the targeted reference population
// it applies to. For example, the normal or therapeutic range.
CodeableConcept type;

//  Codes to indicate the target population this reference range applies
// to.  For example, a reference range may be based on the normal
// population or a particular sex or race.  Multiple `appliesTo`  are
// interpreted as an "AND" of the target populations.  For example, to
// represent a target population of African American females, both a code
// of female and a code for African American would be used.
List<CodeableConcept> appliesTo;

//  The age at which this reference range is applicable. This is a
// neonatal age (e.g. number of weeks at term) if the meaning says so.
Range age;

//  Text based reference range in an observation which may be used when a
// quantitative range is not appropriate for an observation.  An example
// would be a reference value of "Negative" or a list or table of
// "normals".
String text;

Observation_ReferenceRange(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.low,
    this.high,
    this.type,
    this.appliesTo,
    this.age,
    this.text,
    });

  factory Observation_ReferenceRange.fromJson(Map<String, dynamic> json) => _$Observation_ReferenceRangeFromJson(json);
  Map<String, dynamic> toJson() => _$Observation_ReferenceRangeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Observation_Component {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Describes what was observed. Sometimes this is called the observation
// "code".
CodeableConcept code;

//  The information determined as a result of making the observation, if
// the information has a simple value.
Quantity valueQuantity;

//  The information determined as a result of making the observation, if
// the information has a simple value.
CodeableConcept valueCodeableConcept;

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The information determined as a result of making the observation, if
// the information has a simple value.
bool valueBoolean; //  pattern: ^true|false$

//  The information determined as a result of making the observation, if
// the information has a simple value.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The information determined as a result of making the observation, if
// the information has a simple value.
Range valueRange;

//  The information determined as a result of making the observation, if
// the information has a simple value.
Ratio valueRatio;

//  The information determined as a result of making the observation, if
// the information has a simple value.
SampledData valueSampledData;

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The information determined as a result of making the observation, if
// the information has a simple value.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The information determined as a result of making the observation, if
// the information has a simple value.
Period valuePeriod;

//  Provides a reason why the expected value in the element
// Observation.component.value[x] is missing.
CodeableConcept dataAbsentReason;

//  A categorical assessment of an observation value.  For example, high,
// low, normal.
List<CodeableConcept> interpretation;

//  Guidance on how to interpret the value by comparison to a normal or
// recommended range.
List<Observation_ReferenceRange> referenceRange;

Observation_Component(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.valueQuantity,
    this.valueCodeableConcept,
    this.valueString,
    this.valueBoolean,
    this.valueInteger,
    this.valueRange,
    this.valueRatio,
    this.valueSampledData,
    this.valueTime,
    this.valueDateTime,
    this.valuePeriod,
    this.dataAbsentReason,
    this.interpretation,
    this.referenceRange,
    });

  factory Observation_Component.fromJson(Map<String, dynamic> json) => _$Observation_ComponentFromJson(json);
  Map<String, dynamic> toJson() => _$Observation_ComponentToJson(this);
}

part 'observationDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ObservationDefinition {

//  This is a ObservationDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A code that classifies the general type of observation.
List<CodeableConcept> category;

//  Describes what will be observed. Sometimes this is called the
// observation "name".
CodeableConcept code;

//  A unique identifier assigned to this ObservationDefinition artifact.
List<Identifier> identifier;

//  The data types allowed for the value element of the instance
// observations conforming to this ObservationDefinition.
List<String> permittedDataType; // <code> enum: Quantity/CodeableConcept/string/boolean/integer/Range/Ratio/SampledData/time/dateTime/Period> permittedDataType;

//  Multiple results allowed for observations conforming to this
// ObservationDefinition.
bool multipleResultsAllowed;

//  The method or technique used to perform the observation.
CodeableConcept method;

//  The preferred name to be used when reporting the results of
// observations conforming to this ObservationDefinition.
String preferredReportName;

//  Characteristics for quantitative results of this observation.
ObservationDefinition_QuantitativeDetails quantitativeDetails;

//  Multiple  ranges of results qualified by different contexts for
// ordinal or continuous observations conforming to this
// ObservationDefinition.
List<ObservationDefinition_QualifiedInterval> qualifiedInterval;

//  The set of valid coded results for the observations  conforming to
// this ObservationDefinition.
Reference validCodedValueSet;

//  The set of normal coded results for the observations conforming to
// this ObservationDefinition.
Reference normalCodedValueSet;

//  The set of abnormal coded results for the observation conforming to
// this ObservationDefinition.
Reference abnormalCodedValueSet;

//  The set of critical coded results for the observation conforming to
// this ObservationDefinition.
Reference criticalCodedValueSet;

ObservationDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.category,
    this.code,
    this.identifier,
    this.permittedDataType,
    this.multipleResultsAllowed,
    this.method,
    this.preferredReportName,
    this.quantitativeDetails,
    this.qualifiedInterval,
    this.validCodedValueSet,
    this.normalCodedValueSet,
    this.abnormalCodedValueSet,
    this.criticalCodedValueSet,
    });

  factory ObservationDefinition.fromJson(Map<String, dynamic> json) => _$ObservationDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ObservationDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ObservationDefinition_QuantitativeDetails {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Customary unit used to report quantitative results of observations
// conforming to this ObservationDefinition.
CodeableConcept customaryUnit;

//  SI unit used to report quantitative results of observations conforming
// to this ObservationDefinition.
CodeableConcept unit;

//  Factor for converting value expressed with SI unit to value expressed
// with customary unit.
double conversionFactor;

//  Number of digits after decimal separator when the results of such
// observations are of type Quantity.
int decimalPrecision;

ObservationDefinition_QuantitativeDetails(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.customaryUnit,
    this.unit,
    this.conversionFactor,
    this.decimalPrecision,
    });

  factory ObservationDefinition_QuantitativeDetails.fromJson(Map<String, dynamic> json) => _$ObservationDefinition_QuantitativeDetailsFromJson(json);
  Map<String, dynamic> toJson() => _$ObservationDefinition_QuantitativeDetailsToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ObservationDefinition_QualifiedInterval {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The category of interval of values for continuous or ordinal
// observations conforming to this ObservationDefinition.
String category; // <code> enum: reference/critical/absolute;

//  The low and high values determining the interval. There may be only
// one of the two.
Range range;

//  Codes to indicate the health context the range applies to. For
// example, the normal or therapeutic range.
CodeableConcept context;

//  Codes to indicate the target population this reference range applies
// to.
List<CodeableConcept> appliesTo;

//  Sex of the population the range applies to.
String gender; // <code> enum: male/female/other/unknown;

//  The age at which this reference range is applicable. This is a
// neonatal age (e.g. number of weeks at term) if the meaning says so.
Range age;

//  The gestational age to which this reference range is applicable, in
// the context of pregnancy.
Range gestationalAge;

//  Text based condition for which the reference range is valid.
String condition;

ObservationDefinition_QualifiedInterval(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.range,
    this.context,
    this.appliesTo,
    this.gender,
    this.age,
    this.gestationalAge,
    this.condition,
    });

  factory ObservationDefinition_QualifiedInterval.fromJson(Map<String, dynamic> json) => _$ObservationDefinition_QualifiedIntervalFromJson(json);
  Map<String, dynamic> toJson() => _$ObservationDefinition_QualifiedIntervalToJson(this);
}

part 'operationDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class OperationDefinition {

//  This is a OperationDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this operation definition
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this operation definition is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the operation definition is stored on different servers.
String url;

//  The identifier that is used to identify this version of the operation
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the operation
// definition author and is not expected to be globally unique. For
// example, it might be a timestamp (e.g. yyyymmdd) if a managed version
// is not available. There is also no expectation that versions can be
// placed in a lexicographical sequence.
String version;

//  A natural language name identifying the operation definition. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the operation
// definition.
String title;

//  The status of this operation definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  Whether this is an operation or a named query.
String kind; // <code> enum: operation/query;

//  A Boolean value to indicate that this operation definition is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the operation definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the operation definition
// changes.
DateTime date;

//  The name of the organization or individual that published the
// operation definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the operation definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate operation definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the operation definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this operation definition is needed and why it has
// been designed as it has.
String purpose;

//  Whether the operation affects state. Side effects such as producing
// audit trail entries do not count as 'affecting  state'.
bool affectsState;

//  The name used to invoke the operation.
String code;

//  Additional information about how to use this operation or named query.
String comment;

//  Indicates that this operation definition is a constraining profile on
// the base.
String base;

//  The types on which this operation can be executed.
List<String> resource;

//  Indicates whether this operation or named query can be invoked at the
// system level (e.g. without needing to choose a resource type for the
// context).
bool system;

//  Indicates whether this operation or named query can be invoked at the
// resource type level for any given resource type level (e.g. without
// needing to choose a specific resource id for the context).
bool type;

//  Indicates whether this operation can be invoked on a particular
// instance of one of the given types.
bool instance;

//  Additional validation information for the in parameters - a single
// profile that covers all the parameters. The profile is a constraint on
// the parameters resource as a whole.
String inputProfile;

//  Additional validation information for the out parameters - a single
// profile that covers all the parameters. The profile is a constraint on
// the parameters resource.
String outputProfile;

//  The parameters for the operation/query.
List<OperationDefinition_Parameter> parameter;

//  Defines an appropriate combination of parameters to use when invoking
// this operation, to help code generators when generating overloaded
// parameter sets for this operation.
List<OperationDefinition_Overload> overload;

OperationDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.title,
    this.status,
    this.kind,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.affectsState,
    this.code,
    this.comment,
    this.base,
    this.resource,
    this.system,
    this.type,
    this.instance,
    this.inputProfile,
    this.outputProfile,
    this.parameter,
    this.overload,
    });

  factory OperationDefinition.fromJson(Map<String, dynamic> json) => _$OperationDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$OperationDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class OperationDefinition_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of used to identify the parameter.
String name;

//  Whether this is an input or an output parameter.
String use; // <code> enum: in/out;

//  The minimum number of times this parameter SHALL appear in the request
// or response.
int min;

//  The maximum number of times this element is permitted to appear in the
// request or response.
String max;

//  Describes the meaning or use of this parameter.
String documentation;

//  The type for this parameter.
String type;

//  Used when the type is "Reference" or "canonical", and identifies a
// profile structure or implementation Guide that applies to the target of
// the reference this parameter refers to. If any profiles are specified,
// then the content must conform to at least one of them. The URL can be a
// local reference - to a contained StructureDefinition, or a reference to
// another StructureDefinition or Implementation Guide by a canonical URL.
// When an implementation guide is specified, the target resource SHALL
// conform to at least one profile defined in the implementation guide.
List<String> targetProfile;

//  How the parameter is understood as a search parameter. This is only
// used if the parameter type is 'string'.
String searchType; // <code> enum: number/date/string/token/reference/composite/quantity/uri/special;

//  Binds to a value set if this parameter is coded (code, Coding,
// CodeableConcept).
OperationDefinition_Binding binding;

//  Identifies other resource parameters within the operation invocation
// that are expected to resolve to this resource.
List<OperationDefinition_ReferencedFrom> referencedFrom;

//  The parts of a nested Parameter.
List<OperationDefinition_Parameter> part;

OperationDefinition_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.use,
    this.min,
    this.max,
    this.documentation,
    this.type,
    this.targetProfile,
    this.searchType,
    this.binding,
    this.referencedFrom,
    this.part,
    });

  factory OperationDefinition_Parameter.fromJson(Map<String, dynamic> json) => _$OperationDefinition_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$OperationDefinition_ParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class OperationDefinition_Binding {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates the degree of conformance expectations associated with this
// binding - that is, the degree to which the provided value set must be
// adhered to in the instances.
String strength; // <code> enum: required/extensible/preferred/example;

//  Points to the value set or external definition (e.g. implicit value
// set) that identifies the set of codes to be used.
String valueSet;

OperationDefinition_Binding(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.strength,
    this.valueSet,
    });

  factory OperationDefinition_Binding.fromJson(Map<String, dynamic> json) => _$OperationDefinition_BindingFromJson(json);
  Map<String, dynamic> toJson() => _$OperationDefinition_BindingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class OperationDefinition_ReferencedFrom {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the parameter or dot-separated path of parameter names
// pointing to the resource parameter that is expected to contain a
// reference to this resource.
String source;

//  The id of the element in the referencing resource that is expected to
// resolve to this resource.
String sourceId;

OperationDefinition_ReferencedFrom(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.source,
    this.sourceId,
    });

  factory OperationDefinition_ReferencedFrom.fromJson(Map<String, dynamic> json) => _$OperationDefinition_ReferencedFromFromJson(json);
  Map<String, dynamic> toJson() => _$OperationDefinition_ReferencedFromToJson(this);
}

@JsonSerializable(explicitToJson: true)
class OperationDefinition_Overload {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name of parameter to include in overload.
List<String> parameterName;

//  Comments to go on overload.
String comment;

OperationDefinition_Overload(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.parameterName,
    this.comment,
    });

  factory OperationDefinition_Overload.fromJson(Map<String, dynamic> json) => _$OperationDefinition_OverloadFromJson(json);
  Map<String, dynamic> toJson() => _$OperationDefinition_OverloadToJson(this);
}

part 'operationOutcome.g.dart';

@JsonSerializable(explicitToJson: true)
class OperationOutcome {

//  This is a OperationOutcome resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An error, warning, or information message that results from a system
// action.
List<OperationOutcome_Issue> issue;

OperationOutcome(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.issue,
    });

  factory OperationOutcome.fromJson(Map<String, dynamic> json) => _$OperationOutcomeFromJson(json);
  Map<String, dynamic> toJson() => _$OperationOutcomeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class OperationOutcome_Issue {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates whether the issue indicates a variation from successful
// processing.
String severity; // <code> enum: fatal/error/warning/information;

//  Describes the type of the issue. The system that creates an
// OperationOutcome SHALL choose the most applicable code from the
// IssueType value set, and may additional provide its own code for the
// error in the details element.
String code; // <code> enum: invalid/structure/required/value/invariant/security/login/unknown/expired/forbidden/suppressed/processing/not-supported/duplicate/multiple-matches/not-found/deleted/too-long/code-invalid/extension/too-costly/business-rule/conflict/transient/lock-error/no-store/exception/timeout/incomplete/throttled/informational;

//  Additional details about the error. This may be a text description of
// the error or a system code that identifies the error.
CodeableConcept details;

//  Additional diagnostic information about the issue.
String diagnostics;

//  This element is deprecated because it is XML specific. It is replaced
// by issue.expression, which is format independent, and simpler to parse.
//  For resource issues, this will be a simple XPath limited to element
// names, repetition indicators and the default child accessor that
// identifies one of the elements in the resource that caused this issue
// to be raised.  For HTTP errors, will be "http." + the parameter name.
List<String> location;

//  A [simple subset of FHIRPath](fhirpath.html#simple) limited to element
// names, repetition indicators and the default child accessor that
// identifies one of the elements in the resource that caused this issue
// to be raised.
List<String> expression;

OperationOutcome_Issue(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.severity,
    this.code,
    this.details,
    this.diagnostics,
    this.location,
    this.expression,
    });

  factory OperationOutcome_Issue.fromJson(Map<String, dynamic> json) => _$OperationOutcome_IssueFromJson(json);
  Map<String, dynamic> toJson() => _$OperationOutcome_IssueToJson(this);
}

part 'organization.g.dart';

@JsonSerializable(explicitToJson: true)
class Organization {

//  This is a Organization resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the organization that is used to identify the
// organization across multiple disparate systems.
List<Identifier> identifier;

//  Whether the organization's record is still in active use.
bool active;

//  The kind(s) of organization that this is.
List<CodeableConcept> type;

//  A name associated with the organization.
String name;

//  A list of alternate names that the organization is known as, or was
// known as in the past.
List<String> alias;

//  A contact detail for the organization.
List<ContactPoint> telecom;

//  An address for the organization.
List<Address> address;

//  The organization of which this organization forms a part.
Reference partOf;

//  Contact for the organization for a certain purpose.
List<Organization_Contact> contact;

//  Technical endpoints providing access to services operated for the
// organization.
List<Reference> endpoint;

Organization(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.type,
    this.name,
    this.alias,
    this.telecom,
    this.address,
    this.partOf,
    this.contact,
    this.endpoint,
    });

  factory Organization.fromJson(Map<String, dynamic> json) => _$OrganizationFromJson(json);
  Map<String, dynamic> toJson() => _$OrganizationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Organization_Contact {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a purpose for which the contact can be reached.
CodeableConcept purpose;

//  A name associated with the contact.
HumanName name;

//  A contact detail (e.g. a telephone number or an email address) by
// which the party may be contacted.
List<ContactPoint> telecom;

//  Visiting or postal addresses for the contact.
Address address;

Organization_Contact(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.purpose,
    this.name,
    this.telecom,
    this.address,
    });

  factory Organization_Contact.fromJson(Map<String, dynamic> json) => _$Organization_ContactFromJson(json);
  Map<String, dynamic> toJson() => _$Organization_ContactToJson(this);
}

part 'organizationAffiliation.g.dart';

@JsonSerializable(explicitToJson: true)
class OrganizationAffiliation {

//  This is a OrganizationAffiliation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers that are specific to this role.
List<Identifier> identifier;

//  Whether this organization affiliation record is in active use.
bool active;

//  The period during which the participatingOrganization is affiliated
// with the primary organization.
Period period;

//  Organization where the role is available (primary organization/has
// members).
Reference organization;

//  The Participating Organization provides/performs the role(s) defined
// by the code to the Primary Organization (e.g. providing services or is
// a member of).
Reference participatingOrganization;

//  Health insurance provider network in which the
// participatingOrganization provides the role's services (if defined) at
// the indicated locations (if defined).
List<Reference> network;

//  Definition of the role the participatingOrganization plays in the
// association.
List<CodeableConcept> code;

//  Specific specialty of the participatingOrganization in the context of
// the role.
List<CodeableConcept> specialty;

//  The location(s) at which the role occurs.
List<Reference> location;

//  Healthcare services provided through the role.
List<Reference> healthcareService;

//  Contact details at the participatingOrganization relevant to this
// Affiliation.
List<ContactPoint> telecom;

//  Technical endpoints providing access to services operated for this
// role.
List<Reference> endpoint;

OrganizationAffiliation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.period,
    this.organization,
    this.participatingOrganization,
    this.network,
    this.code,
    this.specialty,
    this.location,
    this.healthcareService,
    this.telecom,
    this.endpoint,
    });

  factory OrganizationAffiliation.fromJson(Map<String, dynamic> json) => _$OrganizationAffiliationFromJson(json);
  Map<String, dynamic> toJson() => _$OrganizationAffiliationToJson(this);
}

part 'parameters.g.dart';

@JsonSerializable(explicitToJson: true)
class Parameters {

//  This is a Parameters resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A parameter passed to or received from the operation.
List<Parameters_Parameter> parameter;

Parameters(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.parameter,
    });

  factory Parameters.fromJson(Map<String, dynamic> json) => _$ParametersFromJson(json);
  Map<String, dynamic> toJson() => _$ParametersToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Parameters_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the parameter (reference to the operation definition).
String name;

//  If the parameter is a data type.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  If the parameter is a data type.
bool valueBoolean; //  pattern: ^true|false$

//  If the parameter is a data type.
String valueCanonical; //  pattern: ^\S*$

//  If the parameter is a data type.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  If the parameter is a data type.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  If the parameter is a data type.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  If the parameter is a data type.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  If the parameter is a data type.
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  If the parameter is a data type.
String valueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  If the parameter is a data type.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  If the parameter is a data type.
String valueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  If the parameter is a data type.
String valueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  If the parameter is a data type.
int valuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  If the parameter is a data type.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  If the parameter is a data type.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  If the parameter is a data type.
int valueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  If the parameter is a data type.
String valueUri; //  pattern: ^\S*$

//  If the parameter is a data type.
String valueUrl; //  pattern: ^\S*$

//  If the parameter is a data type.
String valueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  If the parameter is a data type.
Address valueAddress;

//  If the parameter is a data type.
Age valueAge;

//  If the parameter is a data type.
Annotation valueAnnotation;

//  If the parameter is a data type.
Attachment valueAttachment;

//  If the parameter is a data type.
CodeableConcept valueCodeableConcept;

//  If the parameter is a data type.
Coding valueCoding;

//  If the parameter is a data type.
ContactPoint valueContactPoint;

//  If the parameter is a data type.
Count valueCount;

//  If the parameter is a data type.
Distance valueDistance;

//  If the parameter is a data type.
Duration valueDuration;

//  If the parameter is a data type.
HumanName valueHumanName;

//  If the parameter is a data type.
Identifier valueIdentifier;

//  If the parameter is a data type.
Money valueMoney;

//  If the parameter is a data type.
Period valuePeriod;

//  If the parameter is a data type.
Quantity valueQuantity;

//  If the parameter is a data type.
Range valueRange;

//  If the parameter is a data type.
Ratio valueRatio;

//  If the parameter is a data type.
Reference valueReference;

//  If the parameter is a data type.
SampledData valueSampledData;

//  If the parameter is a data type.
Signature valueSignature;

//  If the parameter is a data type.
Timing valueTiming;

//  If the parameter is a data type.
ContactDetail valueContactDetail;

//  If the parameter is a data type.
Contributor valueContributor;

//  If the parameter is a data type.
DataRequirement valueDataRequirement;

//  If the parameter is a data type.
Expression valueExpression;

//  If the parameter is a data type.
ParameterDefinition valueParameterDefinition;

//  If the parameter is a data type.
RelatedArtifact valueRelatedArtifact;

//  If the parameter is a data type.
TriggerDefinition valueTriggerDefinition;

//  If the parameter is a data type.
UsageContext valueUsageContext;

//  If the parameter is a data type.
Dosage valueDosage;

//  If the parameter is a data type.
Meta valueMeta;

//  If the parameter is a whole resource.
ResourceList resource;

//  A named part of a multi-part parameter.
List<Parameters_Parameter> part;

Parameters_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.valueBase64Binary,
    this.valueBoolean,
    this.valueCanonical,
    this.valueCode,
    this.valueDate,
    this.valueDateTime,
    this.valueDecimal,
    this.valueId,
    this.valueInstant,
    this.valueInteger,
    this.valueMarkdown,
    this.valueOid,
    this.valuePositiveInt,
    this.valueString,
    this.valueTime,
    this.valueUnsignedInt,
    this.valueUri,
    this.valueUrl,
    this.valueUuid,
    this.valueAddress,
    this.valueAge,
    this.valueAnnotation,
    this.valueAttachment,
    this.valueCodeableConcept,
    this.valueCoding,
    this.valueContactPoint,
    this.valueCount,
    this.valueDistance,
    this.valueDuration,
    this.valueHumanName,
    this.valueIdentifier,
    this.valueMoney,
    this.valuePeriod,
    this.valueQuantity,
    this.valueRange,
    this.valueRatio,
    this.valueReference,
    this.valueSampledData,
    this.valueSignature,
    this.valueTiming,
    this.valueContactDetail,
    this.valueContributor,
    this.valueDataRequirement,
    this.valueExpression,
    this.valueParameterDefinition,
    this.valueRelatedArtifact,
    this.valueTriggerDefinition,
    this.valueUsageContext,
    this.valueDosage,
    this.valueMeta,
    this.resource,
    this.part,
    });

  factory Parameters_Parameter.fromJson(Map<String, dynamic> json) => _$Parameters_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$Parameters_ParameterToJson(this);
}

part 'patient.g.dart';

@JsonSerializable(explicitToJson: true)
class Patient {

//  This is a Patient resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier for this patient.
List<Identifier> identifier;

//  Whether this patient record is in active use.  Many systems use this
// property to mark as non-current patients, such as those that have not
// been seen for a period of time based on an organization's business
// rules. It is often used to filter patient lists to exclude inactive
// patients Deceased patients may also be marked as inactive for the same
// reasons, but may be active for some time after death.
bool active;

//  A name associated with the individual.
List<HumanName> name;

//  A contact detail (e.g. a telephone number or an email address) by
// which the individual may be contacted.
List<ContactPoint> telecom;

//  Administrative Gender - the gender that the patient is considered to
// have for administration and record keeping purposes.
String gender; // <code> enum: male/female/other/unknown;

//  The date of birth for the individual.
String birthDate;

//  Indicates if the individual is deceased or not.
bool deceasedBoolean; //  pattern: ^true|false$

//  Indicates if the individual is deceased or not.
String deceasedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  An address for the individual.
List<Address> address;

//  This field contains a patient's most recent marital (civil) status.
CodeableConcept maritalStatus;

//  Indicates whether the patient is part of a multiple (boolean) or
// indicates the actual birth order (integer).
bool multipleBirthBoolean; //  pattern: ^true|false$

//  Indicates whether the patient is part of a multiple (boolean) or
// indicates the actual birth order (integer).
int multipleBirthInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Image of the patient.
List<Attachment> photo;

//  A contact party (e.g. guardian, partner, friend) for the patient.
List<Patient_Contact> contact;

//  A language which may be used to communicate with the patient about his
// or her health.
List<Patient_Communication> communication;

//  Patient's nominated care provider.
List<Reference> generalPractitioner;

//  Organization that is the custodian of the patient record.
Reference managingOrganization;

//  Link to another patient resource that concerns the same actual
// patient.
List<Patient_Link> link;

Patient(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.name,
    this.telecom,
    this.gender,
    this.birthDate,
    this.deceasedBoolean,
    this.deceasedDateTime,
    this.address,
    this.maritalStatus,
    this.multipleBirthBoolean,
    this.multipleBirthInteger,
    this.photo,
    this.contact,
    this.communication,
    this.generalPractitioner,
    this.managingOrganization,
    this.link,
    });

  factory Patient.fromJson(Map<String, dynamic> json) => _$PatientFromJson(json);
  Map<String, dynamic> toJson() => _$PatientToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Patient_Contact {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The nature of the relationship between the patient and the contact
// person.
List<CodeableConcept> relationship;

//  A name associated with the contact person.
HumanName name;

//  A contact detail for the person, e.g. a telephone number or an email
// address.
List<ContactPoint> telecom;

//  Address for the contact person.
Address address;

//  Administrative Gender - the gender that the contact person is
// considered to have for administration and record keeping purposes.
String gender; // <code> enum: male/female/other/unknown;

//  Organization on behalf of which the contact is acting or for which the
// contact is working.
Reference organization;

//  The period during which this contact person or organization is valid
// to be contacted relating to this patient.
Period period;

Patient_Contact(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.relationship,
    this.name,
    this.telecom,
    this.address,
    this.gender,
    this.organization,
    this.period,
    });

  factory Patient_Contact.fromJson(Map<String, dynamic> json) => _$Patient_ContactFromJson(json);
  Map<String, dynamic> toJson() => _$Patient_ContactToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Patient_Communication {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The ISO-639-1 alpha 2 code in lower case for the language, optionally
// followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in
// upper case; e.g. "en" for English, or "en-US" for American English
// versus "en-EN" for England English.
CodeableConcept language;

//  Indicates whether or not the patient prefers this language (over other
// languages he masters up a certain level).
bool preferred;

Patient_Communication(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.language,
    this.preferred,
    });

  factory Patient_Communication.fromJson(Map<String, dynamic> json) => _$Patient_CommunicationFromJson(json);
  Map<String, dynamic> toJson() => _$Patient_CommunicationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Patient_Link {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The other patient resource that the link refers to.
Reference other;

//  The type of link between this patient resource and another patient
// resource.
String type; // <code> enum: replaced-by/replaces/refer/seealso;

Patient_Link(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.other,
    this.type,
    });

  factory Patient_Link.fromJson(Map<String, dynamic> json) => _$Patient_LinkFromJson(json);
  Map<String, dynamic> toJson() => _$Patient_LinkToJson(this);
}

part 'paymentNotice.g.dart';

@JsonSerializable(explicitToJson: true)
class PaymentNotice {

//  This is a PaymentNotice resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this payment notice.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  Reference of resource for which payment is being made.
Reference request;

//  Reference of response to resource for which payment is being made.
Reference response;

//  The date when this resource was created.
DateTime created;

//  The practitioner who is responsible for the services rendered to the
// patient.
Reference provider;

//  A reference to the payment which is the subject of this notice.
Reference payment;

//  The date when the above payment action occurred.
String paymentDate;

//  The party who will receive or has received payment that is the subject
// of this notification.
Reference payee;

//  The party who is notified of the payment status.
Reference recipient;

//  The amount sent to the payee.
Money amount;

//  A code indicating whether payment has been sent or cleared.
CodeableConcept paymentStatus;

PaymentNotice(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.request,
    this.response,
    this.created,
    this.provider,
    this.payment,
    this.paymentDate,
    this.payee,
    this.recipient,
    this.amount,
    this.paymentStatus,
    });

  factory PaymentNotice.fromJson(Map<String, dynamic> json) => _$PaymentNoticeFromJson(json);
  Map<String, dynamic> toJson() => _$PaymentNoticeToJson(this);
}

part 'paymentReconciliation.g.dart';

@JsonSerializable(explicitToJson: true)
class PaymentReconciliation {

//  This is a PaymentReconciliation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this payment reconciliation.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  The period of time for which payments have been gathered into this
// bulk payment for settlement.
Period period;

//  The date when the resource was created.
DateTime created;

//  The party who generated the payment.
Reference paymentIssuer;

//  Original request resource reference.
Reference request;

//  The practitioner who is responsible for the services rendered to the
// patient.
Reference requestor;

//  The outcome of a request for a reconciliation.
String outcome; // <code> enum: queued/complete/error/partial;

//  A human readable description of the status of the request for the
// reconciliation.
String disposition;

//  The date of payment as indicated on the financial instrument.
String paymentDate;

//  Total payment amount as indicated on the financial instrument.
Money paymentAmount;

//  Issuer's unique identifier for the payment instrument.
Identifier paymentIdentifier;

//  Distribution of the payment amount for a previously acknowledged
// payable.
List<PaymentReconciliation_Detail> detail;

//  A code for the form to be used for printing the content.
CodeableConcept formCode;

//  A note that describes or explains the processing in a human readable
// form.
List<PaymentReconciliation_ProcessNote> processNote;

PaymentReconciliation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.period,
    this.created,
    this.paymentIssuer,
    this.request,
    this.requestor,
    this.outcome,
    this.disposition,
    this.paymentDate,
    this.paymentAmount,
    this.paymentIdentifier,
    this.detail,
    this.formCode,
    this.processNote,
    });

  factory PaymentReconciliation.fromJson(Map<String, dynamic> json) => _$PaymentReconciliationFromJson(json);
  Map<String, dynamic> toJson() => _$PaymentReconciliationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PaymentReconciliation_Detail {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for the current payment item for the referenced
// payable.
Identifier identifier;

//  Unique identifier for the prior payment item for the referenced
// payable.
Identifier predecessor;

//  Code to indicate the nature of the payment.
CodeableConcept type;

//  A resource, such as a Claim, the evaluation of which could lead to
// payment.
Reference request;

//  The party which submitted the claim or financial transaction.
Reference submitter;

//  A resource, such as a ClaimResponse, which contains a commitment to
// payment.
Reference response;

//  The date from the response resource containing a commitment to pay.
String date;

//  A reference to the individual who is responsible for inquiries
// regarding the response and its payment.
Reference responsible;

//  The party which is receiving the payment.
Reference payee;

//  The monetary amount allocated from the total payment to the payable.
Money amount;

PaymentReconciliation_Detail(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.predecessor,
    this.type,
    this.request,
    this.submitter,
    this.response,
    this.date,
    this.responsible,
    this.payee,
    this.amount,
    });

  factory PaymentReconciliation_Detail.fromJson(Map<String, dynamic> json) => _$PaymentReconciliation_DetailFromJson(json);
  Map<String, dynamic> toJson() => _$PaymentReconciliation_DetailToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PaymentReconciliation_ProcessNote {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The business purpose of the note text.
String type; // <code> enum: display/print/printoper;

//  The explanation or description associated with the processing.
String text;

PaymentReconciliation_ProcessNote(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.text,
    });

  factory PaymentReconciliation_ProcessNote.fromJson(Map<String, dynamic> json) => _$PaymentReconciliation_ProcessNoteFromJson(json);
  Map<String, dynamic> toJson() => _$PaymentReconciliation_ProcessNoteToJson(this);
}

part 'person.g.dart';

@JsonSerializable(explicitToJson: true)
class Person {

//  This is a Person resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for a person within a particular scope.
List<Identifier> identifier;

//  A name associated with the person.
List<HumanName> name;

//  A contact detail for the person, e.g. a telephone number or an email
// address.
List<ContactPoint> telecom;

//  Administrative Gender.
String gender; // <code> enum: male/female/other/unknown;

//  The birth date for the person.
String birthDate;

//  One or more addresses for the person.
List<Address> address;

//  An image that can be displayed as a thumbnail of the person to enhance
// the identification of the individual.
Attachment photo;

//  The organization that is the custodian of the person record.
Reference managingOrganization;

//  Whether this person's record is in active use.
bool active;

//  Link to a resource that concerns the same actual person.
List<Person_Link> link;

Person(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.name,
    this.telecom,
    this.gender,
    this.birthDate,
    this.address,
    this.photo,
    this.managingOrganization,
    this.active,
    this.link,
    });

  factory Person.fromJson(Map<String, dynamic> json) => _$PersonFromJson(json);
  Map<String, dynamic> toJson() => _$PersonToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Person_Link {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The resource to which this actual person is associated.
Reference target;

//  Level of assurance that this link is associated with the target
// resource.
String assurance; // <code> enum: level1/level2/level3/level4;

Person_Link(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.target,
    this.assurance,
    });

  factory Person_Link.fromJson(Map<String, dynamic> json) => _$Person_LinkFromJson(json);
  Map<String, dynamic> toJson() => _$Person_LinkToJson(this);
}

part 'planDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class PlanDefinition {

//  This is a PlanDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this plan definition when it
// is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this plan definition is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the plan
// definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this plan definition when
// it is represented in other formats, or referenced in a specification,
// model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the plan
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the plan definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence. To provide a version consistent with the
// Decision Support Service specification, use the format
// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
// knowledge assets, refer to the Decision Support Service specification.
// Note that a version is required for non-experimental active artifacts.
String version;

//  A natural language name identifying the plan definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the plan definition.
String title;

//  An explanatory or alternate title for the plan definition giving
// additional information about its content.
String subtitle;

//  A high-level category for the plan definition that distinguishes the
// kinds of systems that would be interested in the plan definition.
CodeableConcept type;

//  The status of this plan definition. Enables tracking the life-cycle of
// the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this plan definition is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  A code or group definition that describes the intended subject of the
// plan definition.
CodeableConcept subjectCodeableConcept;

//  A code or group definition that describes the intended subject of the
// plan definition.
Reference subjectReference;

//  The date  (and optionally time) when the plan definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the plan definition changes.
DateTime date;

//  The name of the organization or individual that published the plan
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the plan definition from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate plan definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the plan definition is intended
// to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this plan definition is needed and why it has been
// designed as it has.
String purpose;

//  A detailed description of how the plan definition is used from a
// clinical perspective.
String usage;

//  A copyright statement relating to the plan definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the plan definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the plan definition content was or is planned
// to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the plan definition.
// Topics provide a high-level categorization of the definition that can
// be useful for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a Library resource containing any formal logic used by
// the plan definition.
List<String> library;

//  Goals that describe what the activities within the plan are intended
// to achieve. For example, weight loss, restoring an activity of daily
// living, obtaining herd immunity via immunization, meeting a process
// improvement objective, etc.
List<PlanDefinition_Goal> goal;

//  An action or group of actions to be taken as part of the plan.
List<PlanDefinition_Action> action;

PlanDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.subtitle,
    this.type,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.library,
    this.goal,
    this.action,
    });

  factory PlanDefinition.fromJson(Map<String, dynamic> json) => _$PlanDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_Goal {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates a category the goal falls within.
CodeableConcept category;

//  Human-readable and/or coded description of a specific desired
// objective of care, such as "control blood pressure" or "negotiate an
// obstacle course" or "dance with child at wedding".
CodeableConcept description;

//  Identifies the expected level of importance associated with
// reaching/sustaining the defined goal.
CodeableConcept priority;

//  The event after which the goal should begin being pursued.
CodeableConcept start;

//  Identifies problems, conditions, issues, or concerns the goal is
// intended to address.
List<CodeableConcept> addresses;

//  Didactic or other informational resources associated with the goal
// that provide further supporting information about the goal. Information
// resources can include inline text commentary and links to web
// resources.
List<RelatedArtifact> documentation;

//  Indicates what should be done and within what timeframe.
List<PlanDefinition_Target> target;

PlanDefinition_Goal(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.description,
    this.priority,
    this.start,
    this.addresses,
    this.documentation,
    this.target,
    });

  factory PlanDefinition_Goal.fromJson(Map<String, dynamic> json) => _$PlanDefinition_GoalFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_GoalToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The parameter whose value is to be tracked, e.g. body weight, blood
// pressure, or hemoglobin A1c level.
CodeableConcept measure;

//  The target value of the measure to be achieved to signify fulfillment
// of the goal, e.g. 150 pounds or 7.0%. Either the high or low or both
// values of the range can be specified. When a low value is missing, it
// indicates that the goal is achieved at any value at or below the high
// value. Similarly, if the high value is missing, it indicates that the
// goal is achieved at any value at or above the low value.
Quantity detailQuantity;

//  The target value of the measure to be achieved to signify fulfillment
// of the goal, e.g. 150 pounds or 7.0%. Either the high or low or both
// values of the range can be specified. When a low value is missing, it
// indicates that the goal is achieved at any value at or below the high
// value. Similarly, if the high value is missing, it indicates that the
// goal is achieved at any value at or above the low value.
Range detailRange;

//  The target value of the measure to be achieved to signify fulfillment
// of the goal, e.g. 150 pounds or 7.0%. Either the high or low or both
// values of the range can be specified. When a low value is missing, it
// indicates that the goal is achieved at any value at or below the high
// value. Similarly, if the high value is missing, it indicates that the
// goal is achieved at any value at or above the low value.
CodeableConcept detailCodeableConcept;

//  Indicates the timeframe after the start of the goal in which the goal
// should be met.
Duration due;

PlanDefinition_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.measure,
    this.detailQuantity,
    this.detailRange,
    this.detailCodeableConcept,
    this.due,
    });

  factory PlanDefinition_Target.fromJson(Map<String, dynamic> json) => _$PlanDefinition_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_TargetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_Action {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A user-visible prefix for the action.
String prefix;

//  The title of the action displayed to a user.
String title;

//  A brief description of the action used to provide a summary to display
// to the user.
String description;

//  A text equivalent of the action to be performed. This provides a
// human-interpretable description of the action when the definition is
// consumed by a system that might not be capable of interpreting it
// dynamically.
String textEquivalent;

//  Indicates how quickly the action should be addressed with respect to
// other actions.
String priority;

//  A code that provides meaning for the action or action group. For
// example, a section may have a LOINC code for the section of a
// documentation template.
List<CodeableConcept> code;

//  A description of why this action is necessary or appropriate.
List<CodeableConcept> reason;

//  Didactic or other informational resources associated with the action
// that can be provided to the CDS recipient. Information resources can
// include inline text commentary and links to web resources.
List<RelatedArtifact> documentation;

//  Identifies goals that this action supports. The reference must be to a
// goal element defined within this plan definition.
List<String> goalId;

//  A code or group definition that describes the intended subject of the
// action and its children, if any.
CodeableConcept subjectCodeableConcept;

//  A code or group definition that describes the intended subject of the
// action and its children, if any.
Reference subjectReference;

//  A description of when the action should be triggered.
List<TriggerDefinition> trigger;

//  An expression that describes applicability criteria or start/stop
// conditions for the action.
List<PlanDefinition_Condition> condition;

//  Defines input data requirements for the action.
List<DataRequirement> input;

//  Defines the outputs of the action, if any.
List<DataRequirement> output;

//  A relationship to another action such as "before" or "30-60 minutes
// after start of".
List<PlanDefinition_RelatedAction> relatedAction;

//  An optional value describing when the action should be performed.
String timingDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  An optional value describing when the action should be performed.
Age timingAge;

//  An optional value describing when the action should be performed.
Period timingPeriod;

//  An optional value describing when the action should be performed.
Duration timingDuration;

//  An optional value describing when the action should be performed.
Range timingRange;

//  An optional value describing when the action should be performed.
Timing timingTiming;

//  Indicates who should participate in performing the action described.
List<PlanDefinition_Participant> participant;

//  The type of action to perform (create, update, remove).
CodeableConcept type;

//  Defines the grouping behavior for the action and its children.
String groupingBehavior; // <code> enum: visual-group/logical-group/sentence-group;

//  Defines the selection behavior for the action and its children.
String selectionBehavior; // <code> enum: any/all/all-or-none/exactly-one/at-most-one/one-or-more;

//  Defines the required behavior for the action.
String requiredBehavior; // <code> enum: must/could/must-unless-documented;

//  Defines whether the action should usually be preselected.
String precheckBehavior; // <code> enum: yes/no;

//  Defines whether the action can be selected multiple times.
String cardinalityBehavior; // <code> enum: single/multiple;

//  A reference to an ActivityDefinition that describes the action to be
// taken in detail, or a PlanDefinition that describes a series of actions
// to be taken.
String definitionCanonical; //  pattern: ^\S*$

//  A reference to an ActivityDefinition that describes the action to be
// taken in detail, or a PlanDefinition that describes a series of actions
// to be taken.
String definitionUri; //  pattern: ^\S*$

//  A reference to a StructureMap resource that defines a transform that
// can be executed to produce the intent resource using the
// ActivityDefinition instance as the input.
String transform;

//  Customizations that should be applied to the statically defined
// resource. For example, if the dosage of a medication must be computed
// based on the patient's weight, a customization would be used to specify
// an expression that calculated the weight, and the path on the resource
// that would contain the result.
List<PlanDefinition_DynamicValue> dynamicValue;

//  Sub actions that are contained within the action. The behavior of this
// action determines the functionality of the sub-actions. For example, a
// selection behavior of at-most-one indicates that of the sub-actions, at
// most one may be chosen as part of realizing the action definition.
List<PlanDefinition_Action> action;

PlanDefinition_Action(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.prefix,
    this.title,
    this.description,
    this.textEquivalent,
    this.priority,
    this.code,
    this.reason,
    this.documentation,
    this.goalId,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.trigger,
    this.condition,
    this.input,
    this.output,
    this.relatedAction,
    this.timingDateTime,
    this.timingAge,
    this.timingPeriod,
    this.timingDuration,
    this.timingRange,
    this.timingTiming,
    this.participant,
    this.type,
    this.groupingBehavior,
    this.selectionBehavior,
    this.requiredBehavior,
    this.precheckBehavior,
    this.cardinalityBehavior,
    this.definitionCanonical,
    this.definitionUri,
    this.transform,
    this.dynamicValue,
    this.action,
    });

  factory PlanDefinition_Action.fromJson(Map<String, dynamic> json) => _$PlanDefinition_ActionFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_ActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_Condition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of condition.
String kind; // <code> enum: applicability/start/stop;

//  An expression that returns true or false, indicating whether the
// condition is satisfied.
Expression expression;

PlanDefinition_Condition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.kind,
    this.expression,
    });

  factory PlanDefinition_Condition.fromJson(Map<String, dynamic> json) => _$PlanDefinition_ConditionFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_ConditionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_RelatedAction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The element id of the related action.
String actionId;

//  The relationship of this action to the related action.
String relationship; // <code> enum: before-start/before/before-end/concurrent-with-start/concurrent/concurrent-with-end/after-start/after/after-end;

//  A duration or range of durations to apply to the relationship. For
// example, 30-60 minutes before.
Duration offsetDuration;

//  A duration or range of durations to apply to the relationship. For
// example, 30-60 minutes before.
Range offsetRange;

PlanDefinition_RelatedAction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.actionId,
    this.relationship,
    this.offsetDuration,
    this.offsetRange,
    });

  factory PlanDefinition_RelatedAction.fromJson(Map<String, dynamic> json) => _$PlanDefinition_RelatedActionFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_RelatedActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of participant in the action.
String type; // <code> enum: patient/practitioner/related-person/device;

//  The role the participant should play in performing the described
// action.
CodeableConcept role;

PlanDefinition_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.role,
    });

  factory PlanDefinition_Participant.fromJson(Map<String, dynamic> json) => _$PlanDefinition_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_ParticipantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PlanDefinition_DynamicValue {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The path to the element to be customized. This is the path on the
// resource that will hold the result of the calculation defined by the
// expression. The specified path SHALL be a FHIRPath resolveable on the
// specified target type of the ActivityDefinition, and SHALL consist only
// of identifiers, constant indexers, and a restricted subset of
// functions. The path is allowed to contain qualifiers (.) to traverse
// sub-elements, as well as indexers ([x]) to traverse
// multiple-cardinality sub-elements (see the [Simple FHIRPath
// Profile](fhirpath.html#simple) for full details).
String path;

//  An expression specifying the value of the customized element.
Expression expression;

PlanDefinition_DynamicValue(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.path,
    this.expression,
    });

  factory PlanDefinition_DynamicValue.fromJson(Map<String, dynamic> json) => _$PlanDefinition_DynamicValueFromJson(json);
  Map<String, dynamic> toJson() => _$PlanDefinition_DynamicValueToJson(this);
}

part 'practitioner.g.dart';

@JsonSerializable(explicitToJson: true)
class Practitioner {

//  This is a Practitioner resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier that applies to this person in this role.
List<Identifier> identifier;

//  Whether this practitioner's record is in active use.
bool active;

//  The name(s) associated with the practitioner.
List<HumanName> name;

//  A contact detail for the practitioner, e.g. a telephone number or an
// email address.
List<ContactPoint> telecom;

//  Address(es) of the practitioner that are not role specific (typically
// home address). Work addresses are not typically entered in this
// property as they are usually role dependent.
List<Address> address;

//  Administrative Gender - the gender that the person is considered to
// have for administration and record keeping purposes.
String gender; // <code> enum: male/female/other/unknown;

//  The date of birth for the practitioner.
String birthDate;

//  Image of the person.
List<Attachment> photo;

//  The official certifications, training, and licenses that authorize or
// otherwise pertain to the provision of care by the practitioner.  For
// example, a medical license issued by a medical board authorizing the
// practitioner to practice medicine within a certian locality.
List<Practitioner_Qualification> qualification;

//  A language the practitioner can use in patient communication.
List<CodeableConcept> communication;

Practitioner(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.name,
    this.telecom,
    this.address,
    this.gender,
    this.birthDate,
    this.photo,
    this.qualification,
    this.communication,
    });

  factory Practitioner.fromJson(Map<String, dynamic> json) => _$PractitionerFromJson(json);
  Map<String, dynamic> toJson() => _$PractitionerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Practitioner_Qualification {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier that applies to this person's qualification in this
// role.
List<Identifier> identifier;

//  Coded representation of the qualification.
CodeableConcept code;

//  Period during which the qualification is valid.
Period period;

//  Organization that regulates and issues the qualification.
Reference issuer;

Practitioner_Qualification(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.code,
    this.period,
    this.issuer,
    });

  factory Practitioner_Qualification.fromJson(Map<String, dynamic> json) => _$Practitioner_QualificationFromJson(json);
  Map<String, dynamic> toJson() => _$Practitioner_QualificationToJson(this);
}

part 'practitionerRole.g.dart';

@JsonSerializable(explicitToJson: true)
class PractitionerRole {

//  This is a PractitionerRole resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business Identifiers that are specific to a role/location.
List<Identifier> identifier;

//  Whether this practitioner role record is in active use.
bool active;

//  The period during which the person is authorized to act as a
// practitioner in these role(s) for the organization.
Period period;

//  Practitioner that is able to provide the defined services for the
// organization.
Reference practitioner;

//  The organization where the Practitioner performs the roles associated.
Reference organization;

//  Roles which this practitioner is authorized to perform for the
// organization.
List<CodeableConcept> code;

//  Specific specialty of the practitioner.
List<CodeableConcept> specialty;

//  The location(s) at which this practitioner provides care.
List<Reference> location;

//  The list of healthcare services that this worker provides for this
// role's Organization/Location(s).
List<Reference> healthcareService;

//  Contact details that are specific to the role/location/service.
List<ContactPoint> telecom;

//  A collection of times the practitioner is available or performing this
// role at the location and/or healthcareservice.
List<PractitionerRole_AvailableTime> availableTime;

//  The practitioner is not available or performing this role during this
// period of time due to the provided reason.
List<PractitionerRole_NotAvailable> notAvailable;

//  A description of site availability exceptions, e.g. public holiday
// availability. Succinctly describing all possible exceptions to normal
// site availability as details in the available Times and not available
// Times.
String availabilityExceptions;

//  Technical endpoints providing access to services operated for the
// practitioner with this role.
List<Reference> endpoint;

PractitionerRole(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.period,
    this.practitioner,
    this.organization,
    this.code,
    this.specialty,
    this.location,
    this.healthcareService,
    this.telecom,
    this.availableTime,
    this.notAvailable,
    this.availabilityExceptions,
    this.endpoint,
    });

  factory PractitionerRole.fromJson(Map<String, dynamic> json) => _$PractitionerRoleFromJson(json);
  Map<String, dynamic> toJson() => _$PractitionerRoleToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PractitionerRole_AvailableTime {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates which days of the week are available between the start and
// end Times.
List<String> daysOfWeek;

//  Is this always available? (hence times are irrelevant) e.g. 24 hour
// service.
bool allDay;

//  The opening time of day. Note: If the AllDay flag is set, then this
// time is ignored.
String availableStartTime;

//  The closing time of day. Note: If the AllDay flag is set, then this
// time is ignored.
String availableEndTime;

PractitionerRole_AvailableTime(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.daysOfWeek,
    this.allDay,
    this.availableStartTime,
    this.availableEndTime,
    });

  factory PractitionerRole_AvailableTime.fromJson(Map<String, dynamic> json) => _$PractitionerRole_AvailableTimeFromJson(json);
  Map<String, dynamic> toJson() => _$PractitionerRole_AvailableTimeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class PractitionerRole_NotAvailable {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The reason that can be presented to the user as to why this time is
// not available.
String description;

//  Service is not available (seasonally or for a public holiday) from
// this date.
Period during;

PractitionerRole_NotAvailable(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.during,
    });

  factory PractitionerRole_NotAvailable.fromJson(Map<String, dynamic> json) => _$PractitionerRole_NotAvailableFromJson(json);
  Map<String, dynamic> toJson() => _$PractitionerRole_NotAvailableToJson(this);
}

part 'procedure.g.dart';

@JsonSerializable(explicitToJson: true)
class Procedure {

//  This is a Procedure resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this procedure by the performer or
// other systems which remain constant as the resource is updated and is
// propagated from server to server.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, order set or
// other definition that is adhered to in whole or in part by this
// Procedure.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// order set or other definition that is adhered to in whole or in part by
// this Procedure.
List<String> instantiatesUri;

//  A reference to a resource that contains details of the request for
// this procedure.
List<Reference> basedOn;

//  A larger event of which this particular procedure is a component or
// step.
List<Reference> partOf;

//  A code specifying the state of the procedure. Generally, this will be
// the in-progress or completed state.
String status;

//  Captures the reason for the current state of the procedure.
CodeableConcept statusReason;

//  A code that classifies the procedure for searching, sorting and
// display purposes (e.g. "Surgical Procedure").
CodeableConcept category;

//  The specific procedure that is performed. Use text if the exact nature
// of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
CodeableConcept code;

//  The person, animal or group on which the procedure was performed.
Reference subject;

//  The Encounter during which this Procedure was created or performed or
// to which the creation of this record is tightly associated.
Reference encounter;

//  Estimated or actual date, date-time, period, or age when the procedure
// was performed.  Allows a period to support complex procedures that span
// more than one date, and also allows for the length of the procedure to
// be captured.
String performedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Estimated or actual date, date-time, period, or age when the procedure
// was performed.  Allows a period to support complex procedures that span
// more than one date, and also allows for the length of the procedure to
// be captured.
Period performedPeriod;

//  Estimated or actual date, date-time, period, or age when the procedure
// was performed.  Allows a period to support complex procedures that span
// more than one date, and also allows for the length of the procedure to
// be captured.
String performedString; //  pattern: ^[ \r\n\t\S]+$

//  Estimated or actual date, date-time, period, or age when the procedure
// was performed.  Allows a period to support complex procedures that span
// more than one date, and also allows for the length of the procedure to
// be captured.
Age performedAge;

//  Estimated or actual date, date-time, period, or age when the procedure
// was performed.  Allows a period to support complex procedures that span
// more than one date, and also allows for the length of the procedure to
// be captured.
Range performedRange;

//  Individual who recorded the record and takes responsibility for its
// content.
Reference recorder;

//  Individual who is making the procedure statement.
Reference asserter;

//  Limited to "real" people rather than equipment.
List<Procedure_Performer> performer;

//  The location where the procedure actually happened.  E.g. a newborn at
// home, a tracheostomy at a restaurant.
Reference location;

//  The coded reason why the procedure was performed. This may be a coded
// entity of some type, or may simply be present as text.
List<CodeableConcept> reasonCode;

//  The justification of why the procedure was performed.
List<Reference> reasonReference;

//  Detailed and structured anatomical location information. Multiple
// locations are allowed - e.g. multiple punch biopsies of a lesion.
List<CodeableConcept> bodySite;

//  The outcome of the procedure - did it resolve the reasons for the
// procedure being performed?
CodeableConcept outcome;

//  This could be a histology result, pathology report, surgical report,
// etc.
List<Reference> report;

//  Any complications that occurred during the procedure, or in the
// immediate post-performance period. These are generally tracked
// separately from the notes, which will typically describe the procedure
// itself rather than any 'post procedure' issues.
List<CodeableConcept> complication;

//  Any complications that occurred during the procedure, or in the
// immediate post-performance period.
List<Reference> complicationDetail;

//  If the procedure required specific follow up - e.g. removal of
// sutures. The follow up may be represented as a simple note or could
// potentially be more complex, in which case the CarePlan resource can be
// used.
List<CodeableConcept> followUp;

//  Any other notes and comments about the procedure.
List<Annotation> note;

//  A device that is implanted, removed or otherwise manipulated
// (calibration, battery replacement, fitting a prosthesis, attaching a
// wound-vac, etc.) as a focal portion of the Procedure.
List<Procedure_FocalDevice> focalDevice;

//  Identifies medications, devices and any other substance used as part
// of the procedure.
List<Reference> usedReference;

//  Identifies coded items that were used as part of the procedure.
List<CodeableConcept> usedCode;

Procedure(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.partOf,
    this.status,
    this.statusReason,
    this.category,
    this.code,
    this.subject,
    this.encounter,
    this.performedDateTime,
    this.performedPeriod,
    this.performedString,
    this.performedAge,
    this.performedRange,
    this.recorder,
    this.asserter,
    this.performer,
    this.location,
    this.reasonCode,
    this.reasonReference,
    this.bodySite,
    this.outcome,
    this.report,
    this.complication,
    this.complicationDetail,
    this.followUp,
    this.note,
    this.focalDevice,
    this.usedReference,
    this.usedCode,
    });

  factory Procedure.fromJson(Map<String, dynamic> json) => _$ProcedureFromJson(json);
  Map<String, dynamic> toJson() => _$ProcedureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Procedure_Performer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Distinguishes the type of involvement of the performer in the
// procedure. For example, surgeon, anaesthetist, endoscopist.
CodeableConcept function;

//  The practitioner who was involved in the procedure.
Reference actor;

//  The organization the device or practitioner was acting on behalf of.
Reference onBehalfOf;

Procedure_Performer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.function,
    this.actor,
    this.onBehalfOf,
    });

  factory Procedure_Performer.fromJson(Map<String, dynamic> json) => _$Procedure_PerformerFromJson(json);
  Map<String, dynamic> toJson() => _$Procedure_PerformerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Procedure_FocalDevice {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of change that happened to the device during the procedure.
CodeableConcept action;

//  The device that was manipulated (changed) during the procedure.
Reference manipulated;

Procedure_FocalDevice(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    this.manipulated,
    });

  factory Procedure_FocalDevice.fromJson(Map<String, dynamic> json) => _$Procedure_FocalDeviceFromJson(json);
  Map<String, dynamic> toJson() => _$Procedure_FocalDeviceToJson(this);
}

part 'provenance.g.dart';

@JsonSerializable(explicitToJson: true)
class Provenance {

//  This is a Provenance resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The Reference(s) that were generated or updated by  the activity
// described in this resource. A provenance can point to more than one
// target if multiple resources were created/updated by the same activity.
List<Reference> target;

//  The period during which the activity occurred.
Period occurredPeriod;

//  The period during which the activity occurred.
String occurredDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The instant of time at which the activity was recorded.
DateTime recorded;

//  Policy or plan the activity was defined by. Typically, a single
// activity may have multiple applicable policy documents, such as patient
// consent, guarantor funding, etc.
List<String> policy;

//  Where the activity occurred, if relevant.
Reference location;

//  The reason that the activity was taking place.
List<CodeableConcept> reason;

//  An activity is something that occurs over a period of time and acts
// upon or with entities; it may include consuming, processing,
// transforming, modifying, relocating, using, or generating entities.
CodeableConcept activity;

//  An actor taking a role in an activity  for which it can be assigned
// some degree of responsibility for the activity taking place.
List<Provenance_Agent> agent;

//  An entity used in this activity.
List<Provenance_Entity> entity;

//  A digital signature on the target Reference(s). The signer should
// match a Provenance.agent. The purpose of the signature is indicated.
List<Signature> signature;

Provenance(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.target,
    this.occurredPeriod,
    this.occurredDateTime,
    this.recorded,
    this.policy,
    this.location,
    this.reason,
    this.activity,
    this.agent,
    this.entity,
    this.signature,
    });

  factory Provenance.fromJson(Map<String, dynamic> json) => _$ProvenanceFromJson(json);
  Map<String, dynamic> toJson() => _$ProvenanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Provenance_Agent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The participation the agent had with respect to the activity.
CodeableConcept type;

//  The function of the agent with respect to the activity. The security
// role enabling the agent with respect to the activity.
List<CodeableConcept> role;

//  The individual, device or organization that participated in the event.
Reference who;

//  The individual, device, or organization for whom the change was made.
Reference onBehalfOf;

Provenance_Agent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.role,
    this.who,
    this.onBehalfOf,
    });

  factory Provenance_Agent.fromJson(Map<String, dynamic> json) => _$Provenance_AgentFromJson(json);
  Map<String, dynamic> toJson() => _$Provenance_AgentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Provenance_Entity {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  How the entity was used during the activity.
String role; // <code> enum: derivation/revision/quotation/source/removal;

//  Identity of the  Entity used. May be a logical or physical uri and
// maybe absolute or relative.
Reference what;

//  The entity is attributed to an agent to express the agent's
// responsibility for that entity, possibly along with other agents. This
// description can be understood as shorthand for saying that the agent
// was responsible for the activity which generated the entity.
List<Provenance_Agent> agent;

Provenance_Entity(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.role,
    this.what,
    this.agent,
    });

  factory Provenance_Entity.fromJson(Map<String, dynamic> json) => _$Provenance_EntityFromJson(json);
  Map<String, dynamic> toJson() => _$Provenance_EntityToJson(this);
}

part 'questionnaire.g.dart';

@JsonSerializable(explicitToJson: true)
class Questionnaire {

//  This is a Questionnaire resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this questionnaire when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this questionnaire is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// questionnaire is stored on different servers.
String url;

//  A formal identifier that is used to identify this questionnaire when
// it is represented in other formats, or referenced in a specification,
// model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the
// questionnaire when it is referenced in a specification, model, design
// or instance. This is an arbitrary value managed by the questionnaire
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the questionnaire. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the questionnaire.
String title;

//  The URL of a Questionnaire that this Questionnaire is based on.
List<String> derivedFrom;

//  The status of this questionnaire. Enables tracking the life-cycle of
// the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this questionnaire is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The types of subjects that can be the subject of responses created for
// the questionnaire.
List<String> subjectType;

//  The date  (and optionally time) when the questionnaire was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the questionnaire changes.
DateTime date;

//  The name of the organization or individual that published the
// questionnaire.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the questionnaire from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate questionnaire instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the questionnaire is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this questionnaire is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the questionnaire and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the questionnaire.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the questionnaire content was or is planned to
// be in active use.
Period effectivePeriod;

//  An identifier for this question or group of questions in a particular
// terminology such as LOINC.
List<Coding> code;

//  A particular question, question grouping or display text that is part
// of the questionnaire.
List<Questionnaire_Item> item;

Questionnaire(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.derivedFrom,
    this.status,
    this.experimental,
    this.subjectType,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.code,
    this.item,
    });

  factory Questionnaire.fromJson(Map<String, dynamic> json) => _$QuestionnaireFromJson(json);
  Map<String, dynamic> toJson() => _$QuestionnaireToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Questionnaire_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier that is unique within the Questionnaire allowing linkage
// to the equivalent item in a QuestionnaireResponse resource.
String linkId;

//  This element is a URI that refers to an [[[ElementDefinition]]] that
// provides information about this item, including information that might
// otherwise be included in the instance of the Questionnaire resource. A
// detailed description of the construction of the URI is shown in
// Comments, below. If this element is present then the following element
// values MAY be derived from the Element Definition if the corresponding
// elements of this Questionnaire resource instance have no value: * code
// (ElementDefinition.code)  * type (ElementDefinition.type)  * required
// (ElementDefinition.min)  * repeats (ElementDefinition.max)  * maxLength
// (ElementDefinition.maxLength)  * answerValueSet
// (ElementDefinition.binding) * options (ElementDefinition.binding).
String definition;

//  A terminology code that corresponds to this group or question (e.g. a
// code from LOINC, which defines many questions and answers).
List<Coding> code;

//  A short label for a particular group, question or set of display text
// within the questionnaire used for reference by the individual
// completing the questionnaire.
String prefix;

//  The name of a section, the text of a question or text content for a
// display item.
String text;

//  The type of questionnaire item this is - whether text for display, a
// grouping of other items or a particular type of data to be captured
// (string, integer, coded choice, etc.).
String type; // <code> enum: group/display/boolean/decimal/integer/date/dateTime/time/string/text/url/choice/open-choice/attachment/reference/quantity;

//  A constraint indicating that this item should only be enabled
// (displayed/allow answers to be captured) when the specified condition
// is true.
List<Questionnaire_EnableWhen> enableWhen;

//  Controls how multiple enableWhen values are interpreted -  whether all
// or any must be true.
String enableBehavior; // <code> enum: all/any;

//  An indication, if true, that the item must be present in a "completed"
// QuestionnaireResponse.  If false, the item may be skipped when
// answering the questionnaire.
bool required;

//  An indication, if true, that the item may occur multiple times in the
// response, collecting multiple answers for questions or multiple sets of
// answers for groups.
bool repeats;

//  An indication, when true, that the value cannot be changed by a human
// respondent to the Questionnaire.
bool readOnly;

//  The maximum number of characters that are permitted in the answer to
// be considered a "valid" QuestionnaireResponse.
int maxLength;

//  A reference to a value set containing a list of codes representing
// permitted answers for a "choice" or "open-choice" question.
String answerValueSet;

//  One of the permitted answers for a "choice" or "open-choice" question.
List<Questionnaire_AnswerOption> answerOption;

//  One or more values that should be pre-populated in the answer when
// initially rendering the questionnaire for user input.
List<Questionnaire_Initial> initial;

//  Text, questions and other groups to be nested beneath a question or
// group.
List<Questionnaire_Item> item;

Questionnaire_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.linkId,
    this.definition,
    this.code,
    this.prefix,
    this.text,
    this.type,
    this.enableWhen,
    this.enableBehavior,
    this.required,
    this.repeats,
    this.readOnly,
    this.maxLength,
    this.answerValueSet,
    this.answerOption,
    this.initial,
    this.item,
    });

  factory Questionnaire_Item.fromJson(Map<String, dynamic> json) => _$Questionnaire_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$Questionnaire_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Questionnaire_EnableWhen {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The linkId for the question whose answer (or lack of answer) governs
// whether this item is enabled.
String question;

//  Specifies the criteria by which the question is enabled.
String operator; // <code> enum: exists/=/!=/>/</>=/<=;

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
bool answerBoolean; //  pattern: ^true|false$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
double answerDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
int answerInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
String answerDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
String answerDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
String answerTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
String answerString; //  pattern: ^[ \r\n\t\S]+$

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
Coding answerCoding;

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
Quantity answerQuantity;

//  A value that the referenced question is tested using the specified
// operator in order for the item to be enabled.
Reference answerReference;

Questionnaire_EnableWhen(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.question,
    this.operator,
    this.answerBoolean,
    this.answerDecimal,
    this.answerInteger,
    this.answerDate,
    this.answerDateTime,
    this.answerTime,
    this.answerString,
    this.answerCoding,
    this.answerQuantity,
    this.answerReference,
    });

  factory Questionnaire_EnableWhen.fromJson(Map<String, dynamic> json) => _$Questionnaire_EnableWhenFromJson(json);
  Map<String, dynamic> toJson() => _$Questionnaire_EnableWhenToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Questionnaire_AnswerOption {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A potential answer that's allowed as the answer to this question.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  A potential answer that's allowed as the answer to this question.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  A potential answer that's allowed as the answer to this question.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  A potential answer that's allowed as the answer to this question.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  A potential answer that's allowed as the answer to this question.
Coding valueCoding;

//  A potential answer that's allowed as the answer to this question.
Reference valueReference;

//  Indicates whether the answer value is selected when the list of
// possible answers is initially shown.
bool initialSelected;

Questionnaire_AnswerOption(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.valueInteger,
    this.valueDate,
    this.valueTime,
    this.valueString,
    this.valueCoding,
    this.valueReference,
    this.initialSelected,
    });

  factory Questionnaire_AnswerOption.fromJson(Map<String, dynamic> json) => _$Questionnaire_AnswerOptionFromJson(json);
  Map<String, dynamic> toJson() => _$Questionnaire_AnswerOptionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Questionnaire_Initial {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The actual value to for an initial answer.
bool valueBoolean; //  pattern: ^true|false$

//  The actual value to for an initial answer.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The actual value to for an initial answer.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The actual value to for an initial answer.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The actual value to for an initial answer.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The actual value to for an initial answer.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The actual value to for an initial answer.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The actual value to for an initial answer.
String valueUri; //  pattern: ^\S*$

//  The actual value to for an initial answer.
Attachment valueAttachment;

//  The actual value to for an initial answer.
Coding valueCoding;

//  The actual value to for an initial answer.
Quantity valueQuantity;

//  The actual value to for an initial answer.
Reference valueReference;

Questionnaire_Initial(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.valueBoolean,
    this.valueDecimal,
    this.valueInteger,
    this.valueDate,
    this.valueDateTime,
    this.valueTime,
    this.valueString,
    this.valueUri,
    this.valueAttachment,
    this.valueCoding,
    this.valueQuantity,
    this.valueReference,
    });

  factory Questionnaire_Initial.fromJson(Map<String, dynamic> json) => _$Questionnaire_InitialFromJson(json);
  Map<String, dynamic> toJson() => _$Questionnaire_InitialToJson(this);
}

part 'questionnaireResponse.g.dart';

@JsonSerializable(explicitToJson: true)
class QuestionnaireResponse {

//  This is a QuestionnaireResponse resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A business identifier assigned to a particular completed (or partially
// completed) questionnaire.
Identifier identifier;

//  The order, proposal or plan that is fulfilled in whole or in part by
// this QuestionnaireResponse.  For example, a ServiceRequest seeking an
// intake assessment or a decision support recommendation to assess for
// post-partum depression.
List<Reference> basedOn;

//  A procedure or observation that this questionnaire was performed as
// part of the execution of.  For example, the surgery a checklist was
// executed as part of.
List<Reference> partOf;

//  The Questionnaire that defines and organizes the questions for which
// answers are being provided.
String questionnaire;

//  The position of the questionnaire response within its overall
// lifecycle.
String status; // <code> enum: in-progress/completed/amended/entered-in-error/stopped;

//  The subject of the questionnaire response.  This could be a patient,
// organization, practitioner, device, etc.  This is who/what the answers
// apply to, but is not necessarily the source of information.
Reference subject;

//  The Encounter during which this questionnaire response was created or
// to which the creation of this record is tightly associated.
Reference encounter;

//  The date and/or time that this set of answers were last changed.
DateTime authored;

//  Person who received the answers to the questions in the
// QuestionnaireResponse and recorded them in the system.
Reference author;

//  The person who answered the questions about the subject.
Reference source;

//  A group or question item from the original questionnaire for which
// answers are provided.
List<QuestionnaireResponse_Item> item;

QuestionnaireResponse(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.partOf,
    this.questionnaire,
    this.status,
    this.subject,
    this.encounter,
    this.authored,
    this.author,
    this.source,
    this.item,
    });

  factory QuestionnaireResponse.fromJson(Map<String, dynamic> json) => _$QuestionnaireResponseFromJson(json);
  Map<String, dynamic> toJson() => _$QuestionnaireResponseToJson(this);
}

@JsonSerializable(explicitToJson: true)
class QuestionnaireResponse_Item {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The item from the Questionnaire that corresponds to this item in the
// QuestionnaireResponse resource.
String linkId;

//  A reference to an [[[ElementDefinition]]] that provides the details
// for the item.
String definition;

//  Text that is displayed above the contents of the group or as the text
// of the question being answered.
String text;

//  The respondent's answer(s) to the question.
List<QuestionnaireResponse_Answer> answer;

//  Questions or sub-groups nested beneath a question or group.
List<QuestionnaireResponse_Item> item;

QuestionnaireResponse_Item(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.linkId,
    this.definition,
    this.text,
    this.answer,
    this.item,
    });

  factory QuestionnaireResponse_Item.fromJson(Map<String, dynamic> json) => _$QuestionnaireResponse_ItemFromJson(json);
  Map<String, dynamic> toJson() => _$QuestionnaireResponse_ItemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class QuestionnaireResponse_Answer {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The answer (or one of the answers) provided by the respondent to the
// question.
bool valueBoolean; //  pattern: ^true|false$

//  The answer (or one of the answers) provided by the respondent to the
// question.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The answer (or one of the answers) provided by the respondent to the
// question.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The answer (or one of the answers) provided by the respondent to the
// question.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The answer (or one of the answers) provided by the respondent to the
// question.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The answer (or one of the answers) provided by the respondent to the
// question.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The answer (or one of the answers) provided by the respondent to the
// question.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The answer (or one of the answers) provided by the respondent to the
// question.
String valueUri; //  pattern: ^\S*$

//  The answer (or one of the answers) provided by the respondent to the
// question.
Attachment valueAttachment;

//  The answer (or one of the answers) provided by the respondent to the
// question.
Coding valueCoding;

//  The answer (or one of the answers) provided by the respondent to the
// question.
Quantity valueQuantity;

//  The answer (or one of the answers) provided by the respondent to the
// question.
Reference valueReference;

//  Nested groups and/or questions found within this particular answer.
List<QuestionnaireResponse_Item> item;

QuestionnaireResponse_Answer(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.valueBoolean,
    this.valueDecimal,
    this.valueInteger,
    this.valueDate,
    this.valueDateTime,
    this.valueTime,
    this.valueString,
    this.valueUri,
    this.valueAttachment,
    this.valueCoding,
    this.valueQuantity,
    this.valueReference,
    this.item,
    });

  factory QuestionnaireResponse_Answer.fromJson(Map<String, dynamic> json) => _$QuestionnaireResponse_AnswerFromJson(json);
  Map<String, dynamic> toJson() => _$QuestionnaireResponse_AnswerToJson(this);
}

part 'relatedPerson.g.dart';

@JsonSerializable(explicitToJson: true)
class RelatedPerson {

//  This is a RelatedPerson resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for a person within a particular scope.
List<Identifier> identifier;

//  Whether this related person record is in active use.
bool active;

//  The patient this person is related to.
Reference patient;

//  The nature of the relationship between a patient and the related
// person.
List<CodeableConcept> relationship;

//  A name associated with the person.
List<HumanName> name;

//  A contact detail for the person, e.g. a telephone number or an email
// address.
List<ContactPoint> telecom;

//  Administrative Gender - the gender that the person is considered to
// have for administration and record keeping purposes.
String gender; // <code> enum: male/female/other/unknown;

//  The date on which the related person was born.
String birthDate;

//  Address where the related person can be contacted or visited.
List<Address> address;

//  Image of the person.
List<Attachment> photo;

//  The period of time during which this relationship is or was active. If
// there are no dates defined, then the interval is unknown.
Period period;

//  A language which may be used to communicate with about the patient's
// health.
List<RelatedPerson_Communication> communication;

RelatedPerson(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.patient,
    this.relationship,
    this.name,
    this.telecom,
    this.gender,
    this.birthDate,
    this.address,
    this.photo,
    this.period,
    this.communication,
    });

  factory RelatedPerson.fromJson(Map<String, dynamic> json) => _$RelatedPersonFromJson(json);
  Map<String, dynamic> toJson() => _$RelatedPersonToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RelatedPerson_Communication {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The ISO-639-1 alpha 2 code in lower case for the language, optionally
// followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in
// upper case; e.g. "en" for English, or "en-US" for American English
// versus "en-EN" for England English.
CodeableConcept language;

//  Indicates whether or not the patient prefers this language (over other
// languages he masters up a certain level).
bool preferred;

RelatedPerson_Communication(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.language,
    this.preferred,
    });

  factory RelatedPerson_Communication.fromJson(Map<String, dynamic> json) => _$RelatedPerson_CommunicationFromJson(json);
  Map<String, dynamic> toJson() => _$RelatedPerson_CommunicationToJson(this);
}

part 'requestGroup.g.dart';

@JsonSerializable(explicitToJson: true)
class RequestGroup {

//  This is a RequestGroup resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Allows a service to provide a unique, business identifier for the
// request.
List<Identifier> identifier;

//  A canonical URL referencing a FHIR-defined protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this request.
List<String> instantiatesCanonical;

//  A URL referencing an externally defined protocol, guideline, orderset
// or other definition that is adhered to in whole or in part by this
// request.
List<String> instantiatesUri;

//  A plan, proposal or order that is fulfilled in whole or in part by
// this request.
List<Reference> basedOn;

//  Completed or terminated request(s) whose function is taken by this new
// request.
List<Reference> replaces;

//  A shared identifier common to all requests that were authorized more
// or less simultaneously by a single author, representing the identifier
// of the requisition, prescription or similar form.
Identifier groupIdentifier;

//  The current state of the request. For request groups, the status
// reflects the status of all the requests in the group.
String status;

//  Indicates the level of authority/intentionality associated with the
// request and where the request fits into the workflow chain.
String intent;

//  Indicates how quickly the request should be addressed with respect to
// other requests.
String priority;

//  A code that identifies what the overall request group is.
CodeableConcept code;

//  The subject for which the request group was created.
Reference subject;

//  Describes the context of the request group, if any.
Reference encounter;

//  Indicates when the request group was created.
DateTime authoredOn;

//  Provides a reference to the author of the request group.
Reference author;

//  Describes the reason for the request group in coded or textual form.
List<CodeableConcept> reasonCode;

//  Indicates another resource whose existence justifies this request
// group.
List<Reference> reasonReference;

//  Provides a mechanism to communicate additional information about the
// response.
List<Annotation> note;

//  The actions, if any, produced by the evaluation of the artifact.
List<RequestGroup_Action> action;

RequestGroup(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.replaces,
    this.groupIdentifier,
    this.status,
    this.intent,
    this.priority,
    this.code,
    this.subject,
    this.encounter,
    this.authoredOn,
    this.author,
    this.reasonCode,
    this.reasonReference,
    this.note,
    this.action,
    });

  factory RequestGroup.fromJson(Map<String, dynamic> json) => _$RequestGroupFromJson(json);
  Map<String, dynamic> toJson() => _$RequestGroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RequestGroup_Action {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A user-visible prefix for the action.
String prefix;

//  The title of the action displayed to a user.
String title;

//  A short description of the action used to provide a summary to display
// to the user.
String description;

//  A text equivalent of the action to be performed. This provides a
// human-interpretable description of the action when the definition is
// consumed by a system that might not be capable of interpreting it
// dynamically.
String textEquivalent;

//  Indicates how quickly the action should be addressed with respect to
// other actions.
String priority;

//  A code that provides meaning for the action or action group. For
// example, a section may have a LOINC code for a section of a
// documentation template.
List<CodeableConcept> code;

//  Didactic or other informational resources associated with the action
// that can be provided to the CDS recipient. Information resources can
// include inline text commentary and links to web resources.
List<RelatedArtifact> documentation;

//  An expression that describes applicability criteria, or start/stop
// conditions for the action.
List<RequestGroup_Condition> condition;

//  A relationship to another action such as "before" or "30-60 minutes
// after start of".
List<RequestGroup_RelatedAction> relatedAction;

//  An optional value describing when the action should be performed.
String timingDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  An optional value describing when the action should be performed.
Age timingAge;

//  An optional value describing when the action should be performed.
Period timingPeriod;

//  An optional value describing when the action should be performed.
Duration timingDuration;

//  An optional value describing when the action should be performed.
Range timingRange;

//  An optional value describing when the action should be performed.
Timing timingTiming;

//  The participant that should perform or be responsible for this action.
List<Reference> participant;

//  The type of action to perform (create, update, remove).
CodeableConcept type;

//  Defines the grouping behavior for the action and its children.
String groupingBehavior;

//  Defines the selection behavior for the action and its children.
String selectionBehavior;

//  Defines expectations around whether an action is required.
String requiredBehavior;

//  Defines whether the action should usually be preselected.
String precheckBehavior;

//  Defines whether the action can be selected multiple times.
String cardinalityBehavior;

//  The resource that is the target of the action (e.g.
// CommunicationRequest).
Reference resource;

//  Sub actions.
List<RequestGroup_Action> action;

RequestGroup_Action(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.prefix,
    this.title,
    this.description,
    this.textEquivalent,
    this.priority,
    this.code,
    this.documentation,
    this.condition,
    this.relatedAction,
    this.timingDateTime,
    this.timingAge,
    this.timingPeriod,
    this.timingDuration,
    this.timingRange,
    this.timingTiming,
    this.participant,
    this.type,
    this.groupingBehavior,
    this.selectionBehavior,
    this.requiredBehavior,
    this.precheckBehavior,
    this.cardinalityBehavior,
    this.resource,
    this.action,
    });

  factory RequestGroup_Action.fromJson(Map<String, dynamic> json) => _$RequestGroup_ActionFromJson(json);
  Map<String, dynamic> toJson() => _$RequestGroup_ActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RequestGroup_Condition {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kind of condition.
String kind;

//  An expression that returns true or false, indicating whether or not
// the condition is satisfied.
Expression expression;

RequestGroup_Condition(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.kind,
    this.expression,
    });

  factory RequestGroup_Condition.fromJson(Map<String, dynamic> json) => _$RequestGroup_ConditionFromJson(json);
  Map<String, dynamic> toJson() => _$RequestGroup_ConditionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RequestGroup_RelatedAction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The element id of the action this is related to.
String actionId;

//  The relationship of this action to the related action.
String relationship;

//  A duration or range of durations to apply to the relationship. For
// example, 30-60 minutes before.
Duration offsetDuration;

//  A duration or range of durations to apply to the relationship. For
// example, 30-60 minutes before.
Range offsetRange;

RequestGroup_RelatedAction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.actionId,
    this.relationship,
    this.offsetDuration,
    this.offsetRange,
    });

  factory RequestGroup_RelatedAction.fromJson(Map<String, dynamic> json) => _$RequestGroup_RelatedActionFromJson(json);
  Map<String, dynamic> toJson() => _$RequestGroup_RelatedActionToJson(this);
}

part 'researchDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ResearchDefinition {

//  This is a ResearchDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this research definition when
// it is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this research definition is (or will be) published. This URL can be
// the target of a canonical reference. It SHALL remain the same when the
// research definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this research definition
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the research
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the research definition
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence. To provide a version consistent with the
// Decision Support Service specification, use the format
// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
// knowledge assets, refer to the Decision Support Service specification.
// Note that a version is required for non-experimental active artifacts.
String version;

//  A natural language name identifying the research definition. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the research definition.
String title;

//  The short title provides an alternate title for use in informal
// descriptive contexts where the full, formal title is not necessary.
String shortTitle;

//  An explanatory or alternate title for the ResearchDefinition giving
// additional information about its content.
String subtitle;

//  The status of this research definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this research definition is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The intended subjects for the ResearchDefinition. If this element is
// not provided, a Patient subject is assumed, but the subject of the
// ResearchDefinition can be anything.
CodeableConcept subjectCodeableConcept;

//  The intended subjects for the ResearchDefinition. If this element is
// not provided, a Patient subject is assumed, but the subject of the
// ResearchDefinition can be anything.
Reference subjectReference;

//  The date  (and optionally time) when the research definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the research definition changes.
DateTime date;

//  The name of the organization or individual that published the research
// definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the research definition
// from a consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<String> comment;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate research definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the research definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this research definition is needed and why it has
// been designed as it has.
String purpose;

//  A detailed description, from a clinical perspective, of how the
// ResearchDefinition is used.
String usage;

//  A copyright statement relating to the research definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the research definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the research definition content was or is
// planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the ResearchDefinition.
// Topics provide a high-level categorization grouping types of
// ResearchDefinitions that can be useful for filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a Library resource containing the formal logic used by
// the ResearchDefinition.
List<String> library;

//  A reference to a ResearchElementDefinition resource that defines the
// population for the research.
Reference population;

//  A reference to a ResearchElementDefinition resource that defines the
// exposure for the research.
Reference exposure;

//  A reference to a ResearchElementDefinition resource that defines the
// exposureAlternative for the research.
Reference exposureAlternative;

//  A reference to a ResearchElementDefinition resomece that defines the
// outcome for the research.
Reference outcome;

ResearchDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.shortTitle,
    this.subtitle,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.comment,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.library,
    this.population,
    this.exposure,
    this.exposureAlternative,
    this.outcome,
    });

  factory ResearchDefinition.fromJson(Map<String, dynamic> json) => _$ResearchDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchDefinitionToJson(this);
}

part 'researchElementDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class ResearchElementDefinition {

//  This is a ResearchElementDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this research element
// definition when it is referenced in a specification, model, design or
// an instance; also called its canonical identifier. This SHOULD be
// globally unique and SHOULD be a literal address at which at which an
// authoritative instance of this research element definition is (or will
// be) published. This URL can be the target of a canonical reference. It
// SHALL remain the same when the research element definition is stored on
// different servers.
String url;

//  A formal identifier that is used to identify this research element
// definition when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the research
// element definition when it is referenced in a specification, model,
// design or instance. This is an arbitrary value managed by the research
// element definition author and is not expected to be globally unique.
// For example, it might be a timestamp (e.g. yyyymmdd) if a managed
// version is not available. There is also no expectation that versions
// can be placed in a lexicographical sequence. To provide a version
// consistent with the Decision Support Service specification, use the
// format Major.Minor.Revision (e.g. 1.0.0). For more information on
// versioning knowledge assets, refer to the Decision Support Service
// specification. Note that a version is required for non-experimental
// active artifacts.
String version;

//  A natural language name identifying the research element definition.
// This name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the research element
// definition.
String title;

//  The short title provides an alternate title for use in informal
// descriptive contexts where the full, formal title is not necessary.
String shortTitle;

//  An explanatory or alternate title for the ResearchElementDefinition
// giving additional information about its content.
String subtitle;

//  The status of this research element definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this research element definition is
// authored for testing purposes (or education/evaluation/marketing) and
// is not intended to be used for genuine usage.
bool experimental;

//  The intended subjects for the ResearchElementDefinition. If this
// element is not provided, a Patient subject is assumed, but the subject
// of the ResearchElementDefinition can be anything.
CodeableConcept subjectCodeableConcept;

//  The intended subjects for the ResearchElementDefinition. If this
// element is not provided, a Patient subject is assumed, but the subject
// of the ResearchElementDefinition can be anything.
Reference subjectReference;

//  The date  (and optionally time) when the research element definition
// was published. The date must change when the business version changes
// and it must change if the status code changes. In addition, it should
// change when the substantive content of the research element definition
// changes.
DateTime date;

//  The name of the organization or individual that published the research
// element definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the research element
// definition from a consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<String> comment;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate research element definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the research element definition
// is intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this research element definition is needed and why
// it has been designed as it has.
String purpose;

//  A detailed description, from a clinical perspective, of how the
// ResearchElementDefinition is used.
String usage;

//  A copyright statement relating to the research element definition
// and/or its contents. Copyright statements are generally legal
// restrictions on the use and publishing of the research element
// definition.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the research element definition content was or
// is planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the
// ResearchElementDefinition. Topics provide a high-level categorization
// grouping types of ResearchElementDefinitions that can be useful for
// filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  A reference to a Library resource containing the formal logic used by
// the ResearchElementDefinition.
List<String> library;

//  The type of research element, a population, an exposure, or an
// outcome.
String type; // <code> enum: population/exposure/outcome;

//  The type of the outcome (e.g. Dichotomous, Continuous, or
// Descriptive).
String variableType; // <code> enum: dichotomous/continuous/descriptive;

//  A characteristic that defines the members of the research element.
// Multiple characteristics are applied with "and" semantics.
List<ResearchElementDefinition_Characteristic> characteristic;

ResearchElementDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.shortTitle,
    this.subtitle,
    this.status,
    this.experimental,
    this.subjectCodeableConcept,
    this.subjectReference,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.comment,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.usage,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.library,
    this.type,
    this.variableType,
    this.characteristic,
    });

  factory ResearchElementDefinition.fromJson(Map<String, dynamic> json) => _$ResearchElementDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchElementDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ResearchElementDefinition_Characteristic {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Define members of the research element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
CodeableConcept definitionCodeableConcept;

//  Define members of the research element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
String definitionCanonical; //  pattern: ^\S*$

//  Define members of the research element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
Expression definitionExpression;

//  Define members of the research element using Codes (such as condition,
// medication, or observation), Expressions ( using an expression language
// such as FHIRPath or CQL) or DataRequirements (such as Diabetes
// diagnosis onset in the last year).
DataRequirement definitionDataRequirement;

//  Use UsageContext to define the members of the population, such as Age
// Ranges, Genders, Settings.
List<UsageContext> usageContext;

//  When true, members with this characteristic are excluded from the
// element.
bool exclude;

//  Specifies the UCUM unit for the outcome.
CodeableConcept unitOfMeasure;

//  A narrative description of the time period the study covers.
String studyEffectiveDescription;

//  Indicates what effective period the study covers.
String studyEffectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Indicates what effective period the study covers.
Period studyEffectivePeriod;

//  Indicates what effective period the study covers.
Duration studyEffectiveDuration;

//  Indicates what effective period the study covers.
Timing studyEffectiveTiming;

//  Indicates duration from the study initiation.
Duration studyEffectiveTimeFromStart;

//  Indicates how elements are aggregated within the study effective
// period.
String studyEffectiveGroupMeasure; // <code> enum: mean/median/mean-of-mean/mean-of-median/median-of-mean/median-of-median;

//  A narrative description of the time period the study covers.
String participantEffectiveDescription;

//  Indicates what effective period the study covers.
String participantEffectiveDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Indicates what effective period the study covers.
Period participantEffectivePeriod;

//  Indicates what effective period the study covers.
Duration participantEffectiveDuration;

//  Indicates what effective period the study covers.
Timing participantEffectiveTiming;

//  Indicates duration from the participant's study entry.
Duration participantEffectiveTimeFromStart;

//  Indicates how elements are aggregated within the study effective
// period.
String participantEffectiveGroupMeasure; // <code> enum: mean/median/mean-of-mean/mean-of-median/median-of-mean/median-of-median;

ResearchElementDefinition_Characteristic(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.definitionCodeableConcept,
    this.definitionCanonical,
    this.definitionExpression,
    this.definitionDataRequirement,
    this.usageContext,
    this.exclude,
    this.unitOfMeasure,
    this.studyEffectiveDescription,
    this.studyEffectiveDateTime,
    this.studyEffectivePeriod,
    this.studyEffectiveDuration,
    this.studyEffectiveTiming,
    this.studyEffectiveTimeFromStart,
    this.studyEffectiveGroupMeasure,
    this.participantEffectiveDescription,
    this.participantEffectiveDateTime,
    this.participantEffectivePeriod,
    this.participantEffectiveDuration,
    this.participantEffectiveTiming,
    this.participantEffectiveTimeFromStart,
    this.participantEffectiveGroupMeasure,
    });

  factory ResearchElementDefinition_Characteristic.fromJson(Map<String, dynamic> json) => _$ResearchElementDefinition_CharacteristicFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchElementDefinition_CharacteristicToJson(this);
}

part 'researchStudy.g.dart';

@JsonSerializable(explicitToJson: true)
class ResearchStudy {

//  This is a ResearchStudy resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this research study by the sponsor or other
// systems.
List<Identifier> identifier;

//  A short, descriptive user-friendly label for the study.
String title;

//  The set of steps expected to be performed as part of the execution of
// the study.
List<Reference> protocol;

//  A larger research study of which this particular study is a component
// or step.
List<Reference> partOf;

//  The current state of the study.
String status; // <code> enum: active/administratively-completed/approved/closed-to-accrual/closed-to-accrual-and-intervention/completed/disapproved/in-review/temporarily-closed-to-accrual/temporarily-closed-to-accrual-and-intervention/withdrawn;

//  The type of study based upon the intent of the study's activities. A
// classification of the intent of the study.
CodeableConcept primaryPurposeType;

//  The stage in the progression of a therapy from initial experimental
// use in humans in clinical trials to post-market evaluation.
CodeableConcept phase;

//  Codes categorizing the type of study such as investigational vs.
// observational, type of blinding, type of randomization, safety vs.
// efficacy, etc.
List<CodeableConcept> category;

//  The medication(s), food(s), therapy(ies), device(s) or other concerns
// or interventions that the study is seeking to gain more information
// about.
List<CodeableConcept> focus;

//  The condition that is the focus of the study.  For example, In a study
// to examine risk factors for Lupus, might have as an inclusion criterion
// "healthy volunteer", but the target condition code would be a Lupus
// SNOMED code.
List<CodeableConcept> condition;

//  Contact details to assist a user in learning more about or engaging
// with the study.
List<ContactDetail> contact;

//  Citations, references and other related documents.
List<RelatedArtifact> relatedArtifact;

//  Key terms to aid in searching for or filtering the study.
List<CodeableConcept> keyword;

//  Indicates a country, state or other region where the study is taking
// place.
List<CodeableConcept> location;

//  A full description of how the study is being conducted.
String description;

//  Reference to a Group that defines the criteria for and quantity of
// subjects participating in the study.  E.g. " 200 female Europeans
// between the ages of 20 and 45 with early onset diabetes".
List<Reference> enrollment;

//  Identifies the start date and the expected (or actual, depending on
// status) end date for the study.
Period period;

//  An organization that initiates the investigation and is legally
// responsible for the study.
Reference sponsor;

//  A researcher in a study who oversees multiple aspects of the study,
// such as concept development, protocol writing, protocol submission for
// IRB approval, participant recruitment, informed consent, data
// collection, analysis, interpretation and presentation.
Reference principalInvestigator;

//  A facility in which study activities are conducted.
List<Reference> site;

//  A description and/or code explaining the premature termination of the
// study.
CodeableConcept reasonStopped;

//  Comments made about the study by the performer, subject or other
// participants.
List<Annotation> note;

//  Describes an expected sequence of events for one of the participants
// of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B,
// wash-out, follow-up.
List<ResearchStudy_Arm> arm;

//  A goal that the study is aiming to achieve in terms of a scientific
// question to be answered by the analysis of data collected during the
// study.
List<ResearchStudy_Objective> objective;

ResearchStudy(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.title,
    this.protocol,
    this.partOf,
    this.status,
    this.primaryPurposeType,
    this.phase,
    this.category,
    this.focus,
    this.condition,
    this.contact,
    this.relatedArtifact,
    this.keyword,
    this.location,
    this.description,
    this.enrollment,
    this.period,
    this.sponsor,
    this.principalInvestigator,
    this.site,
    this.reasonStopped,
    this.note,
    this.arm,
    this.objective,
    });

  factory ResearchStudy.fromJson(Map<String, dynamic> json) => _$ResearchStudyFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchStudyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ResearchStudy_Arm {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique, human-readable label for this arm of the study.
String name;

//  Categorization of study arm, e.g. experimental, active comparator,
// placebo comparater.
CodeableConcept type;

//  A succinct description of the path through the study that would be
// followed by a subject adhering to this arm.
String description;

ResearchStudy_Arm(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    this.description,
    });

  factory ResearchStudy_Arm.fromJson(Map<String, dynamic> json) => _$ResearchStudy_ArmFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchStudy_ArmToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ResearchStudy_Objective {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Unique, human-readable label for this objective of the study.
String name;

//  The kind of study objective.
CodeableConcept type;

ResearchStudy_Objective(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    });

  factory ResearchStudy_Objective.fromJson(Map<String, dynamic> json) => _$ResearchStudy_ObjectiveFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchStudy_ObjectiveToJson(this);
}

part 'researchSubject.g.dart';

@JsonSerializable(explicitToJson: true)
class ResearchSubject {

//  This is a ResearchSubject resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this research subject for a study.
List<Identifier> identifier;

//  The current state of the subject.
String status; // <code> enum: candidate/eligible/follow-up/ineligible/not-registered/off-study/on-study/on-study-intervention/on-study-observation/pending-on-study/potential-candidate/screening/withdrawn;

//  The dates the subject began and ended their participation in the
// study.
Period period;

//  Reference to the study the subject is participating in.
Reference study;

//  The record of the person or animal who is involved in the study.
Reference individual;

//  The name of the arm in the study the subject is expected to follow as
// part of this study.
String assignedArm;

//  The name of the arm in the study the subject actually followed as part
// of this study.
String actualArm;

//  A record of the patient's informed agreement to participate in the
// study.
Reference consent;

ResearchSubject(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.period,
    this.study,
    this.individual,
    this.assignedArm,
    this.actualArm,
    this.consent,
    });

  factory ResearchSubject.fromJson(Map<String, dynamic> json) => _$ResearchSubjectFromJson(json);
  Map<String, dynamic> toJson() => _$ResearchSubjectToJson(this);
}

part 'riskAssessment.g.dart';

@JsonSerializable(explicitToJson: true)
class RiskAssessment {

//  This is a RiskAssessment resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifier assigned to the risk assessment.
List<Identifier> identifier;

//  A reference to the request that is fulfilled by this risk assessment.
Reference basedOn;

//  A reference to a resource that this risk assessment is part of, such
// as a Procedure.
Reference parent;

//  The status of the RiskAssessment, using the same statuses as an
// Observation.
String status;

//  The algorithm, process or mechanism used to evaluate the risk.
CodeableConcept method;

//  The type of the risk assessment performed.
CodeableConcept code;

//  The patient or group the risk assessment applies to.
Reference subject;

//  The encounter where the assessment was performed.
Reference encounter;

//  The date (and possibly time) the risk assessment was performed.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date (and possibly time) the risk assessment was performed.
Period occurrencePeriod;

//  For assessments or prognosis specific to a particular condition,
// indicates the condition being assessed.
Reference condition;

//  The provider or software application that performed the assessment.
Reference performer;

//  The reason the risk assessment was performed.
List<CodeableConcept> reasonCode;

//  Resources supporting the reason the risk assessment was performed.
List<Reference> reasonReference;

//  Indicates the source data considered as part of the assessment (for
// example, FamilyHistory, Observations, Procedures, Conditions, etc.).
List<Reference> basis;

//  Describes the expected outcome for the subject.
List<RiskAssessment_Prediction> prediction;

//  A description of the steps that might be taken to reduce the
// identified risk(s).
String mitigation;

//  Additional comments about the risk assessment.
List<Annotation> note;

RiskAssessment(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.parent,
    this.status,
    this.method,
    this.code,
    this.subject,
    this.encounter,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.condition,
    this.performer,
    this.reasonCode,
    this.reasonReference,
    this.basis,
    this.prediction,
    this.mitigation,
    this.note,
    });

  factory RiskAssessment.fromJson(Map<String, dynamic> json) => _$RiskAssessmentFromJson(json);
  Map<String, dynamic> toJson() => _$RiskAssessmentToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskAssessment_Prediction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  One of the potential outcomes for the patient (e.g. remission, death, 
// a particular condition).
CodeableConcept outcome;

//  Indicates how likely the outcome is (in the specified timeframe).
double probabilityDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  Indicates how likely the outcome is (in the specified timeframe).
Range probabilityRange;

//  Indicates how likely the outcome is (in the specified timeframe),
// expressed as a qualitative value (e.g. low, medium, or high).
CodeableConcept qualitativeRisk;

//  Indicates the risk for this particular subject (with their specific
// characteristics) divided by the risk of the population in general. 
// (Numbers greater than 1 = higher risk than the population, numbers less
// than 1 = lower risk.).
double relativeRisk;

//  Indicates the period of time or age range of the subject to which the
// specified probability applies.
Period whenPeriod;

//  Indicates the period of time or age range of the subject to which the
// specified probability applies.
Range whenRange;

//  Additional information explaining the basis for the prediction.
String rationale;

RiskAssessment_Prediction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.outcome,
    this.probabilityDecimal,
    this.probabilityRange,
    this.qualitativeRisk,
    this.relativeRisk,
    this.whenPeriod,
    this.whenRange,
    this.rationale,
    });

  factory RiskAssessment_Prediction.fromJson(Map<String, dynamic> json) => _$RiskAssessment_PredictionFromJson(json);
  Map<String, dynamic> toJson() => _$RiskAssessment_PredictionToJson(this);
}

part 'riskEvidenceSynthesis.g.dart';

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis {

//  This is a RiskEvidenceSynthesis resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this risk evidence synthesis
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this risk evidence synthesis is (or will be) published.
// This URL can be the target of a canonical reference. It SHALL remain
// the same when the risk evidence synthesis is stored on different
// servers.
String url;

//  A formal identifier that is used to identify this risk evidence
// synthesis when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the risk
// evidence synthesis when it is referenced in a specification, model,
// design or instance. This is an arbitrary value managed by the risk
// evidence synthesis author and is not expected to be globally unique.
// For example, it might be a timestamp (e.g. yyyymmdd) if a managed
// version is not available. There is also no expectation that versions
// can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the risk evidence synthesis. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the risk evidence
// synthesis.
String title;

//  The status of this risk evidence synthesis. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  The date  (and optionally time) when the risk evidence synthesis was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the risk evidence synthesis
// changes.
DateTime date;

//  The name of the organization or individual that published the risk
// evidence synthesis.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the risk evidence
// synthesis from a consumer's perspective.
String description;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate risk evidence synthesis instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the risk evidence synthesis is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  A copyright statement relating to the risk evidence synthesis and/or
// its contents. Copyright statements are generally legal restrictions on
// the use and publishing of the risk evidence synthesis.
String copyright;

//  The date on which the resource content was approved by the publisher.
// Approval happens once when the content is officially approved for
// usage.
String approvalDate;

//  The date on which the resource content was last reviewed. Review
// happens periodically after approval but does not change the original
// approval date.
String lastReviewDate;

//  The period during which the risk evidence synthesis content was or is
// planned to be in active use.
Period effectivePeriod;

//  Descriptive topics related to the content of the
// RiskEvidenceSynthesis. Topics provide a high-level categorization
// grouping types of EffectEvidenceSynthesiss that can be useful for
// filtering and searching.
List<CodeableConcept> topic;

//  An individiual or organization primarily involved in the creation and
// maintenance of the content.
List<ContactDetail> author;

//  An individual or organization primarily responsible for internal
// coherence of the content.
List<ContactDetail> editor;

//  An individual or organization primarily responsible for review of some
// aspect of the content.
List<ContactDetail> reviewer;

//  An individual or organization responsible for officially endorsing the
// content for use in some setting.
List<ContactDetail> endorser;

//  Related artifacts such as additional documentation, justification, or
// bibliographic references.
List<RelatedArtifact> relatedArtifact;

//  Type of synthesis eg meta-analysis.
CodeableConcept synthesisType;

//  Type of study eg randomized trial.
CodeableConcept studyType;

//  A reference to a EvidenceVariable resource that defines the population
// for the research.
Reference population;

//  A reference to a EvidenceVariable resource that defines the exposure
// for the research.
Reference exposure;

//  A reference to a EvidenceVariable resomece that defines the outcome
// for the research.
Reference outcome;

//  A description of the size of the sample involved in the synthesis.
RiskEvidenceSynthesis_SampleSize sampleSize;

//  The estimated risk of the outcome.
RiskEvidenceSynthesis_RiskEstimate riskEstimate;

//  A description of the certainty of the risk estimate.
List<RiskEvidenceSynthesis_Certainty> certainty;

RiskEvidenceSynthesis(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.note,
    this.useContext,
    this.jurisdiction,
    this.copyright,
    this.approvalDate,
    this.lastReviewDate,
    this.effectivePeriod,
    this.topic,
    this.author,
    this.editor,
    this.reviewer,
    this.endorser,
    this.relatedArtifact,
    this.synthesisType,
    this.studyType,
    this.population,
    this.exposure,
    this.outcome,
    this.sampleSize,
    this.riskEstimate,
    this.certainty,
    });

  factory RiskEvidenceSynthesis.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesisFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesisToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis_SampleSize {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable summary of sample size.
String description;

//  Number of studies included in this evidence synthesis.
int numberOfStudies;

//  Number of participants included in this evidence synthesis.
int numberOfParticipants;

RiskEvidenceSynthesis_SampleSize(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.numberOfStudies,
    this.numberOfParticipants,
    });

  factory RiskEvidenceSynthesis_SampleSize.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesis_SampleSizeFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesis_SampleSizeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis_RiskEstimate {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Human-readable summary of risk estimate.
String description;

//  Examples include proportion and mean.
CodeableConcept type;

//  The point estimate of the risk estimate.
double value;

//  Specifies the UCUM unit for the outcome.
CodeableConcept unitOfMeasure;

//  The sample size for the group that was measured for this risk
// estimate.
int denominatorCount;

//  The number of group members with the outcome of interest.
int numeratorCount;

//  A description of the precision of the estimate for the effect.
List<RiskEvidenceSynthesis_PrecisionEstimate> precisionEstimate;

RiskEvidenceSynthesis_RiskEstimate(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.type,
    this.value,
    this.unitOfMeasure,
    this.denominatorCount,
    this.numeratorCount,
    this.precisionEstimate,
    });

  factory RiskEvidenceSynthesis_RiskEstimate.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesis_RiskEstimateFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesis_RiskEstimateToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis_PrecisionEstimate {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Examples include confidence interval and interquartile range.
CodeableConcept type;

//  Use 95 for a 95% confidence interval.
double level;

//  Lower bound of confidence interval.
double from;

//  Upper bound of confidence interval.
double to;

RiskEvidenceSynthesis_PrecisionEstimate(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.level,
    this.from,
    this.to,
    });

  factory RiskEvidenceSynthesis_PrecisionEstimate.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesis_PrecisionEstimateFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesis_PrecisionEstimateToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis_Certainty {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A rating of the certainty of the effect estimate.
List<CodeableConcept> rating;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

//  A description of a component of the overall certainty.
List<RiskEvidenceSynthesis_CertaintySubcomponent> certaintySubcomponent;

RiskEvidenceSynthesis_Certainty(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.rating,
    this.note,
    this.certaintySubcomponent,
    });

  factory RiskEvidenceSynthesis_Certainty.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesis_CertaintyFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesis_CertaintyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class RiskEvidenceSynthesis_CertaintySubcomponent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type of subcomponent of certainty rating.
CodeableConcept type;

//  A rating of a subcomponent of rating certainty.
List<CodeableConcept> rating;

//  A human-readable string to clarify or explain concepts about the
// resource.
List<Annotation> note;

RiskEvidenceSynthesis_CertaintySubcomponent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.rating,
    this.note,
    });

  factory RiskEvidenceSynthesis_CertaintySubcomponent.fromJson(Map<String, dynamic> json) => _$RiskEvidenceSynthesis_CertaintySubcomponentFromJson(json);
  Map<String, dynamic> toJson() => _$RiskEvidenceSynthesis_CertaintySubcomponentToJson(this);
}

part 'schedule.g.dart';

@JsonSerializable(explicitToJson: true)
class Schedule {

//  This is a Schedule resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  External Ids for this item.
List<Identifier> identifier;

//  Whether this schedule record is in active use or should not be used
// (such as was entered in error).
bool active;

//  A broad categorization of the service that is to be performed during
// this appointment.
List<CodeableConcept> serviceCategory;

//  The specific service that is to be performed during this appointment.
List<CodeableConcept> serviceType;

//  The specialty of a practitioner that would be required to perform the
// service requested in this appointment.
List<CodeableConcept> specialty;

//  Slots that reference this schedule resource provide the availability
// details to these referenced resource(s).
List<Reference> actor;

//  The period of time that the slots that reference this Schedule
// resource cover (even if none exist). These  cover the amount of time
// that an organization's planning horizon; the interval for which they
// are currently accepting appointments. This does not define a "template"
// for planning outside these dates.
Period planningHorizon;

//  Comments on the availability to describe any extended information.
// Such as custom constraints on the slots that may be associated.
String comment;

Schedule(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.active,
    this.serviceCategory,
    this.serviceType,
    this.specialty,
    this.actor,
    this.planningHorizon,
    this.comment,
    });

  factory Schedule.fromJson(Map<String, dynamic> json) => _$ScheduleFromJson(json);
  Map<String, dynamic> toJson() => _$ScheduleToJson(this);
}

part 'searchParameter.g.dart';

@JsonSerializable(explicitToJson: true)
class SearchParameter {

//  This is a SearchParameter resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this search parameter when it
// is referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this search parameter is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// search parameter is stored on different servers.
String url;

//  The identifier that is used to identify this version of the search
// parameter when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the search parameter
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the search parameter. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  Where this search parameter is originally defined. If a derivedFrom is
// provided, then the details in the search parameter must be consistent
// with the definition from which it is defined. i.e. the parameter should
// have the same meaning, and (usually) the functionality should be a
// proper subset of the underlying search parameter.
String derivedFrom;

//  The status of this search parameter. Enables tracking the life-cycle
// of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this search parameter is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the search parameter was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the search parameter changes.
DateTime date;

//  The name of the organization or individual that published the search
// parameter.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  And how it used.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate search parameter instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the search parameter is intended
// to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this search parameter is needed and why it has been
// designed as it has.
String purpose;

//  The code used in the URL or the parameter name in a parameters
// resource for this search parameter.
String code;

//  The base resource type(s) that this search parameter can be used
// against.
List<String> base;

//  The type of value that a search parameter may contain, and how the
// content is interpreted.
String type; // <code> enum: number/date/string/token/reference/composite/quantity/uri/special;

//  A FHIRPath expression that returns a set of elements for the search
// parameter.
String expression;

//  An XPath expression that returns a set of elements for the search
// parameter.
String xpath;

//  How the search parameter relates to the set of elements returned by
// evaluating the xpath query.
String xpathUsage; // <code> enum: normal/phonetic/nearby/distance/other;

//  Types of resource (if a resource is referenced).
List<String> target;

//  Whether multiple values are allowed for each time the parameter
// exists. Values are separated by commas, and the parameter matches if
// any of the values match.
bool multipleOr;

//  Whether multiple parameters are allowed - e.g. more than one parameter
// with the same name. The search matches if all the parameters match.
bool multipleAnd;

//  Comparators supported for the search parameter.
List<String> comparator; // <code> enum: eq/ne/gt/lt/ge/le/sa/eb/ap> comparator;

//  A modifier supported for the search parameter.
List<String> modifier; // <code> enum: missing/exact/contains/not/text/in/not-in/below/above/type/identifier/ofType> modifier;

//  Contains the names of any search parameters which may be chained to
// the containing search parameter. Chained parameters may be added to
// search parameters of type reference and specify that resources will
// only be returned if they contain a reference to a resource which
// matches the chained parameter value. Values for this field should be
// drawn from SearchParameter.code for a parameter on the target resource
// type.
List<String> chain;

//  Used to define the parts of a composite search parameter.
List<SearchParameter_Component> component;

SearchParameter(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.derivedFrom,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.code,
    this.base,
    this.type,
    this.expression,
    this.xpath,
    this.xpathUsage,
    this.target,
    this.multipleOr,
    this.multipleAnd,
    this.comparator,
    this.modifier,
    this.chain,
    this.component,
    });

  factory SearchParameter.fromJson(Map<String, dynamic> json) => _$SearchParameterFromJson(json);
  Map<String, dynamic> toJson() => _$SearchParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SearchParameter_Component {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The definition of the search parameter that describes this part.
String definition;

//  A sub-expression that defines how to extract values for this component
// from the output of the main SearchParameter.expression.
String expression;

SearchParameter_Component(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.definition,
    this.expression,
    });

  factory SearchParameter_Component.fromJson(Map<String, dynamic> json) => _$SearchParameter_ComponentFromJson(json);
  Map<String, dynamic> toJson() => _$SearchParameter_ComponentToJson(this);
}

part 'serviceRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class ServiceRequest {

//  This is a ServiceRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifiers assigned to this order instance by the orderer and/or the
// receiver and/or order fulfiller.
List<Identifier> identifier;

//  The URL pointing to a FHIR-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this
// ServiceRequest.
List<String> instantiatesCanonical;

//  The URL pointing to an externally maintained protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this ServiceRequest.
List<String> instantiatesUri;

//  Plan/proposal/order fulfilled by this request.
List<Reference> basedOn;

//  The request takes the place of the referenced completed or terminated
// request(s).
List<Reference> replaces;

//  A shared identifier common to all service requests that were
// authorized more or less simultaneously by a single author, representing
// the composite or group identifier.
Identifier requisition;

//  The status of the order.
String status;

//  Whether the request is a proposal, plan, an original order or a reflex
// order.
String intent;

//  A code that classifies the service for searching, sorting and display
// purposes (e.g. "Surgical Procedure").
List<CodeableConcept> category;

//  Indicates how quickly the ServiceRequest should be addressed with
// respect to other requests.
String priority;

//  Set this to true if the record is saying that the service/procedure
// should NOT be performed.
bool doNotPerform;

//  A code that identifies a particular service (i.e., procedure,
// diagnostic investigation, or panel of investigations) that have been
// requested.
CodeableConcept code;

//  Additional details and instructions about the how the services are to
// be delivered.   For example, and order for a urinary catheter may have
// an order detail for an external or indwelling catheter, or an order for
// a bandage may require additional instructions specifying how the
// bandage should be applied.
List<CodeableConcept> orderDetail;

//  An amount of service being requested which can be a quantity ( for
// example $1,500 home modification), a ratio ( for example, 20 half day
// visits per month), or a range (2.0 to 1.8 Gy per fraction).
Quantity quantityQuantity;

//  An amount of service being requested which can be a quantity ( for
// example $1,500 home modification), a ratio ( for example, 20 half day
// visits per month), or a range (2.0 to 1.8 Gy per fraction).
Ratio quantityRatio;

//  An amount of service being requested which can be a quantity ( for
// example $1,500 home modification), a ratio ( for example, 20 half day
// visits per month), or a range (2.0 to 1.8 Gy per fraction).
Range quantityRange;

//  On whom or what the service is to be performed. This is usually a
// human patient, but can also be requested on animals, groups of humans
// or animals, devices such as dialysis machines, or even locations
// (typically for environmental scans).
Reference subject;

//  An encounter that provides additional information about the healthcare
// context in which this request is made.
Reference encounter;

//  The date/time at which the requested service should occur.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date/time at which the requested service should occur.
Period occurrencePeriod;

//  The date/time at which the requested service should occur.
Timing occurrenceTiming;

//  If a CodeableConcept is present, it indicates the pre-condition for
// performing the service.  For example "pain", "on flare-up", etc.
bool asNeededBoolean; //  pattern: ^true|false$

//  If a CodeableConcept is present, it indicates the pre-condition for
// performing the service.  For example "pain", "on flare-up", etc.
CodeableConcept asNeededCodeableConcept;

//  When the request transitioned to being actionable.
DateTime authoredOn;

//  The individual who initiated the request and has responsibility for
// its activation.
Reference requester;

//  Desired type of performer for doing the requested service.
CodeableConcept performerType;

//  The desired performer for doing the requested service.  For example,
// the surgeon, dermatopathologist, endoscopist, etc.
List<Reference> performer;

//  The preferred location(s) where the procedure should actually happen
// in coded or free text form. E.g. at home or nursing day care center.
List<CodeableConcept> locationCode;

//  A reference to the the preferred location(s) where the procedure
// should actually happen. E.g. at home or nursing day care center.
List<Reference> locationReference;

//  An explanation or justification for why this service is being
// requested in coded or textual form.   This is often for billing
// purposes.  May relate to the resources referred to in `supportingInfo`.
List<CodeableConcept> reasonCode;

//  Indicates another resource that provides a justification for why this
// service is being requested.   May relate to the resources referred to
// in `supportingInfo`.
List<Reference> reasonReference;

//  Insurance plans, coverage extensions, pre-authorizations and/or
// pre-determinations that may be needed for delivering the requested
// service.
List<Reference> insurance;

//  Additional clinical information about the patient or specimen that may
// influence the services or their interpretations.     This information
// includes diagnosis, clinical findings and other observations.  In
// laboratory ordering these are typically referred to as "ask at order
// entry questions (AOEs)".  This includes observations explicitly
// requested by the producer (filler) to provide context or supporting
// information needed to complete the order. For example,  reporting the
// amount of inspired oxygen for blood gas measurements.
List<Reference> supportingInfo;

//  One or more specimens that the laboratory procedure will use.
List<Reference> specimen;

//  Anatomic location where the procedure should be performed. This is the
// target site.
List<CodeableConcept> bodySite;

//  Any other notes and comments made about the service request. For
// example, internal billing notes.
List<Annotation> note;

//  Instructions in terms that are understood by the patient or consumer.
String patientInstruction;

//  Key events in the history of the request.
List<Reference> relevantHistory;

ServiceRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.replaces,
    this.requisition,
    this.status,
    this.intent,
    this.category,
    this.priority,
    this.doNotPerform,
    this.code,
    this.orderDetail,
    this.quantityQuantity,
    this.quantityRatio,
    this.quantityRange,
    this.subject,
    this.encounter,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.asNeededBoolean,
    this.asNeededCodeableConcept,
    this.authoredOn,
    this.requester,
    this.performerType,
    this.performer,
    this.locationCode,
    this.locationReference,
    this.reasonCode,
    this.reasonReference,
    this.insurance,
    this.supportingInfo,
    this.specimen,
    this.bodySite,
    this.note,
    this.patientInstruction,
    this.relevantHistory,
    });

  factory ServiceRequest.fromJson(Map<String, dynamic> json) => _$ServiceRequestFromJson(json);
  Map<String, dynamic> toJson() => _$ServiceRequestToJson(this);
}

part 'slot.g.dart';

@JsonSerializable(explicitToJson: true)
class Slot {

//  This is a Slot resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  External Ids for this item.
List<Identifier> identifier;

//  A broad categorization of the service that is to be performed during
// this appointment.
List<CodeableConcept> serviceCategory;

//  The type of appointments that can be booked into this slot (ideally
// this would be an identifiable service - which is at a location, rather
// than the location itself). If provided then this overrides the value
// provided on the availability resource.
List<CodeableConcept> serviceType;

//  The specialty of a practitioner that would be required to perform the
// service requested in this appointment.
List<CodeableConcept> specialty;

//  The style of appointment or patient that may be booked in the slot
// (not service type).
CodeableConcept appointmentType;

//  The schedule resource that this slot defines an interval of status
// information.
Reference schedule;

//  busy | free | busy-unavailable | busy-tentative | entered-in-error.
String status; // <code> enum: busy/free/busy-unavailable/busy-tentative/entered-in-error;

//  Date/Time that the slot is to begin.
DateTime start;

//  Date/Time that the slot is to conclude.
DateTime end;

//  This slot has already been overbooked, appointments are unlikely to be
// accepted for this time.
bool overbooked;

//  Comments on the slot to describe any extended information. Such as
// custom constraints on the slot.
String comment;

Slot(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.serviceCategory,
    this.serviceType,
    this.specialty,
    this.appointmentType,
    this.schedule,
    this.status,
    this.start,
    this.end,
    this.overbooked,
    this.comment,
    });

  factory Slot.fromJson(Map<String, dynamic> json) => _$SlotFromJson(json);
  Map<String, dynamic> toJson() => _$SlotToJson(this);
}

part 'specimen.g.dart';

@JsonSerializable(explicitToJson: true)
class Specimen {

//  This is a Specimen resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Id for specimen.
List<Identifier> identifier;

//  The identifier assigned by the lab when accessioning specimen(s). This
// is not necessarily the same as the specimen identifier, depending on
// local lab procedures.
Identifier accessionIdentifier;

//  The availability of the specimen.
String status; // <code> enum: available/unavailable/unsatisfactory/entered-in-error;

//  The kind of material that forms the specimen.
CodeableConcept type;

//  Where the specimen came from. This may be from patient(s), from a
// location (e.g., the source of an environmental sample), or a sampling
// of a substance or a device.
Reference subject;

//  Time when specimen was received for processing or testing.
DateTime receivedTime;

//  Reference to the parent (source) specimen which is used when the
// specimen was either derived from or a component of another specimen.
List<Reference> parent;

//  Details concerning a service request that required a specimen to be
// collected.
List<Reference> request;

//  Details concerning the specimen collection.
Specimen_Collection collection;

//  Details concerning processing and processing steps for the specimen.
List<Specimen_Processing> processing;

//  The container holding the specimen.  The recursive nature of
// containers; i.e. blood in tube in tray in rack is not addressed here.
List<Specimen_Container> container;

//  A mode or state of being that describes the nature of the specimen.
List<CodeableConcept> condition;

//  To communicate any details or issues about the specimen or during the
// specimen collection. (for example: broken vial, sent with patient,
// frozen).
List<Annotation> note;

Specimen(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.accessionIdentifier,
    this.status,
    this.type,
    this.subject,
    this.receivedTime,
    this.parent,
    this.request,
    this.collection,
    this.processing,
    this.container,
    this.condition,
    this.note,
    });

  factory Specimen.fromJson(Map<String, dynamic> json) => _$SpecimenFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Specimen_Collection {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Person who collected the specimen.
Reference collector;

//  Time when specimen was collected from subject - the physiologically
// relevant time.
String collectedDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  Time when specimen was collected from subject - the physiologically
// relevant time.
Period collectedPeriod;

//  The span of time over which the collection of a specimen occurred.
Duration duration;

//  The quantity of specimen collected; for instance the volume of a blood
// sample, or the physical measurement of an anatomic pathology sample.
Quantity quantity;

//  A coded value specifying the technique that is used to perform the
// procedure.
CodeableConcept method;

//  Anatomical location from which the specimen was collected (if subject
// is a patient). This is the target site.  This element is not used for
// environmental specimens.
CodeableConcept bodySite;

//  Abstinence or reduction from some or all food, drink, or both, for a
// period of time prior to sample collection.
CodeableConcept fastingStatusCodeableConcept;

//  Abstinence or reduction from some or all food, drink, or both, for a
// period of time prior to sample collection.
Duration fastingStatusDuration;

Specimen_Collection(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.collector,
    this.collectedDateTime,
    this.collectedPeriod,
    this.duration,
    this.quantity,
    this.method,
    this.bodySite,
    this.fastingStatusCodeableConcept,
    this.fastingStatusDuration,
    });

  factory Specimen_Collection.fromJson(Map<String, dynamic> json) => _$Specimen_CollectionFromJson(json);
  Map<String, dynamic> toJson() => _$Specimen_CollectionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Specimen_Processing {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Textual description of procedure.
String description;

//  A coded value specifying the procedure used to process the specimen.
CodeableConcept procedure;

//  Material used in the processing step.
List<Reference> additive;

//  A record of the time or period when the specimen processing occurred. 
// For example the time of sample fixation or the period of time the
// sample was in formalin.
String timeDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  A record of the time or period when the specimen processing occurred. 
// For example the time of sample fixation or the period of time the
// sample was in formalin.
Period timePeriod;

Specimen_Processing(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.procedure,
    this.additive,
    this.timeDateTime,
    this.timePeriod,
    });

  factory Specimen_Processing.fromJson(Map<String, dynamic> json) => _$Specimen_ProcessingFromJson(json);
  Map<String, dynamic> toJson() => _$Specimen_ProcessingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Specimen_Container {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Id for container. There may be multiple; a manufacturer's bar code,
// lab assigned identifier, etc. The container ID may differ from the
// specimen id in some circumstances.
List<Identifier> identifier;

//  Textual description of the container.
String description;

//  The type of container associated with the specimen (e.g. slide,
// aliquot, etc.).
CodeableConcept type;

//  The capacity (volume or other measure) the container may contain.
Quantity capacity;

//  The quantity of specimen in the container; may be volume, dimensions,
// or other appropriate measurements, depending on the specimen type.
Quantity specimenQuantity;

//  Introduced substance to preserve, maintain or enhance the specimen.
// Examples: Formalin, Citrate, EDTA.
CodeableConcept additiveCodeableConcept;

//  Introduced substance to preserve, maintain or enhance the specimen.
// Examples: Formalin, Citrate, EDTA.
Reference additiveReference;

Specimen_Container(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.description,
    this.type,
    this.capacity,
    this.specimenQuantity,
    this.additiveCodeableConcept,
    this.additiveReference,
    });

  factory Specimen_Container.fromJson(Map<String, dynamic> json) => _$Specimen_ContainerFromJson(json);
  Map<String, dynamic> toJson() => _$Specimen_ContainerToJson(this);
}

part 'specimenDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class SpecimenDefinition {

//  This is a SpecimenDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A business identifier associated with the kind of specimen.
Identifier identifier;

//  The kind of material to be collected.
CodeableConcept typeCollected;

//  Preparation of the patient for specimen collection.
List<CodeableConcept> patientPreparation;

//  Time aspect of specimen collection (duration or offset).
String timeAspect;

//  The action to be performed for collecting the specimen.
List<CodeableConcept> collection;

//  Specimen conditioned in a container as expected by the testing
// laboratory.
List<SpecimenDefinition_TypeTested> typeTested;

SpecimenDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.typeCollected,
    this.patientPreparation,
    this.timeAspect,
    this.collection,
    this.typeTested,
    });

  factory SpecimenDefinition.fromJson(Map<String, dynamic> json) => _$SpecimenDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SpecimenDefinition_TypeTested {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Primary of secondary specimen.
bool isDerived;

//  The kind of specimen conditioned for testing expected by lab.
CodeableConcept type;

//  The preference for this type of conditioned specimen.
String preference; // <code> enum: preferred/alternate;

//  The specimen's container.
SpecimenDefinition_Container container;

//  Requirements for delivery and special handling of this kind of
// conditioned specimen.
String requirement;

//  The usual time that a specimen of this kind is retained after the
// ordered tests are completed, for the purpose of additional testing.
Duration retentionTime;

//  Criterion for rejection of the specimen in its container by the
// laboratory.
List<CodeableConcept> rejectionCriterion;

//  Set of instructions for preservation/transport of the specimen at a
// defined temperature interval, prior the testing process.
List<SpecimenDefinition_Handling> handling;

SpecimenDefinition_TypeTested(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.isDerived,
    this.type,
    this.preference,
    this.container,
    this.requirement,
    this.retentionTime,
    this.rejectionCriterion,
    this.handling,
    });

  factory SpecimenDefinition_TypeTested.fromJson(Map<String, dynamic> json) => _$SpecimenDefinition_TypeTestedFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenDefinition_TypeTestedToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SpecimenDefinition_Container {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of material of the container.
CodeableConcept material;

//  The type of container used to contain this kind of specimen.
CodeableConcept type;

//  Color of container cap.
CodeableConcept cap;

//  The textual description of the kind of container.
String description;

//  The capacity (volume or other measure) of this kind of container.
Quantity capacity;

//  The minimum volume to be conditioned in the container.
Quantity minimumVolumeQuantity;

//  The minimum volume to be conditioned in the container.
String minimumVolumeString; //  pattern: ^[ \r\n\t\S]+$

//  Substance introduced in the kind of container to preserve, maintain or
// enhance the specimen. Examples: Formalin, Citrate, EDTA.
List<SpecimenDefinition_Additive> additive;

//  Special processing that should be applied to the container for this
// kind of specimen.
String preparation;

SpecimenDefinition_Container(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.material,
    this.type,
    this.cap,
    this.description,
    this.capacity,
    this.minimumVolumeQuantity,
    this.minimumVolumeString,
    this.additive,
    this.preparation,
    });

  factory SpecimenDefinition_Container.fromJson(Map<String, dynamic> json) => _$SpecimenDefinition_ContainerFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenDefinition_ContainerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SpecimenDefinition_Additive {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Substance introduced in the kind of container to preserve, maintain or
// enhance the specimen. Examples: Formalin, Citrate, EDTA.
CodeableConcept additiveCodeableConcept;

//  Substance introduced in the kind of container to preserve, maintain or
// enhance the specimen. Examples: Formalin, Citrate, EDTA.
Reference additiveReference;

SpecimenDefinition_Additive(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.additiveCodeableConcept,
    this.additiveReference,
    });

  factory SpecimenDefinition_Additive.fromJson(Map<String, dynamic> json) => _$SpecimenDefinition_AdditiveFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenDefinition_AdditiveToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SpecimenDefinition_Handling {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  It qualifies the interval of temperature, which characterizes an
// occurrence of handling. Conditions that are not related to temperature
// may be handled in the instruction element.
CodeableConcept temperatureQualifier;

//  The temperature interval for this set of handling instructions.
Range temperatureRange;

//  The maximum time interval of preservation of the specimen with these
// conditions.
Duration maxDuration;

//  Additional textual instructions for the preservation or transport of
// the specimen. For instance, 'Protect from light exposure'.
String instruction;

SpecimenDefinition_Handling(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.temperatureQualifier,
    this.temperatureRange,
    this.maxDuration,
    this.instruction,
    });

  factory SpecimenDefinition_Handling.fromJson(Map<String, dynamic> json) => _$SpecimenDefinition_HandlingFromJson(json);
  Map<String, dynamic> toJson() => _$SpecimenDefinition_HandlingToJson(this);
}

part 'structureDefinition.g.dart';

@JsonSerializable(explicitToJson: true)
class StructureDefinition {

//  This is a StructureDefinition resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this structure definition
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this structure definition is (or will be) published. This
// URL can be the target of a canonical reference. It SHALL remain the
// same when the structure definition is stored on different servers.
String url;

//  A formal identifier that is used to identify this structure definition
// when it is represented in other formats, or referenced in a
// specification, model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the structure
// definition when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the structure
// definition author and is not expected to be globally unique. For
// example, it might be a timestamp (e.g. yyyymmdd) if a managed version
// is not available. There is also no expectation that versions can be
// placed in a lexicographical sequence.
String version;

//  A natural language name identifying the structure definition. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the structure
// definition.
String title;

//  The status of this structure definition. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this structure definition is authored
// for testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the structure definition was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the structure definition
// changes.
DateTime date;

//  The name of the organization or individual that published the
// structure definition.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the structure definition
// from a consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate structure definition instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the structure definition is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this structure definition is needed and why it has
// been designed as it has.
String purpose;

//  A copyright statement relating to the structure definition and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the structure definition.
String copyright;

//  A set of key words or terms from external terminologies that may be
// used to assist with indexing and searching of templates nby describing
// the use of this structure definition, or the content it describes.
List<Coding> keyword;

//  The version of the FHIR specification on which this
// StructureDefinition is based - this is the formal version of the
// specification, without the revision number, e.g.
// [publication].[major].[minor], which is 4.0.1. for this version.
String fhirVersion; // <code> enum: 0.01/0.05/0.06/0.11/0.0.80/0.0.81/0.0.82/0.4.0/0.5.0/1.0.0/1.0.1/1.0.2/1.1.0/1.4.0/1.6.0/1.8.0/3.0.0/3.0.1/3.3.0/3.5.0/4.0.0/4.0.1;

//  An external specification that the content is mapped to.
List<StructureDefinition_Mapping> mapping;

//  Defines the kind of structure that this definition is describing.
String kind; // <code> enum: primitive-type/complex-type/resource/logical;

//  Whether structure this definition describes is abstract or not  - that
// is, whether the structure is not intended to be instantiated. For
// Resources and Data types, abstract types will never be exchanged 
// between systems.
bool abstract;

//  Identifies the types of resource or data type elements to which the
// extension can be applied.
List<StructureDefinition_Context> context;

//  A set of rules as FHIRPath Invariants about when the extension can be
// used (e.g. co-occurrence variants for the extension). All the rules
// must be true.
List<String> contextInvariant;

//  The type this structure describes. If the derivation kind is
// 'specialization' then this is the master definition for a type, and
// there is always one of these (a data type, an extension, a resource,
// including abstract ones). Otherwise the structure definition is a
// constraint on the stated type (and in this case, the type cannot be an
// abstract type).  References are URLs that are relative to
// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only
// allowed in logical models.
String type;

//  An absolute URI that is the base structure from which this type is
// derived, either by specialization or constraint.
String baseDefinition;

//  How the type relates to the baseDefinition.
String derivation; // <code> enum: specialization/constraint;

//  A snapshot view is expressed in a standalone form that can be used and
// interpreted without considering the base StructureDefinition.
StructureDefinition_Snapshot snapshot;

//  A differential view is expressed relative to the base
// StructureDefinition - a statement of differences that it applies.
StructureDefinition_Differential differential;

StructureDefinition(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.keyword,
    this.fhirVersion,
    this.mapping,
    this.kind,
    this.abstract,
    this.context,
    this.contextInvariant,
    this.type,
    this.baseDefinition,
    this.derivation,
    this.snapshot,
    this.differential,
    });

  factory StructureDefinition.fromJson(Map<String, dynamic> json) => _$StructureDefinitionFromJson(json);
  Map<String, dynamic> toJson() => _$StructureDefinitionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureDefinition_Mapping {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An Internal id that is used to identify this mapping set when specific
// mappings are made.
String identity;

//  An absolute URI that identifies the specification that this mapping is
// expressed to.
String uri;

//  A name for the specification that is being mapped to.
String name;

//  Comments about this mapping, including version notes, issues, scope
// limitations, and other important notes for usage.
String comment;

StructureDefinition_Mapping(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identity,
    this.uri,
    this.name,
    this.comment,
    });

  factory StructureDefinition_Mapping.fromJson(Map<String, dynamic> json) => _$StructureDefinition_MappingFromJson(json);
  Map<String, dynamic> toJson() => _$StructureDefinition_MappingToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureDefinition_Context {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Defines how to interpret the expression that defines what the context
// of the extension is.
String type; // <code> enum: fhirpath/element/extension;

//  An expression that defines where an extension can be used in
// resources.
String expression;

StructureDefinition_Context(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.expression,
    });

  factory StructureDefinition_Context.fromJson(Map<String, dynamic> json) => _$StructureDefinition_ContextFromJson(json);
  Map<String, dynamic> toJson() => _$StructureDefinition_ContextToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureDefinition_Snapshot {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Captures constraints on each element within the resource.
List<ElementDefinition> element;

StructureDefinition_Snapshot(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.element,
    });

  factory StructureDefinition_Snapshot.fromJson(Map<String, dynamic> json) => _$StructureDefinition_SnapshotFromJson(json);
  Map<String, dynamic> toJson() => _$StructureDefinition_SnapshotToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureDefinition_Differential {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Captures constraints on each element within the resource.
List<ElementDefinition> element;

StructureDefinition_Differential(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.element,
    });

  factory StructureDefinition_Differential.fromJson(Map<String, dynamic> json) => _$StructureDefinition_DifferentialFromJson(json);
  Map<String, dynamic> toJson() => _$StructureDefinition_DifferentialToJson(this);
}

part 'structureMap.g.dart';

@JsonSerializable(explicitToJson: true)
class StructureMap {

//  This is a StructureMap resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this structure map when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this structure map is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the
// structure map is stored on different servers.
String url;

//  A formal identifier that is used to identify this structure map when
// it is represented in other formats, or referenced in a specification,
// model, design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the structure
// map when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the structure map
// author and is not expected to be globally unique. For example, it might
// be a timestamp (e.g. yyyymmdd) if a managed version is not available.
// There is also no expectation that versions can be placed in a
// lexicographical sequence.
String version;

//  A natural language name identifying the structure map. This name
// should be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the structure map.
String title;

//  The status of this structure map. Enables tracking the life-cycle of
// the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this structure map is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the structure map was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the structure map changes.
DateTime date;

//  The name of the organization or individual that published the
// structure map.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the structure map from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate structure map instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the structure map is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this structure map is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the structure map and/or its
// contents. Copyright statements are generally legal restrictions on the
// use and publishing of the structure map.
String copyright;

//  A structure definition used by this map. The structure definition may
// describe instances that are converted, or the instances that are
// produced.
List<StructureMap_Structure> structure;

//  Other maps used by this map (canonical URLs).
List<String> import;

//  Organizes the mapping into manageable chunks for human review/ease of
// maintenance.
List<StructureMap_Group> group;

StructureMap(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.structure,
    this.import,
    this.group,
    });

  factory StructureMap.fromJson(Map<String, dynamic> json) => _$StructureMapFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMapToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Structure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The canonical reference to the structure.
String url;

//  How the referenced structure is used in this mapping.
String mode; // <code> enum: source/queried/target/produced;

//  The name used for this type in the map.
String alias;

//  Documentation that describes how the structure is used in the mapping.
String documentation;

StructureMap_Structure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.url,
    this.mode,
    this.alias,
    this.documentation,
    });

  factory StructureMap_Structure.fromJson(Map<String, dynamic> json) => _$StructureMap_StructureFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_StructureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Group {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A unique name for the group for the convenience of human readers.
String name;

//  Another group that this group adds rules to.
String extends;

//  If this is the default rule set to apply for the source type or this
// combination of types.
String typeMode; // <code> enum: none/types/type-and-types;

//  Additional supporting documentation that explains the purpose of the
// group and the types of mappings within it.
String documentation;

//  A name assigned to an instance of data. The instance must be provided
// when the mapping is invoked.
List<StructureMap_Input> input;

//  Transform Rule from source to target.
List<StructureMap_Rule> rule;

StructureMap_Group(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.extends,
    this.typeMode,
    this.documentation,
    this.input,
    this.rule,
    });

  factory StructureMap_Group.fromJson(Map<String, dynamic> json) => _$StructureMap_GroupFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_GroupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Input {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name for this instance of data.
String name;

//  Type for this instance of data.
String type;

//  Mode for this instance of data.
String mode; // <code> enum: source/target;

//  Documentation for this instance of data.
String documentation;

StructureMap_Input(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    this.mode,
    this.documentation,
    });

  factory StructureMap_Input.fromJson(Map<String, dynamic> json) => _$StructureMap_InputFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_InputToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Rule {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name of the rule for internal references.
String name;

//  Source inputs to the mapping.
List<StructureMap_Source> source;

//  Content to create because of this mapping rule.
List<StructureMap_Target> target;

//  Rules contained in this rule.
List<StructureMap_Rule> rule;

//  Which other rules to apply in the context of this rule.
List<StructureMap_Dependent> dependent;

//  Documentation for this instance of data.
String documentation;

StructureMap_Rule(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.source,
    this.target,
    this.rule,
    this.dependent,
    this.documentation,
    });

  factory StructureMap_Rule.fromJson(Map<String, dynamic> json) => _$StructureMap_RuleFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_RuleToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Source {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type or variable this rule applies to.
String context;

//  Specified minimum cardinality for the element. This is optional; if
// present, it acts an implicit check on the input content.
int min;

//  Specified maximum cardinality for the element - a number or a "*".
// This is optional; if present, it acts an implicit check on the input
// content (* just serves as documentation; it's the default value).
String max;

//  Specified type for the element. This works as a condition on the
// mapping - use for polymorphic elements.
String type;

//  A value to use if there is no existing value in the source object.
String defaultValueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  A value to use if there is no existing value in the source object.
bool defaultValueBoolean; //  pattern: ^true|false$

//  A value to use if there is no existing value in the source object.
String defaultValueCanonical; //  pattern: ^\S*$

//  A value to use if there is no existing value in the source object.
String defaultValueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  A value to use if there is no existing value in the source object.
String defaultValueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  A value to use if there is no existing value in the source object.
String defaultValueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  A value to use if there is no existing value in the source object.
double defaultValueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  A value to use if there is no existing value in the source object.
String defaultValueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  A value to use if there is no existing value in the source object.
String defaultValueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  A value to use if there is no existing value in the source object.
int defaultValueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  A value to use if there is no existing value in the source object.
String defaultValueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  A value to use if there is no existing value in the source object.
String defaultValueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  A value to use if there is no existing value in the source object.
int defaultValuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  A value to use if there is no existing value in the source object.
String defaultValueString; //  pattern: ^[ \r\n\t\S]+$

//  A value to use if there is no existing value in the source object.
String defaultValueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  A value to use if there is no existing value in the source object.
int defaultValueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  A value to use if there is no existing value in the source object.
String defaultValueUri; //  pattern: ^\S*$

//  A value to use if there is no existing value in the source object.
String defaultValueUrl; //  pattern: ^\S*$

//  A value to use if there is no existing value in the source object.
String defaultValueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  A value to use if there is no existing value in the source object.
Address defaultValueAddress;

//  A value to use if there is no existing value in the source object.
Age defaultValueAge;

//  A value to use if there is no existing value in the source object.
Annotation defaultValueAnnotation;

//  A value to use if there is no existing value in the source object.
Attachment defaultValueAttachment;

//  A value to use if there is no existing value in the source object.
CodeableConcept defaultValueCodeableConcept;

//  A value to use if there is no existing value in the source object.
Coding defaultValueCoding;

//  A value to use if there is no existing value in the source object.
ContactPoint defaultValueContactPoint;

//  A value to use if there is no existing value in the source object.
Count defaultValueCount;

//  A value to use if there is no existing value in the source object.
Distance defaultValueDistance;

//  A value to use if there is no existing value in the source object.
Duration defaultValueDuration;

//  A value to use if there is no existing value in the source object.
HumanName defaultValueHumanName;

//  A value to use if there is no existing value in the source object.
Identifier defaultValueIdentifier;

//  A value to use if there is no existing value in the source object.
Money defaultValueMoney;

//  A value to use if there is no existing value in the source object.
Period defaultValuePeriod;

//  A value to use if there is no existing value in the source object.
Quantity defaultValueQuantity;

//  A value to use if there is no existing value in the source object.
Range defaultValueRange;

//  A value to use if there is no existing value in the source object.
Ratio defaultValueRatio;

//  A value to use if there is no existing value in the source object.
Reference defaultValueReference;

//  A value to use if there is no existing value in the source object.
SampledData defaultValueSampledData;

//  A value to use if there is no existing value in the source object.
Signature defaultValueSignature;

//  A value to use if there is no existing value in the source object.
Timing defaultValueTiming;

//  A value to use if there is no existing value in the source object.
ContactDetail defaultValueContactDetail;

//  A value to use if there is no existing value in the source object.
Contributor defaultValueContributor;

//  A value to use if there is no existing value in the source object.
DataRequirement defaultValueDataRequirement;

//  A value to use if there is no existing value in the source object.
Expression defaultValueExpression;

//  A value to use if there is no existing value in the source object.
ParameterDefinition defaultValueParameterDefinition;

//  A value to use if there is no existing value in the source object.
RelatedArtifact defaultValueRelatedArtifact;

//  A value to use if there is no existing value in the source object.
TriggerDefinition defaultValueTriggerDefinition;

//  A value to use if there is no existing value in the source object.
UsageContext defaultValueUsageContext;

//  A value to use if there is no existing value in the source object.
Dosage defaultValueDosage;

//  A value to use if there is no existing value in the source object.
Meta defaultValueMeta;

//  Optional field for this source.
String element;

//  How to handle the list mode for this element.
String listMode; // <code> enum: first/not_first/last/not_last/only_one;

//  Named context for field, if a field is specified.
String variable;

//  FHIRPath expression  - must be true or the rule does not apply.
String condition;

//  FHIRPath expression  - must be true or the mapping engine throws an
// error instead of completing.
String check;

//  A FHIRPath expression which specifies a message to put in the
// transform log when content matching the source rule is found.
String logMessage;

StructureMap_Source(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.context,
    this.min,
    this.max,
    this.type,
    this.defaultValueBase64Binary,
    this.defaultValueBoolean,
    this.defaultValueCanonical,
    this.defaultValueCode,
    this.defaultValueDate,
    this.defaultValueDateTime,
    this.defaultValueDecimal,
    this.defaultValueId,
    this.defaultValueInstant,
    this.defaultValueInteger,
    this.defaultValueMarkdown,
    this.defaultValueOid,
    this.defaultValuePositiveInt,
    this.defaultValueString,
    this.defaultValueTime,
    this.defaultValueUnsignedInt,
    this.defaultValueUri,
    this.defaultValueUrl,
    this.defaultValueUuid,
    this.defaultValueAddress,
    this.defaultValueAge,
    this.defaultValueAnnotation,
    this.defaultValueAttachment,
    this.defaultValueCodeableConcept,
    this.defaultValueCoding,
    this.defaultValueContactPoint,
    this.defaultValueCount,
    this.defaultValueDistance,
    this.defaultValueDuration,
    this.defaultValueHumanName,
    this.defaultValueIdentifier,
    this.defaultValueMoney,
    this.defaultValuePeriod,
    this.defaultValueQuantity,
    this.defaultValueRange,
    this.defaultValueRatio,
    this.defaultValueReference,
    this.defaultValueSampledData,
    this.defaultValueSignature,
    this.defaultValueTiming,
    this.defaultValueContactDetail,
    this.defaultValueContributor,
    this.defaultValueDataRequirement,
    this.defaultValueExpression,
    this.defaultValueParameterDefinition,
    this.defaultValueRelatedArtifact,
    this.defaultValueTriggerDefinition,
    this.defaultValueUsageContext,
    this.defaultValueDosage,
    this.defaultValueMeta,
    this.element,
    this.listMode,
    this.variable,
    this.condition,
    this.check,
    this.logMessage,
    });

  factory StructureMap_Source.fromJson(Map<String, dynamic> json) => _$StructureMap_SourceFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_SourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Type or variable this rule applies to.
String context;

//  How to interpret the context.
String contextType; // <code> enum: type/variable;

//  Field to create in the context.
String element;

//  Named context for field, if desired, and a field is specified.
String variable;

//  If field is a list, how to manage the list.
List<String> listMode; // <code> enum: first/share/last/collate> listMode;

//  Internal rule reference for shared list items.
String listRuleId;

//  How the data is copied / created.
String transform; // <code> enum: create/copy/truncate/escape/cast/append/translate/reference/dateOp/uuid/pointer/evaluate/cc/c/qty/id/cp;

//  Parameters to the transform.
List<StructureMap_Parameter> parameter;

StructureMap_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.context,
    this.contextType,
    this.element,
    this.variable,
    this.listMode,
    this.listRuleId,
    this.transform,
    this.parameter,
    });

  factory StructureMap_Target.fromJson(Map<String, dynamic> json) => _$StructureMap_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_TargetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Parameter value - variable or literal.
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  Parameter value - variable or literal.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  Parameter value - variable or literal.
bool valueBoolean; //  pattern: ^true|false$

//  Parameter value - variable or literal.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  Parameter value - variable or literal.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

StructureMap_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.valueId,
    this.valueString,
    this.valueBoolean,
    this.valueInteger,
    this.valueDecimal,
    });

  factory StructureMap_Parameter.fromJson(Map<String, dynamic> json) => _$StructureMap_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_ParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class StructureMap_Dependent {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name of a rule or group to apply.
String name;

//  Variable to pass to the rule or group.
List<String> variable;

StructureMap_Dependent(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.variable,
    });

  factory StructureMap_Dependent.fromJson(Map<String, dynamic> json) => _$StructureMap_DependentFromJson(json);
  Map<String, dynamic> toJson() => _$StructureMap_DependentToJson(this);
}

part 'subscription.g.dart';

@JsonSerializable(explicitToJson: true)
class Subscription {

//  This is a Subscription resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The status of the subscription, which marks the server state for
// managing the subscription.
String status; // <code> enum: requested/active/error/off;

//  Contact details for a human to contact about the subscription. The
// primary use of this for system administrator troubleshooting.
List<ContactPoint> contact;

//  The time for the server to turn the subscription off.
DateTime end;

//  A description of why this subscription is defined.
String reason;

//  The rules that the server should use to determine when to generate
// notifications for this subscription.
String criteria;

//  A record of the last error that occurred when the server processed a
// notification.
String error;

//  Details where to send notifications when resources are received that
// meet the criteria.
Subscription_Channel channel;

Subscription(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.status,
    this.contact,
    this.end,
    this.reason,
    this.criteria,
    this.error,
    this.channel,
    });

  factory Subscription.fromJson(Map<String, dynamic> json) => _$SubscriptionFromJson(json);
  Map<String, dynamic> toJson() => _$SubscriptionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Subscription_Channel {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of channel to send notifications on.
String type; // <code> enum: rest-hook/websocket/email/sms/message;

//  The url that describes the actual end-point to send messages to.
String endpoint;

//  The mime type to send the payload in - either application/fhir+xml, or
// application/fhir+json. If the payload is not present, then there is no
// payload in the notification, just a notification. The mime type
// "text/plain" may also be used for Email and SMS subscriptions.
String payload;

//  Additional headers / information to send as part of the notification.
List<String> header;

Subscription_Channel(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.endpoint,
    this.payload,
    this.header,
    });

  factory Subscription_Channel.fromJson(Map<String, dynamic> json) => _$Subscription_ChannelFromJson(json);
  Map<String, dynamic> toJson() => _$Subscription_ChannelToJson(this);
}

part 'substance.g.dart';

@JsonSerializable(explicitToJson: true)
class Substance {

//  This is a Substance resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Unique identifier for the substance.
List<Identifier> identifier;

//  A code to indicate if the substance is actively used.
String status; // <code> enum: active/inactive/entered-in-error;

//  A code that classifies the general type of substance.  This is used 
// for searching, sorting and display purposes.
List<CodeableConcept> category;

//  A code (or set of codes) that identify this substance.
CodeableConcept code;

//  A description of the substance - its appearance, handling
// requirements, and other usage notes.
String description;

//  Substance may be used to describe a kind of substance, or a specific
// package/container of the substance: an instance.
List<Substance_Instance> instance;

//  A substance can be composed of other substances.
List<Substance_Ingredient> ingredient;

Substance(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.category,
    this.code,
    this.description,
    this.instance,
    this.ingredient,
    });

  factory Substance.fromJson(Map<String, dynamic> json) => _$SubstanceFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Substance_Instance {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier associated with the package/container (usually a label
// affixed directly).
Identifier identifier;

//  When the substance is no longer valid to use. For some substances, a
// single arbitrary date is used for expiry.
DateTime expiry;

//  The amount of the substance.
Quantity quantity;

Substance_Instance(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.expiry,
    this.quantity,
    });

  factory Substance_Instance.fromJson(Map<String, dynamic> json) => _$Substance_InstanceFromJson(json);
  Map<String, dynamic> toJson() => _$Substance_InstanceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Substance_Ingredient {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The amount of the ingredient in the substance - a concentration ratio.
Ratio quantity;

//  Another substance that is a component of this substance.
CodeableConcept substanceCodeableConcept;

//  Another substance that is a component of this substance.
Reference substanceReference;

Substance_Ingredient(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.quantity,
    this.substanceCodeableConcept,
    this.substanceReference,
    });

  factory Substance_Ingredient.fromJson(Map<String, dynamic> json) => _$Substance_IngredientFromJson(json);
  Map<String, dynamic> toJson() => _$Substance_IngredientToJson(this);
}

part 'substanceNucleicAcid.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceNucleicAcid {

//  This is a SubstanceNucleicAcid resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The type of the sequence shall be specified based on a controlled
// vocabulary.
CodeableConcept sequenceType;

//  The number of linear sequences of nucleotides linked through
// phosphodiester bonds shall be described. Subunits would be strands of
// nucleic acids that are tightly associated typically through
// Watson-Crick base pairing. NOTE: If not specified in the reference
// source, the assumption is that there is 1 subunit.
int numberOfSubunits;

//  The area of hybridisation shall be described if applicable for double
// stranded RNA or DNA. The number associated with the subunit followed by
// the number associated to the residue shall be specified in increasing
// order. The underscore  shall be used as separator as follows:
// Subunitnumber Residue.
String areaOfHybridisation;

//  (TBC).
CodeableConcept oligoNucleotideType;

//  Subunits are listed in order of decreasing length; sequences of the
// same length will be ordered by molecular weight; subunits that have
// identical sequences will be repeated multiple times.
List<SubstanceNucleicAcid_Subunit> subunit;

SubstanceNucleicAcid(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.sequenceType,
    this.numberOfSubunits,
    this.areaOfHybridisation,
    this.oligoNucleotideType,
    this.subunit,
    });

  factory SubstanceNucleicAcid.fromJson(Map<String, dynamic> json) => _$SubstanceNucleicAcidFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceNucleicAcidToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceNucleicAcid_Subunit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Index of linear sequences of nucleic acids in order of decreasing
// length. Sequences of the same length will be ordered by molecular
// weight. Subunits that have identical sequences will be repeated and
// have sequential subscripts.
int subunit;

//  Actual nucleotide sequence notation from 5' to 3' end using standard
// single letter codes. In addition to the base sequence, sugar and type
// of phosphate or non-phosphate linkage should also be captured.
String sequence;

//  The length of the sequence shall be captured.
int length;

//  (TBC).
Attachment sequenceAttachment;

//  The nucleotide present at the 5 terminal shall be specified based on
// a controlled vocabulary. Since the sequence is represented from the 5'
// to the 3' end, the 5 prime nucleotide is the letter at the first
// position in the sequence. A separate representation would be redundant.
CodeableConcept fivePrime;

//  The nucleotide present at the 3 terminal shall be specified based on
// a controlled vocabulary. Since the sequence is represented from the 5'
// to the 3' end, the 5 prime nucleotide is the letter at the last
// position in the sequence. A separate representation would be redundant.
CodeableConcept threePrime;

//  The linkages between sugar residues will also be captured.
List<SubstanceNucleicAcid_Linkage> linkage;

//  5.3.6.8.1 Sugar ID (Mandatory).
List<SubstanceNucleicAcid_Sugar> sugar;

SubstanceNucleicAcid_Subunit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.subunit,
    this.sequence,
    this.length,
    this.sequenceAttachment,
    this.fivePrime,
    this.threePrime,
    this.linkage,
    this.sugar,
    });

  factory SubstanceNucleicAcid_Subunit.fromJson(Map<String, dynamic> json) => _$SubstanceNucleicAcid_SubunitFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceNucleicAcid_SubunitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceNucleicAcid_Linkage {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The entity that links the sugar residues together should also be
// captured for nearly all naturally occurring nucleic acid the linkage is
// a phosphate group. For many synthetic oligonucleotides phosphorothioate
// linkages are often seen. Linkage connectivity is assumed to be 3-5.
// If the linkage is either 3-3 or 5-5 this should be specified.
String connectivity;

//  Each linkage will be registered as a fragment and have an ID.
Identifier identifier;

//  Each linkage will be registered as a fragment and have at least one
// name. A single name shall be assigned to each linkage.
String name;

//  Residues shall be captured as described in 5.3.6.8.3.
String residueSite;

SubstanceNucleicAcid_Linkage(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.connectivity,
    this.identifier,
    this.name,
    this.residueSite,
    });

  factory SubstanceNucleicAcid_Linkage.fromJson(Map<String, dynamic> json) => _$SubstanceNucleicAcid_LinkageFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceNucleicAcid_LinkageToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceNucleicAcid_Sugar {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The Substance ID of the sugar or sugar-like component that make up the
// nucleotide.
Identifier identifier;

//  The name of the sugar or sugar-like component that make up the
// nucleotide.
String name;

//  The residues that contain a given sugar will be captured. The order of
// given residues will be captured in the 5-3direction consistent with
// the base sequences listed above.
String residueSite;

SubstanceNucleicAcid_Sugar(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.name,
    this.residueSite,
    });

  factory SubstanceNucleicAcid_Sugar.fromJson(Map<String, dynamic> json) => _$SubstanceNucleicAcid_SugarFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceNucleicAcid_SugarToJson(this);
}

part 'substancePolymer.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstancePolymer {

//  This is a SubstancePolymer resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept class;

//  Todo.
CodeableConcept geometry;

//  Todo.
List<CodeableConcept> copolymerConnectivity;

//  Todo.
List<String> modification;

//  Todo.
List<SubstancePolymer_MonomerSet> monomerSet;

//  Todo.
List<SubstancePolymer_Repeat> repeat;

SubstancePolymer(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.class,
    this.geometry,
    this.copolymerConnectivity,
    this.modification,
    this.monomerSet,
    this.repeat,
    });

  factory SubstancePolymer.fromJson(Map<String, dynamic> json) => _$SubstancePolymerFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymerToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_MonomerSet {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept ratioType;

//  Todo.
List<SubstancePolymer_StartingMaterial> startingMaterial;

SubstancePolymer_MonomerSet(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.ratioType,
    this.startingMaterial,
    });

  factory SubstancePolymer_MonomerSet.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_MonomerSetFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_MonomerSetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_StartingMaterial {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept material;

//  Todo.
CodeableConcept type;

//  Todo.
bool isDefining;

//  Todo.
SubstanceAmount amount;

SubstancePolymer_StartingMaterial(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.material,
    this.type,
    this.isDefining,
    this.amount,
    });

  factory SubstancePolymer_StartingMaterial.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_StartingMaterialFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_StartingMaterialToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_Repeat {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
int numberOfUnits;

//  Todo.
String averageMolecularFormula;

//  Todo.
CodeableConcept repeatUnitAmountType;

//  Todo.
List<SubstancePolymer_RepeatUnit> repeatUnit;

SubstancePolymer_Repeat(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.numberOfUnits,
    this.averageMolecularFormula,
    this.repeatUnitAmountType,
    this.repeatUnit,
    });

  factory SubstancePolymer_Repeat.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_RepeatFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_RepeatToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_RepeatUnit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept orientationOfPolymerisation;

//  Todo.
String repeatUnit;

//  Todo.
SubstanceAmount amount;

//  Todo.
List<SubstancePolymer_DegreeOfPolymerisation> degreeOfPolymerisation;

//  Todo.
List<SubstancePolymer_StructuralRepresentation> structuralRepresentation;

SubstancePolymer_RepeatUnit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.orientationOfPolymerisation,
    this.repeatUnit,
    this.amount,
    this.degreeOfPolymerisation,
    this.structuralRepresentation,
    });

  factory SubstancePolymer_RepeatUnit.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_RepeatUnitFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_RepeatUnitToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_DegreeOfPolymerisation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept degree;

//  Todo.
SubstanceAmount amount;

SubstancePolymer_DegreeOfPolymerisation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.degree,
    this.amount,
    });

  factory SubstancePolymer_DegreeOfPolymerisation.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_DegreeOfPolymerisationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_DegreeOfPolymerisationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstancePolymer_StructuralRepresentation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept type;

//  Todo.
String representation;

//  Todo.
Attachment attachment;

SubstancePolymer_StructuralRepresentation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.representation,
    this.attachment,
    });

  factory SubstancePolymer_StructuralRepresentation.fromJson(Map<String, dynamic> json) => _$SubstancePolymer_StructuralRepresentationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstancePolymer_StructuralRepresentationToJson(this);
}

part 'substanceProtein.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceProtein {

//  This is a SubstanceProtein resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The SubstanceProtein descriptive elements will only be used when a
// complete or partial amino acid sequence is available or derivable from
// a nucleic acid sequence.
CodeableConcept sequenceType;

//  Number of linear sequences of amino acids linked through peptide
// bonds. The number of subunits constituting the SubstanceProtein shall
// be described. It is possible that the number of subunits can be
// variable.
int numberOfSubunits;

//  The disulphide bond between two cysteine residues either on the same
// subunit or on two different subunits shall be described. The position
// of the disulfide bonds in the SubstanceProtein shall be listed in
// increasing order of subunit number and position within subunit followed
// by the abbreviation of the amino acids involved. The disulfide linkage
// positions shall actually contain the amino acid Cysteine at the
// respective positions.
List<String> disulfideLinkage;

//  This subclause refers to the description of each subunit constituting
// the SubstanceProtein. A subunit is a linear sequence of amino acids
// linked through peptide bonds. The Subunit information shall be provided
// when the finished SubstanceProtein is a complex of multiple sequences;
// subunits are not used to delineate domains within a single sequence.
// Subunits are listed in order of decreasing length; sequences of the
// same length will be ordered by decreasing molecular weight; subunits
// that have identical sequences will be repeated multiple times.
List<SubstanceProtein_Subunit> subunit;

SubstanceProtein(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.sequenceType,
    this.numberOfSubunits,
    this.disulfideLinkage,
    this.subunit,
    });

  factory SubstanceProtein.fromJson(Map<String, dynamic> json) => _$SubstanceProteinFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceProteinToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceProtein_Subunit {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Index of primary sequences of amino acids linked through peptide bonds
// in order of decreasing length. Sequences of the same length will be
// ordered by molecular weight. Subunits that have identical sequences
// will be repeated and have sequential subscripts.
int subunit;

//  The sequence information shall be provided enumerating the amino acids
// from N- to C-terminal end using standard single-letter amino acid
// codes. Uppercase shall be used for L-amino acids and lowercase for
// D-amino acids. Transcribed SubstanceProteins will always be described
// using the translated sequence; for synthetic peptide containing amino
// acids that are not represented with a single letter code an X should be
// used within the sequence. The modified amino acids will be
// distinguished by their position in the sequence.
String sequence;

//  Length of linear sequences of amino acids contained in the subunit.
int length;

//  The sequence information shall be provided enumerating the amino acids
// from N- to C-terminal end using standard single-letter amino acid
// codes. Uppercase shall be used for L-amino acids and lowercase for
// D-amino acids. Transcribed SubstanceProteins will always be described
// using the translated sequence; for synthetic peptide containing amino
// acids that are not represented with a single letter code an X should be
// used within the sequence. The modified amino acids will be
// distinguished by their position in the sequence.
Attachment sequenceAttachment;

//  Unique identifier for molecular fragment modification based on the ISO
// 11238 Substance ID.
Identifier nTerminalModificationId;

//  The name of the fragment modified at the N-terminal of the
// SubstanceProtein shall be specified.
String nTerminalModification;

//  Unique identifier for molecular fragment modification based on the ISO
// 11238 Substance ID.
Identifier cTerminalModificationId;

//  The modification at the C-terminal shall be specified.
String cTerminalModification;

SubstanceProtein_Subunit(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.subunit,
    this.sequence,
    this.length,
    this.sequenceAttachment,
    this.nTerminalModificationId,
    this.nTerminalModification,
    this.cTerminalModificationId,
    this.cTerminalModification,
    });

  factory SubstanceProtein_Subunit.fromJson(Map<String, dynamic> json) => _$SubstanceProtein_SubunitFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceProtein_SubunitToJson(this);
}

part 'substanceReferenceInformation.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceReferenceInformation {

//  This is a SubstanceReferenceInformation resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
String comment;

//  Todo.
List<SubstanceReferenceInformation_Gene> gene;

//  Todo.
List<SubstanceReferenceInformation_GeneElement> geneElement;

//  Todo.
List<SubstanceReferenceInformation_Classification> classification;

//  Todo.
List<SubstanceReferenceInformation_Target> target;

SubstanceReferenceInformation(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.comment,
    this.gene,
    this.geneElement,
    this.classification,
    this.target,
    });

  factory SubstanceReferenceInformation.fromJson(Map<String, dynamic> json) => _$SubstanceReferenceInformationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceReferenceInformationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceReferenceInformation_Gene {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept geneSequenceOrigin;

//  Todo.
CodeableConcept gene;

//  Todo.
List<Reference> source;

SubstanceReferenceInformation_Gene(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.geneSequenceOrigin,
    this.gene,
    this.source,
    });

  factory SubstanceReferenceInformation_Gene.fromJson(Map<String, dynamic> json) => _$SubstanceReferenceInformation_GeneFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceReferenceInformation_GeneToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceReferenceInformation_GeneElement {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept type;

//  Todo.
Identifier element;

//  Todo.
List<Reference> source;

SubstanceReferenceInformation_GeneElement(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.element,
    this.source,
    });

  factory SubstanceReferenceInformation_GeneElement.fromJson(Map<String, dynamic> json) => _$SubstanceReferenceInformation_GeneElementFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceReferenceInformation_GeneElementToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceReferenceInformation_Classification {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
CodeableConcept domain;

//  Todo.
CodeableConcept classification;

//  Todo.
List<CodeableConcept> subtype;

//  Todo.
List<Reference> source;

SubstanceReferenceInformation_Classification(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.domain,
    this.classification,
    this.subtype,
    this.source,
    });

  factory SubstanceReferenceInformation_Classification.fromJson(Map<String, dynamic> json) => _$SubstanceReferenceInformation_ClassificationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceReferenceInformation_ClassificationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceReferenceInformation_Target {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Todo.
Identifier target;

//  Todo.
CodeableConcept type;

//  Todo.
CodeableConcept interaction;

//  Todo.
CodeableConcept organism;

//  Todo.
CodeableConcept organismType;

//  Todo.
Quantity amountQuantity;

//  Todo.
Range amountRange;

//  Todo.
String amountString; //  pattern: ^[ \r\n\t\S]+$

//  Todo.
CodeableConcept amountType;

//  Todo.
List<Reference> source;

SubstanceReferenceInformation_Target(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.target,
    this.type,
    this.interaction,
    this.organism,
    this.organismType,
    this.amountQuantity,
    this.amountRange,
    this.amountString,
    this.amountType,
    this.source,
    });

  factory SubstanceReferenceInformation_Target.fromJson(Map<String, dynamic> json) => _$SubstanceReferenceInformation_TargetFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceReferenceInformation_TargetToJson(this);
}

part 'substanceSourceMaterial.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial {

//  This is a SubstanceSourceMaterial resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  General high level classification of the source material specific to
// the origin of the material.
CodeableConcept sourceMaterialClass;

//  The type of the source material shall be specified based on a
// controlled vocabulary. For vaccines, this subclause refers to the class
// of infectious agent.
CodeableConcept sourceMaterialType;

//  The state of the source material when extracted.
CodeableConcept sourceMaterialState;

//  The unique identifier associated with the source material parent
// organism shall be specified.
Identifier organismId;

//  The organism accepted Scientific name shall be provided based on the
// organism taxonomy.
String organismName;

//  The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID
// of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole
// plant).
List<Identifier> parentSubstanceId;

//  The parent substance of the Herbal Drug, or Herbal preparation.
List<String> parentSubstanceName;

//  The country where the plant material is harvested or the countries
// where the plasma is sourced from as laid down in accordance with the
// Plasma Master File. For Plasma-derived substances the attribute
// country of origin provides information about the countries used for the
// manufacturing of the Cryopoor plama or Crioprecipitate.
List<CodeableConcept> countryOfOrigin;

//  The place/region where the plant is harvested or the places/regions
// where the animal source material has its habitat.
List<String> geographicalLocation;

//  Stage of life for animals, plants, insects and microorganisms. This
// information shall be provided only when the substance is significantly
// different in these stages (e.g. foetal bovine serum).
CodeableConcept developmentStage;

//  Many complex materials are fractions of parts of plants, animals, or
// minerals. Fraction elements are often necessary to define both
// Substances and Specified Group 1 Substances. For substances derived
// from Plants, fraction information will be captured at the Substance
// information level ( . Oils, Juices and Exudates). Additional
// information for Extracts, such as extraction solvent composition, will
// be captured at the Specified Substance Group 1 information level. For
// plasma-derived products fraction information will be captured at the
// Substance and the Specified Substance Group 1 levels.
List<SubstanceSourceMaterial_FractionDescription> fractionDescription;

//  This subclause describes the organism which the substance is derived
// from. For vaccines, the parent organism shall be specified based on
// these subclause elements. As an example, full taxonomy will be
// described for the Substance Name: ., Leaf.
SubstanceSourceMaterial_Organism organism;

//  To do.
List<SubstanceSourceMaterial_PartDescription> partDescription;

SubstanceSourceMaterial(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.sourceMaterialClass,
    this.sourceMaterialType,
    this.sourceMaterialState,
    this.organismId,
    this.organismName,
    this.parentSubstanceId,
    this.parentSubstanceName,
    this.countryOfOrigin,
    this.geographicalLocation,
    this.developmentStage,
    this.fractionDescription,
    this.organism,
    this.partDescription,
    });

  factory SubstanceSourceMaterial.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterialFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterialToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_FractionDescription {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  This element is capturing information about the fraction of a plant
// part, or human plasma for fractionation.
String fraction;

//  The specific type of the material constituting the component. For
// Herbal preparations the particulars of the extracts (liquid/dry) is
// described in Specified Substance Group 1.
CodeableConcept materialType;

SubstanceSourceMaterial_FractionDescription(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.fraction,
    this.materialType,
    });

  factory SubstanceSourceMaterial_FractionDescription.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_FractionDescriptionFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_FractionDescriptionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_Organism {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The family of an organism shall be specified.
CodeableConcept family;

//  The genus of an organism shall be specified; refers to the Latin
// epithet of the genus element of the plant/animal scientific name; it is
// present in names for genera, species and infraspecies.
CodeableConcept genus;

//  The species of an organism shall be specified; refers to the Latin
// epithet of the species of the plant/animal; it is present in names for
// species and infraspecies.
CodeableConcept species;

//  The Intraspecific type of an organism shall be specified.
CodeableConcept intraspecificType;

//  The intraspecific description of an organism shall be specified based
// on a controlled vocabulary. For Influenza Vaccine, the intraspecific
// description shall contain the syntax of the antigen in line with the
// WHO convention.
String intraspecificDescription;

//  4.9.13.6.1 Author type (Conditional).
List<SubstanceSourceMaterial_Author> author;

//  4.9.13.8.1 Hybrid species maternal organism ID (Optional).
SubstanceSourceMaterial_Hybrid hybrid;

//  4.9.13.7.1 Kingdom (Conditional).
SubstanceSourceMaterial_OrganismGeneral organismGeneral;

SubstanceSourceMaterial_Organism(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.family,
    this.genus,
    this.species,
    this.intraspecificType,
    this.intraspecificDescription,
    this.author,
    this.hybrid,
    this.organismGeneral,
    });

  factory SubstanceSourceMaterial_Organism.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_OrganismFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_OrganismToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_Author {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of author of an organism species shall be specified. The
// parenthetical author of an organism species refers to the first author
// who published the plant/animal name (of any rank). The primary author
// of an organism species refers to the first author(s), who validly
// published the plant/animal name.
CodeableConcept authorType;

//  The author of an organism species shall be specified. The author year
// of an organism shall also be specified when applicable; refers to the
// year in which the first author(s) published the infraspecific
// plant/animal name (of any rank).
String authorDescription;

SubstanceSourceMaterial_Author(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.authorType,
    this.authorDescription,
    });

  factory SubstanceSourceMaterial_Author.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_AuthorFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_AuthorToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_Hybrid {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The identifier of the maternal species constituting the hybrid
// organism shall be specified based on a controlled vocabulary. For
// plants, the parents arent always known, and it is unlikely that it
// will be known which is maternal and which is paternal.
String maternalOrganismId;

//  The name of the maternal species constituting the hybrid organism
// shall be specified. For plants, the parents arent always known, and it
// is unlikely that it will be known which is maternal and which is
// paternal.
String maternalOrganismName;

//  The identifier of the paternal species constituting the hybrid
// organism shall be specified based on a controlled vocabulary.
String paternalOrganismId;

//  The name of the paternal species constituting the hybrid organism
// shall be specified.
String paternalOrganismName;

//  The hybrid type of an organism shall be specified.
CodeableConcept hybridType;

SubstanceSourceMaterial_Hybrid(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.maternalOrganismId,
    this.maternalOrganismName,
    this.paternalOrganismId,
    this.paternalOrganismName,
    this.hybridType,
    });

  factory SubstanceSourceMaterial_Hybrid.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_HybridFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_HybridToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_OrganismGeneral {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The kingdom of an organism shall be specified.
CodeableConcept kingdom;

//  The phylum of an organism shall be specified.
CodeableConcept phylum;

//  The class of an organism shall be specified.
CodeableConcept class;

//  The order of an organism shall be specified,.
CodeableConcept order;

SubstanceSourceMaterial_OrganismGeneral(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.kingdom,
    this.phylum,
    this.class,
    this.order,
    });

  factory SubstanceSourceMaterial_OrganismGeneral.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_OrganismGeneralFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_OrganismGeneralToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSourceMaterial_PartDescription {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Entity of anatomical origin of source material within an organism.
CodeableConcept part;

//  The detailed anatomic location when the part can be extracted from
// different anatomical locations of the organism. Multiple alternative
// locations may apply.
CodeableConcept partLocation;

SubstanceSourceMaterial_PartDescription(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.part,
    this.partLocation,
    });

  factory SubstanceSourceMaterial_PartDescription.fromJson(Map<String, dynamic> json) => _$SubstanceSourceMaterial_PartDescriptionFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSourceMaterial_PartDescriptionToJson(this);
}

part 'substanceSpecification.g.dart';

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification {

//  This is a SubstanceSpecification resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier by which this substance is known.
Identifier identifier;

//  High level categorization, e.g. polymer or nucleic acid.
CodeableConcept type;

//  Status of substance within the catalogue e.g. approved.
CodeableConcept status;

//  If the substance applies to only human or veterinary use.
CodeableConcept domain;

//  Textual description of the substance.
String description;

//  Supporting literature.
List<Reference> source;

//  Textual comment about this record of a substance.
String comment;

//  Moiety, for structural modifications.
List<SubstanceSpecification_Moiety> moiety;

//  General specifications for this substance, including how it is related
// to other substances.
List<SubstanceSpecification_Property> property;

//  General information detailing this substance.
Reference referenceInformation;

//  Structural information.
SubstanceSpecification_Structure structure;

//  Codes associated with the substance.
List<SubstanceSpecification_Code> code;

//  Names applicable to this substance.
List<SubstanceSpecification_Name> name;

//  The molecular weight or weight range (for proteins, polymers or
// nucleic acids).
List<SubstanceSpecification_MolecularWeight> molecularWeight;

//  A link between this substance and another, with details of the
// relationship.
List<SubstanceSpecification_Relationship> relationship;

//  Data items specific to nucleic acids.
Reference nucleicAcid;

//  Data items specific to polymers.
Reference polymer;

//  Data items specific to proteins.
Reference protein;

//  Material or taxonomic/anatomical source for the substance.
Reference sourceMaterial;

SubstanceSpecification(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.type,
    this.status,
    this.domain,
    this.description,
    this.source,
    this.comment,
    this.moiety,
    this.property,
    this.referenceInformation,
    this.structure,
    this.code,
    this.name,
    this.molecularWeight,
    this.relationship,
    this.nucleicAcid,
    this.polymer,
    this.protein,
    this.sourceMaterial,
    });

  factory SubstanceSpecification.fromJson(Map<String, dynamic> json) => _$SubstanceSpecificationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecificationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Moiety {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Role that the moiety is playing.
CodeableConcept role;

//  Identifier by which this moiety substance is known.
Identifier identifier;

//  Textual name for this moiety substance.
String name;

//  Stereochemistry type.
CodeableConcept stereochemistry;

//  Optical activity type.
CodeableConcept opticalActivity;

//  Molecular formula.
String molecularFormula;

//  Quantitative value for this moiety.
Quantity amountQuantity;

//  Quantitative value for this moiety.
String amountString; //  pattern: ^[ \r\n\t\S]+$

SubstanceSpecification_Moiety(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.role,
    this.identifier,
    this.name,
    this.stereochemistry,
    this.opticalActivity,
    this.molecularFormula,
    this.amountQuantity,
    this.amountString,
    });

  factory SubstanceSpecification_Moiety.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_MoietyFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_MoietyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Property {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A category for this property, e.g. Physical, Chemical, Enzymatic.
CodeableConcept category;

//  Property type e.g. viscosity, pH, isoelectric point.
CodeableConcept code;

//  Parameters that were used in the measurement of a property (e.g. for
// viscosity: measured at 20C with a pH of 7.1).
String parameters;

//  A substance upon which a defining property depends (e.g. for
// solubility: in water, in alcohol).
Reference definingSubstanceReference;

//  A substance upon which a defining property depends (e.g. for
// solubility: in water, in alcohol).
CodeableConcept definingSubstanceCodeableConcept;

//  Quantitative value for this property.
Quantity amountQuantity;

//  Quantitative value for this property.
String amountString; //  pattern: ^[ \r\n\t\S]+$

SubstanceSpecification_Property(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.category,
    this.code,
    this.parameters,
    this.definingSubstanceReference,
    this.definingSubstanceCodeableConcept,
    this.amountQuantity,
    this.amountString,
    });

  factory SubstanceSpecification_Property.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_PropertyFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_PropertyToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Structure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Stereochemistry type.
CodeableConcept stereochemistry;

//  Optical activity type.
CodeableConcept opticalActivity;

//  Molecular formula.
String molecularFormula;

//  Specified per moiety according to the Hill system, i.e. first C, then
// H, then alphabetical, each moiety separated by a dot.
String molecularFormulaByMoiety;

//  Applicable for single substances that contain a radionuclide or a
// non-natural isotopic ratio.
List<SubstanceSpecification_Isotope> isotope;

//  The molecular weight or weight range (for proteins, polymers or
// nucleic acids).
SubstanceSpecification_MolecularWeight molecularWeight;

//  Supporting literature.
List<Reference> source;

//  Molecular structural representation.
List<SubstanceSpecification_Representation> representation;

SubstanceSpecification_Structure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.stereochemistry,
    this.opticalActivity,
    this.molecularFormula,
    this.molecularFormulaByMoiety,
    this.isotope,
    this.molecularWeight,
    this.source,
    this.representation,
    });

  factory SubstanceSpecification_Structure.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_StructureFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_StructureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Isotope {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Substance identifier for each non-natural or radioisotope.
Identifier identifier;

//  Substance name for each non-natural or radioisotope.
CodeableConcept name;

//  The type of isotopic substitution present in a single substance.
CodeableConcept substitution;

//  Half life - for a non-natural nuclide.
Quantity halfLife;

//  The molecular weight or weight range (for proteins, polymers or
// nucleic acids).
SubstanceSpecification_MolecularWeight molecularWeight;

SubstanceSpecification_Isotope(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.name,
    this.substitution,
    this.halfLife,
    this.molecularWeight,
    });

  factory SubstanceSpecification_Isotope.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_IsotopeFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_IsotopeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_MolecularWeight {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The method by which the molecular weight was determined.
CodeableConcept method;

//  Type of molecular weight such as exact, average (also known as. number
// average), weight average.
CodeableConcept type;

//  Used to capture quantitative values for a variety of elements. If only
// limits are given, the arithmetic mean would be the average. If only a
// single definite value for a given element is given, it would be
// captured in this field.
Quantity amount;

SubstanceSpecification_MolecularWeight(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.method,
    this.type,
    this.amount,
    });

  factory SubstanceSpecification_MolecularWeight.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_MolecularWeightFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_MolecularWeightToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Representation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of structure (e.g. Full, Partial, Representative).
CodeableConcept type;

//  The structural representation as text string in a format e.g. InChI,
// SMILES, MOLFILE, CDX.
String representation;

//  An attached file with the structural representation.
Attachment attachment;

SubstanceSpecification_Representation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.representation,
    this.attachment,
    });

  factory SubstanceSpecification_Representation.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_RepresentationFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_RepresentationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Code {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The specific code.
CodeableConcept code;

//  Status of the code assignment.
CodeableConcept status;

//  The date at which the code status is changed as part of the
// terminology maintenance.
DateTime statusDate;

//  Any comment can be provided in this field, if necessary.
String comment;

//  Supporting literature.
List<Reference> source;

SubstanceSpecification_Code(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.status,
    this.statusDate,
    this.comment,
    this.source,
    });

  factory SubstanceSpecification_Code.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_CodeFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_CodeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Name {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The actual name.
String name;

//  Name type.
CodeableConcept type;

//  The status of the name.
CodeableConcept status;

//  If this is the preferred name for this substance.
bool preferred;

//  Language of the name.
List<CodeableConcept> language;

//  The use context of this name for example if there is a different name
// a drug active ingredient as opposed to a food colour additive.
List<CodeableConcept> domain;

//  The jurisdiction where this name applies.
List<CodeableConcept> jurisdiction;

//  A synonym of this name.
List<SubstanceSpecification_Name> synonym;

//  A translation for this name.
List<SubstanceSpecification_Name> translation;

//  Details of the official nature of this name.
List<SubstanceSpecification_Official> official;

//  Supporting literature.
List<Reference> source;

SubstanceSpecification_Name(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.type,
    this.status,
    this.preferred,
    this.language,
    this.domain,
    this.jurisdiction,
    this.synonym,
    this.translation,
    this.official,
    this.source,
    });

  factory SubstanceSpecification_Name.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_NameFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_NameToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Official {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Which authority uses this official name.
CodeableConcept authority;

//  The status of the official name.
CodeableConcept status;

//  Date of official name change.
DateTime date;

SubstanceSpecification_Official(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.authority,
    this.status,
    this.date,
    });

  factory SubstanceSpecification_Official.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_OfficialFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_OfficialToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SubstanceSpecification_Relationship {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A pointer to another substance, as a resource or just a
// representational code.
Reference substanceReference;

//  A pointer to another substance, as a resource or just a
// representational code.
CodeableConcept substanceCodeableConcept;

//  For example "salt to parent", "active moiety", "starting material".
CodeableConcept relationship;

//  For example where an enzyme strongly bonds with a particular
// substance, this is a defining relationship for that enzyme, out of
// several possible substance relationships.
bool isDefining;

//  A numeric factor for the relationship, for instance to express that
// the salt of a substance has some percentage of the active substance in
// relation to some other.
Quantity amountQuantity;

//  A numeric factor for the relationship, for instance to express that
// the salt of a substance has some percentage of the active substance in
// relation to some other.
Range amountRange;

//  A numeric factor for the relationship, for instance to express that
// the salt of a substance has some percentage of the active substance in
// relation to some other.
Ratio amountRatio;

//  A numeric factor for the relationship, for instance to express that
// the salt of a substance has some percentage of the active substance in
// relation to some other.
String amountString; //  pattern: ^[ \r\n\t\S]+$

//  For use when the numeric.
Ratio amountRatioLowLimit;

//  An operator for the amount, for example "average", "approximately",
// "less than".
CodeableConcept amountType;

//  Supporting literature.
List<Reference> source;

SubstanceSpecification_Relationship(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.substanceReference,
    this.substanceCodeableConcept,
    this.relationship,
    this.isDefining,
    this.amountQuantity,
    this.amountRange,
    this.amountRatio,
    this.amountString,
    this.amountRatioLowLimit,
    this.amountType,
    this.source,
    });

  factory SubstanceSpecification_Relationship.fromJson(Map<String, dynamic> json) => _$SubstanceSpecification_RelationshipFromJson(json);
  Map<String, dynamic> toJson() => _$SubstanceSpecification_RelationshipToJson(this);
}

part 'supplyDelivery.g.dart';

@JsonSerializable(explicitToJson: true)
class SupplyDelivery {

//  This is a SupplyDelivery resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the supply delivery event that is used to identify it
// across multiple disparate systems.
List<Identifier> identifier;

//  A plan, proposal or order that is fulfilled in whole or in part by
// this event.
List<Reference> basedOn;

//  A larger event of which this particular event is a component or step.
List<Reference> partOf;

//  A code specifying the state of the dispense event.
String status; // <code> enum: in-progress/completed/abandoned/entered-in-error;

//  A link to a resource representing the person whom the delivered item
// is for.
Reference patient;

//  Indicates the type of dispensing event that is performed. Examples
// include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill,
// Samples, etc.
CodeableConcept type;

//  The item that is being delivered or has been supplied.
SupplyDelivery_SuppliedItem suppliedItem;

//  The date or time(s) the activity occurred.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The date or time(s) the activity occurred.
Period occurrencePeriod;

//  The date or time(s) the activity occurred.
Timing occurrenceTiming;

//  The individual responsible for dispensing the medication, supplier or
// device.
Reference supplier;

//  Identification of the facility/location where the Supply was shipped
// to, as part of the dispense event.
Reference destination;

//  Identifies the person who picked up the Supply.
List<Reference> receiver;

SupplyDelivery(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.basedOn,
    this.partOf,
    this.status,
    this.patient,
    this.type,
    this.suppliedItem,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.supplier,
    this.destination,
    this.receiver,
    });

  factory SupplyDelivery.fromJson(Map<String, dynamic> json) => _$SupplyDeliveryFromJson(json);
  Map<String, dynamic> toJson() => _$SupplyDeliveryToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SupplyDelivery_SuppliedItem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The amount of supply that has been dispensed. Includes unit of
// measure.
Quantity quantity;

//  Identifies the medication, substance or device being dispensed. This
// is either a link to a resource representing the details of the item or
// a code that identifies the item from a known list.
CodeableConcept itemCodeableConcept;

//  Identifies the medication, substance or device being dispensed. This
// is either a link to a resource representing the details of the item or
// a code that identifies the item from a known list.
Reference itemReference;

SupplyDelivery_SuppliedItem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.quantity,
    this.itemCodeableConcept,
    this.itemReference,
    });

  factory SupplyDelivery_SuppliedItem.fromJson(Map<String, dynamic> json) => _$SupplyDelivery_SuppliedItemFromJson(json);
  Map<String, dynamic> toJson() => _$SupplyDelivery_SuppliedItemToJson(this);
}

part 'supplyRequest.g.dart';

@JsonSerializable(explicitToJson: true)
class SupplyRequest {

//  This is a SupplyRequest resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Business identifiers assigned to this SupplyRequest by the author
// and/or other systems. These identifiers remain constant as the resource
// is updated and propagates from server to server.
List<Identifier> identifier;

//  Status of the supply request.
String status; // <code> enum: draft/active/suspended/cancelled/completed/entered-in-error/unknown;

//  Category of supply, e.g.  central, non-stock, etc. This is used to
// support work flows associated with the supply process.
CodeableConcept category;

//  Indicates how quickly this SupplyRequest should be addressed with
// respect to other requests.
String priority;

//  The item that is requested to be supplied. This is either a link to a
// resource representing the details of the item or a code that identifies
// the item from a known list.
CodeableConcept itemCodeableConcept;

//  The item that is requested to be supplied. This is either a link to a
// resource representing the details of the item or a code that identifies
// the item from a known list.
Reference itemReference;

//  The amount that is being ordered of the indicated item.
Quantity quantity;

//  Specific parameters for the ordered item.  For example, the size of
// the indicated item.
List<SupplyRequest_Parameter> parameter;

//  When the request should be fulfilled.
String occurrenceDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  When the request should be fulfilled.
Period occurrencePeriod;

//  When the request should be fulfilled.
Timing occurrenceTiming;

//  When the request was made.
DateTime authoredOn;

//  The device, practitioner, etc. who initiated the request.
Reference requester;

//  Who is intended to fulfill the request.
List<Reference> supplier;

//  The reason why the supply item was requested.
List<CodeableConcept> reasonCode;

//  The reason why the supply item was requested.
List<Reference> reasonReference;

//  Where the supply is expected to come from.
Reference deliverFrom;

//  Where the supply is destined to go.
Reference deliverTo;

SupplyRequest(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.category,
    this.priority,
    this.itemCodeableConcept,
    this.itemReference,
    this.quantity,
    this.parameter,
    this.occurrenceDateTime,
    this.occurrencePeriod,
    this.occurrenceTiming,
    this.authoredOn,
    this.requester,
    this.supplier,
    this.reasonCode,
    this.reasonReference,
    this.deliverFrom,
    this.deliverTo,
    });

  factory SupplyRequest.fromJson(Map<String, dynamic> json) => _$SupplyRequestFromJson(json);
  Map<String, dynamic> toJson() => _$SupplyRequestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class SupplyRequest_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code or string that identifies the device detail being asserted.
CodeableConcept code;

//  The value of the device detail.
CodeableConcept valueCodeableConcept;

//  The value of the device detail.
Quantity valueQuantity;

//  The value of the device detail.
Range valueRange;

//  The value of the device detail.
bool valueBoolean; //  pattern: ^true|false$

SupplyRequest_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.valueCodeableConcept,
    this.valueQuantity,
    this.valueRange,
    this.valueBoolean,
    });

  factory SupplyRequest_Parameter.fromJson(Map<String, dynamic> json) => _$SupplyRequest_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$SupplyRequest_ParameterToJson(this);
}

part 'task.g.dart';

@JsonSerializable(explicitToJson: true)
class Task {

//  This is a Task resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  The business identifier for this task.
List<Identifier> identifier;

//  The URL pointing to a *FHIR*-defined protocol, guideline, orderset or
// other definition that is adhered to in whole or in part by this Task.
String instantiatesCanonical;

//  The URL pointing to an *externally* maintained  protocol, guideline,
// orderset or other definition that is adhered to in whole or in part by
// this Task.
String instantiatesUri;

//  BasedOn refers to a higher-level authorization that triggered the
// creation of the task.  It references a "request" resource such as a
// ServiceRequest, MedicationRequest, ServiceRequest, CarePlan, etc. which
// is distinct from the "request" resource the task is seeking to fulfill.
//  This latter resource is referenced by FocusOn.  For example, based on
// a ServiceRequest (= BasedOn), a task is created to fulfill a
// procedureRequest ( = FocusOn ) to collect a specimen from a patient.
List<Reference> basedOn;

//  An identifier that links together multiple tasks and other requests
// that were created in the same context.
Identifier groupIdentifier;

//  Task that this particular task is part of.
List<Reference> partOf;

//  The current status of the task.
String status; // <code> enum: draft/requested/received/accepted/rejected/ready/cancelled/in-progress/on-hold/failed/completed/entered-in-error;

//  An explanation as to why this task is held, failed, was refused, etc.
CodeableConcept statusReason;

//  Contains business-specific nuances of the business state.
CodeableConcept businessStatus;

//  Indicates the "level" of actionability associated with the Task, i.e.
// i+R[9]Cs this a proposed task, a planned task, an actionable task, etc.
String intent; // <code> enum: unknown/proposal/plan/order/original-order/reflex-order/filler-order/instance-order/option;

//  Indicates how quickly the Task should be addressed with respect to
// other requests.
String priority;

//  A name or code (or both) briefly describing what the task involves.
CodeableConcept code;

//  A free-text description of what is to be performed.
String description;

//  The request being actioned or the resource being manipulated by this
// task.
Reference focus;

//  The entity who benefits from the performance of the service specified
// in the task (e.g., the patient).
Reference for;

//  The healthcare event  (e.g. a patient and healthcare provider
// interaction) during which this task was created.
Reference encounter;

//  Identifies the time action was first taken against the task (start)
// and/or the time final action was taken against the task prior to
// marking it as completed (end).
Period executionPeriod;

//  The date and time this task was created.
DateTime authoredOn;

//  The date and time of last modification to this task.
DateTime lastModified;

//  The creator of the task.
Reference requester;

//  The kind of participant that should perform the task.
List<CodeableConcept> performerType;

//  Individual organization or Device currently responsible for task
// execution.
Reference owner;

//  Principal physical location where the this task is performed.
Reference location;

//  A description or code indicating why this task needs to be performed.
CodeableConcept reasonCode;

//  A resource reference indicating why this task needs to be performed.
Reference reasonReference;

//  Insurance plans, coverage extensions, pre-authorizations and/or
// pre-determinations that may be relevant to the Task.
List<Reference> insurance;

//  Free-text information captured about the task as it progresses.
List<Annotation> note;

//  Links to Provenance records for past versions of this Task that
// identify key state transitions or updates that are likely to be
// relevant to a user looking at the current version of the task.
List<Reference> relevantHistory;

//  If the Task.focus is a request resource and the task is seeking
// fulfillment (i.e. is asking for the request to be actioned), this
// element identifies any limitations on what parts of the referenced
// request should be actioned.
Task_Restriction restriction;

//  Additional information that may be needed in the execution of the
// task.
List<Task_Input> input;

//  Outputs produced by the Task.
List<Task_Output> output;

Task(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.instantiatesCanonical,
    this.instantiatesUri,
    this.basedOn,
    this.groupIdentifier,
    this.partOf,
    this.status,
    this.statusReason,
    this.businessStatus,
    this.intent,
    this.priority,
    this.code,
    this.description,
    this.focus,
    this.for,
    this.encounter,
    this.executionPeriod,
    this.authoredOn,
    this.lastModified,
    this.requester,
    this.performerType,
    this.owner,
    this.location,
    this.reasonCode,
    this.reasonReference,
    this.insurance,
    this.note,
    this.relevantHistory,
    this.restriction,
    this.input,
    this.output,
    });

  factory Task.fromJson(Map<String, dynamic> json) => _$TaskFromJson(json);
  Map<String, dynamic> toJson() => _$TaskToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Task_Restriction {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Indicates the number of times the requested action should occur.
int repetitions;

//  Over what time-period is fulfillment sought.
Period period;

//  For requests that are targeted to more than on potential
// recipient/target, for whom is fulfillment sought?
List<Reference> recipient;

Task_Restriction(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.repetitions,
    this.period,
    this.recipient,
    });

  factory Task_Restriction.fromJson(Map<String, dynamic> json) => _$Task_RestrictionFromJson(json);
  Map<String, dynamic> toJson() => _$Task_RestrictionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Task_Input {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code or description indicating how the input is intended to be used
// as part of the task execution.
CodeableConcept type;

//  The value of the input parameter as a basic type.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  The value of the input parameter as a basic type.
bool valueBoolean; //  pattern: ^true|false$

//  The value of the input parameter as a basic type.
String valueCanonical; //  pattern: ^\S*$

//  The value of the input parameter as a basic type.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The value of the input parameter as a basic type.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The value of the input parameter as a basic type.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The value of the input parameter as a basic type.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The value of the input parameter as a basic type.
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  The value of the input parameter as a basic type.
String valueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The value of the input parameter as a basic type.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The value of the input parameter as a basic type.
String valueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  The value of the input parameter as a basic type.
String valueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  The value of the input parameter as a basic type.
int valuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The value of the input parameter as a basic type.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The value of the input parameter as a basic type.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The value of the input parameter as a basic type.
int valueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The value of the input parameter as a basic type.
String valueUri; //  pattern: ^\S*$

//  The value of the input parameter as a basic type.
String valueUrl; //  pattern: ^\S*$

//  The value of the input parameter as a basic type.
String valueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  The value of the input parameter as a basic type.
Address valueAddress;

//  The value of the input parameter as a basic type.
Age valueAge;

//  The value of the input parameter as a basic type.
Annotation valueAnnotation;

//  The value of the input parameter as a basic type.
Attachment valueAttachment;

//  The value of the input parameter as a basic type.
CodeableConcept valueCodeableConcept;

//  The value of the input parameter as a basic type.
Coding valueCoding;

//  The value of the input parameter as a basic type.
ContactPoint valueContactPoint;

//  The value of the input parameter as a basic type.
Count valueCount;

//  The value of the input parameter as a basic type.
Distance valueDistance;

//  The value of the input parameter as a basic type.
Duration valueDuration;

//  The value of the input parameter as a basic type.
HumanName valueHumanName;

//  The value of the input parameter as a basic type.
Identifier valueIdentifier;

//  The value of the input parameter as a basic type.
Money valueMoney;

//  The value of the input parameter as a basic type.
Period valuePeriod;

//  The value of the input parameter as a basic type.
Quantity valueQuantity;

//  The value of the input parameter as a basic type.
Range valueRange;

//  The value of the input parameter as a basic type.
Ratio valueRatio;

//  The value of the input parameter as a basic type.
Reference valueReference;

//  The value of the input parameter as a basic type.
SampledData valueSampledData;

//  The value of the input parameter as a basic type.
Signature valueSignature;

//  The value of the input parameter as a basic type.
Timing valueTiming;

//  The value of the input parameter as a basic type.
ContactDetail valueContactDetail;

//  The value of the input parameter as a basic type.
Contributor valueContributor;

//  The value of the input parameter as a basic type.
DataRequirement valueDataRequirement;

//  The value of the input parameter as a basic type.
Expression valueExpression;

//  The value of the input parameter as a basic type.
ParameterDefinition valueParameterDefinition;

//  The value of the input parameter as a basic type.
RelatedArtifact valueRelatedArtifact;

//  The value of the input parameter as a basic type.
TriggerDefinition valueTriggerDefinition;

//  The value of the input parameter as a basic type.
UsageContext valueUsageContext;

//  The value of the input parameter as a basic type.
Dosage valueDosage;

//  The value of the input parameter as a basic type.
Meta valueMeta;

Task_Input(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueBase64Binary,
    this.valueBoolean,
    this.valueCanonical,
    this.valueCode,
    this.valueDate,
    this.valueDateTime,
    this.valueDecimal,
    this.valueId,
    this.valueInstant,
    this.valueInteger,
    this.valueMarkdown,
    this.valueOid,
    this.valuePositiveInt,
    this.valueString,
    this.valueTime,
    this.valueUnsignedInt,
    this.valueUri,
    this.valueUrl,
    this.valueUuid,
    this.valueAddress,
    this.valueAge,
    this.valueAnnotation,
    this.valueAttachment,
    this.valueCodeableConcept,
    this.valueCoding,
    this.valueContactPoint,
    this.valueCount,
    this.valueDistance,
    this.valueDuration,
    this.valueHumanName,
    this.valueIdentifier,
    this.valueMoney,
    this.valuePeriod,
    this.valueQuantity,
    this.valueRange,
    this.valueRatio,
    this.valueReference,
    this.valueSampledData,
    this.valueSignature,
    this.valueTiming,
    this.valueContactDetail,
    this.valueContributor,
    this.valueDataRequirement,
    this.valueExpression,
    this.valueParameterDefinition,
    this.valueRelatedArtifact,
    this.valueTriggerDefinition,
    this.valueUsageContext,
    this.valueDosage,
    this.valueMeta,
    });

  factory Task_Input.fromJson(Map<String, dynamic> json) => _$Task_InputFromJson(json);
  Map<String, dynamic> toJson() => _$Task_InputToJson(this);
}

@JsonSerializable(explicitToJson: true)
class Task_Output {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of the Output parameter.
CodeableConcept type;

//  The value of the Output parameter as a basic type.
String valueBase64Binary; //  pattern: ^(\s*([0-9a-zA-Z\+/=]){4}\s*)+$

//  The value of the Output parameter as a basic type.
bool valueBoolean; //  pattern: ^true|false$

//  The value of the Output parameter as a basic type.
String valueCanonical; //  pattern: ^\S*$

//  The value of the Output parameter as a basic type.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The value of the Output parameter as a basic type.
String valueDate; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?$

//  The value of the Output parameter as a basic type.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

//  The value of the Output parameter as a basic type.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The value of the Output parameter as a basic type.
String valueId; //  pattern: ^[A-Za-z0-9\-\.]{1,64}$

//  The value of the Output parameter as a basic type.
String valueInstant; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))$

//  The value of the Output parameter as a basic type.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The value of the Output parameter as a basic type.
String valueMarkdown; //  pattern: ^[ \r\n\t\S]+$

//  The value of the Output parameter as a basic type.
String valueOid; //  pattern: ^urn:oid:[0-2](\.(0|[1-9][0-9]*))+$

//  The value of the Output parameter as a basic type.
int valuePositiveInt; //  pattern: ^[1-9][0-9]*$

//  The value of the Output parameter as a basic type.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The value of the Output parameter as a basic type.
String valueTime; //  pattern: ^([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?$

//  The value of the Output parameter as a basic type.
int valueUnsignedInt; //  pattern: ^[0]|([1-9][0-9]*)$

//  The value of the Output parameter as a basic type.
String valueUri; //  pattern: ^\S*$

//  The value of the Output parameter as a basic type.
String valueUrl; //  pattern: ^\S*$

//  The value of the Output parameter as a basic type.
String valueUuid; //  pattern: ^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$

//  The value of the Output parameter as a basic type.
Address valueAddress;

//  The value of the Output parameter as a basic type.
Age valueAge;

//  The value of the Output parameter as a basic type.
Annotation valueAnnotation;

//  The value of the Output parameter as a basic type.
Attachment valueAttachment;

//  The value of the Output parameter as a basic type.
CodeableConcept valueCodeableConcept;

//  The value of the Output parameter as a basic type.
Coding valueCoding;

//  The value of the Output parameter as a basic type.
ContactPoint valueContactPoint;

//  The value of the Output parameter as a basic type.
Count valueCount;

//  The value of the Output parameter as a basic type.
Distance valueDistance;

//  The value of the Output parameter as a basic type.
Duration valueDuration;

//  The value of the Output parameter as a basic type.
HumanName valueHumanName;

//  The value of the Output parameter as a basic type.
Identifier valueIdentifier;

//  The value of the Output parameter as a basic type.
Money valueMoney;

//  The value of the Output parameter as a basic type.
Period valuePeriod;

//  The value of the Output parameter as a basic type.
Quantity valueQuantity;

//  The value of the Output parameter as a basic type.
Range valueRange;

//  The value of the Output parameter as a basic type.
Ratio valueRatio;

//  The value of the Output parameter as a basic type.
Reference valueReference;

//  The value of the Output parameter as a basic type.
SampledData valueSampledData;

//  The value of the Output parameter as a basic type.
Signature valueSignature;

//  The value of the Output parameter as a basic type.
Timing valueTiming;

//  The value of the Output parameter as a basic type.
ContactDetail valueContactDetail;

//  The value of the Output parameter as a basic type.
Contributor valueContributor;

//  The value of the Output parameter as a basic type.
DataRequirement valueDataRequirement;

//  The value of the Output parameter as a basic type.
Expression valueExpression;

//  The value of the Output parameter as a basic type.
ParameterDefinition valueParameterDefinition;

//  The value of the Output parameter as a basic type.
RelatedArtifact valueRelatedArtifact;

//  The value of the Output parameter as a basic type.
TriggerDefinition valueTriggerDefinition;

//  The value of the Output parameter as a basic type.
UsageContext valueUsageContext;

//  The value of the Output parameter as a basic type.
Dosage valueDosage;

//  The value of the Output parameter as a basic type.
Meta valueMeta;

Task_Output(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.valueBase64Binary,
    this.valueBoolean,
    this.valueCanonical,
    this.valueCode,
    this.valueDate,
    this.valueDateTime,
    this.valueDecimal,
    this.valueId,
    this.valueInstant,
    this.valueInteger,
    this.valueMarkdown,
    this.valueOid,
    this.valuePositiveInt,
    this.valueString,
    this.valueTime,
    this.valueUnsignedInt,
    this.valueUri,
    this.valueUrl,
    this.valueUuid,
    this.valueAddress,
    this.valueAge,
    this.valueAnnotation,
    this.valueAttachment,
    this.valueCodeableConcept,
    this.valueCoding,
    this.valueContactPoint,
    this.valueCount,
    this.valueDistance,
    this.valueDuration,
    this.valueHumanName,
    this.valueIdentifier,
    this.valueMoney,
    this.valuePeriod,
    this.valueQuantity,
    this.valueRange,
    this.valueRatio,
    this.valueReference,
    this.valueSampledData,
    this.valueSignature,
    this.valueTiming,
    this.valueContactDetail,
    this.valueContributor,
    this.valueDataRequirement,
    this.valueExpression,
    this.valueParameterDefinition,
    this.valueRelatedArtifact,
    this.valueTriggerDefinition,
    this.valueUsageContext,
    this.valueDosage,
    this.valueMeta,
    });

  factory Task_Output.fromJson(Map<String, dynamic> json) => _$Task_OutputFromJson(json);
  Map<String, dynamic> toJson() => _$Task_OutputToJson(this);
}

part 'terminologyCapabilities.g.dart';

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities {

//  This is a TerminologyCapabilities resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this terminology capabilities
// when it is referenced in a specification, model, design or an instance;
// also called its canonical identifier. This SHOULD be globally unique
// and SHOULD be a literal address at which at which an authoritative
// instance of this terminology capabilities is (or will be) published.
// This URL can be the target of a canonical reference. It SHALL remain
// the same when the terminology capabilities is stored on different
// servers.
String url;

//  The identifier that is used to identify this version of the
// terminology capabilities when it is referenced in a specification,
// model, design or instance. This is an arbitrary value managed by the
// terminology capabilities author and is not expected to be globally
// unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
// managed version is not available. There is also no expectation that
// versions can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the terminology capabilities. This
// name should be usable as an identifier for the module by machine
// processing applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the terminology
// capabilities.
String title;

//  The status of this terminology capabilities. Enables tracking the
// life-cycle of the content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this terminology capabilities is
// authored for testing purposes (or education/evaluation/marketing) and
// is not intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the terminology capabilities was
// published. The date must change when the business version changes and
// it must change if the status code changes. In addition, it should
// change when the substantive content of the terminology capabilities
// changes.
DateTime date;

//  The name of the organization or individual that published the
// terminology capabilities.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the terminology
// capabilities from a consumer's perspective. Typically, this is used
// when the capability statement describes a desired rather than an actual
// solution, for example as a formal expression of requirements as part of
// an RFP.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate terminology capabilities instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the terminology capabilities is
// intended to be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this terminology capabilities is needed and why it
// has been designed as it has.
String purpose;

//  A copyright statement relating to the terminology capabilities and/or
// its contents. Copyright statements are generally legal restrictions on
// the use and publishing of the terminology capabilities.
String copyright;

//  The way that this statement is intended to be used, to describe an
// actual running instance of software, a particular product (kind, not
// instance of software) or a class of implementation (e.g. a desired
// purchase).
String kind;

//  Software that is covered by this terminology capability statement.  It
// is used when the statement describes the capabilities of a particular
// software version, independent of an installation.
TerminologyCapabilities_Software software;

//  Identifies a specific implementation instance that is described by the
// terminology capability statement - i.e. a particular installation,
// rather than the capabilities of a software program.
TerminologyCapabilities_Implementation implementation;

//  Whether the server supports lockedDate.
bool lockedDate;

//  Identifies a code system that is supported by the server. If there is
// a no code system URL, then this declares the general assumptions a
// client can make about support for any CodeSystem resource.
List<TerminologyCapabilities_CodeSystem> codeSystem;

//  Information about the
// [ValueSet/$expand](valueset-operation-expand.html) operation.
TerminologyCapabilities_Expansion expansion;

//  The degree to which the server supports the code search parameter on
// ValueSet, if it is supported.
String codeSearch; // <code> enum: explicit/all;

//  Information about the
// [ValueSet/$validate-code](valueset-operation-validate-code.html)
// operation.
TerminologyCapabilities_ValidateCode validateCode;

//  Information about the
// [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
TerminologyCapabilities_Translation translation;

//  Whether the $closure operation is supported.
TerminologyCapabilities_Closure closure;

TerminologyCapabilities(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.kind,
    this.software,
    this.implementation,
    this.lockedDate,
    this.codeSystem,
    this.expansion,
    this.codeSearch,
    this.validateCode,
    this.translation,
    this.closure,
    });

  factory TerminologyCapabilities.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilitiesFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilitiesToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Software {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name the software is known by.
String name;

//  The version identifier for the software covered by this statement.
String version;

TerminologyCapabilities_Software(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.version,
    });

  factory TerminologyCapabilities_Software.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_SoftwareFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_SoftwareToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Implementation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Information about the specific installation that this terminology
// capability statement relates to.
String description;

//  An absolute base URL for the implementation.
String url;

TerminologyCapabilities_Implementation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.description,
    this.url,
    });

  factory TerminologyCapabilities_Implementation.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_ImplementationFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_ImplementationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_CodeSystem {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  URI for the Code System.
String uri;

//  For the code system, a list of versions that are supported by the
// server.
List<TerminologyCapabilities_Version> version;

//  True if subsumption is supported for this version of the code system.
bool subsumption;

TerminologyCapabilities_CodeSystem(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.uri,
    this.version,
    this.subsumption,
    });

  factory TerminologyCapabilities_CodeSystem.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_CodeSystemFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_CodeSystemToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Version {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  For version-less code systems, there should be a single version with
// no identifier.
String code;

//  If this is the default version for this code system.
bool isDefault;

//  If the compositional grammar defined by the code system is supported.
bool compositional;

//  Language Displays supported.
List<String> language;

//  Filter Properties supported.
List<TerminologyCapabilities_Filter> filter;

//  Properties supported for $lookup.
List<String> property;

TerminologyCapabilities_Version(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.isDefault,
    this.compositional,
    this.language,
    this.filter,
    this.property,
    });

  factory TerminologyCapabilities_Version.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_VersionFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_VersionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Filter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Code of the property supported.
String code;

//  Operations supported for the property.
List<String> op;

TerminologyCapabilities_Filter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.op,
    });

  factory TerminologyCapabilities_Filter.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_FilterFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_FilterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Expansion {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether the server can return nested value sets.
bool hierarchical;

//  Whether the server supports paging on expansion.
bool paging;

//  Allow request for incomplete expansions?
bool incomplete;

//  Supported expansion parameter.
List<TerminologyCapabilities_Parameter> parameter;

//  Documentation about text searching works.
String textFilter;

TerminologyCapabilities_Expansion(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.hierarchical,
    this.paging,
    this.incomplete,
    this.parameter,
    this.textFilter,
    });

  factory TerminologyCapabilities_Expansion.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_ExpansionFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_ExpansionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Expansion Parameter name.
String name;

//  Description of support for parameter.
String documentation;

TerminologyCapabilities_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.documentation,
    });

  factory TerminologyCapabilities_Parameter.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_ParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_ValidateCode {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether translations are validated.
bool translations;

TerminologyCapabilities_ValidateCode(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.translations,
    });

  factory TerminologyCapabilities_ValidateCode.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_ValidateCodeFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_ValidateCodeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Translation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether the client must identify the map.
bool needsMap;

TerminologyCapabilities_Translation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.needsMap,
    });

  factory TerminologyCapabilities_Translation.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_TranslationFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_TranslationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TerminologyCapabilities_Closure {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  If cross-system closure is supported.
bool translation;

TerminologyCapabilities_Closure(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.translation,
    });

  factory TerminologyCapabilities_Closure.fromJson(Map<String, dynamic> json) => _$TerminologyCapabilities_ClosureFromJson(json);
  Map<String, dynamic> toJson() => _$TerminologyCapabilities_ClosureToJson(this);
}

part 'testReport.g.dart';

@JsonSerializable(explicitToJson: true)
class TestReport {

//  This is a TestReport resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  Identifier for the TestScript assigned for external purposes outside
// the context of FHIR.
Identifier identifier;

//  A free text natural language name identifying the executed TestScript.
String name;

//  The current state of this test report.
String status; // <code> enum: completed/in-progress/waiting/stopped/entered-in-error;

//  Ideally this is an absolute URL that is used to identify the
// version-specific TestScript that was executed, matching the
// `TestScript.url`.
Reference testScript;

//  The overall result from the execution of the TestScript.
String result; // <code> enum: pass/fail/pending;

//  The final score (percentage of tests passed) resulting from the
// execution of the TestScript.
double score;

//  Name of the tester producing this report (Organization or individual).
String tester;

//  When the TestScript was executed and this TestReport was generated.
DateTime issued;

//  A participant in the test execution, either the execution engine, a
// client, or a server.
List<TestReport_Participant> participant;

//  The results of the series of required setup operations before the
// tests were executed.
TestReport_Setup setup;

//  A test executed from the test script.
List<TestReport_Test> test;

//  The results of the series of operations required to clean up after all
// the tests were executed (successfully or otherwise).
TestReport_Teardown teardown;

TestReport(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.name,
    this.status,
    this.testScript,
    this.result,
    this.score,
    this.tester,
    this.issued,
    this.participant,
    this.setup,
    this.test,
    this.teardown,
    });

  factory TestReport.fromJson(Map<String, dynamic> json) => _$TestReportFromJson(json);
  Map<String, dynamic> toJson() => _$TestReportToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Participant {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The type of participant.
String type; // <code> enum: test-engine/client/server;

//  The uri of the participant. An absolute URL is preferred.
String uri;

//  The display name of the participant.
String display;

TestReport_Participant(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.uri,
    this.display,
    });

  factory TestReport_Participant.fromJson(Map<String, dynamic> json) => _$TestReport_ParticipantFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_ParticipantToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Setup {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Action would contain either an operation or an assertion.
List<TestReport_Action> action;

TestReport_Setup(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    });

  factory TestReport_Setup.fromJson(Map<String, dynamic> json) => _$TestReport_SetupFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_SetupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Action {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The operation performed.
TestReport_Operation operation;

//  The results of the assertion performed on the previous operations.
TestReport_Assert assert;

TestReport_Action(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    this.assert,
    });

  factory TestReport_Action.fromJson(Map<String, dynamic> json) => _$TestReport_ActionFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_ActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Operation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The result of this operation.
String result; // <code> enum: pass/skip/fail/warning/error;

//  An explanatory message associated with the result.
String message;

//  A link to further details on the result.
String detail;

TestReport_Operation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.result,
    this.message,
    this.detail,
    });

  factory TestReport_Operation.fromJson(Map<String, dynamic> json) => _$TestReport_OperationFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_OperationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Assert {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The result of this assertion.
String result; // <code> enum: pass/skip/fail/warning/error;

//  An explanatory message associated with the result.
String message;

//  A link to further details on the result.
String detail;

TestReport_Assert(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.result,
    this.message,
    this.detail,
    });

  factory TestReport_Assert.fromJson(Map<String, dynamic> json) => _$TestReport_AssertFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_AssertToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Test {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of this test used for tracking/logging purposes by test
// engines.
String name;

//  A short description of the test used by test engines for tracking and
// reporting purposes.
String description;

//  Action would contain either an operation or an assertion.
List<TestReport_Action1> action;

TestReport_Test(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.description,
    this.action,
    });

  factory TestReport_Test.fromJson(Map<String, dynamic> json) => _$TestReport_TestFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_TestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Action1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An operation would involve a REST request to a server.
TestReport_Operation operation;

//  The results of the assertion performed on the previous operations.
TestReport_Assert assert;

TestReport_Action1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    this.assert,
    });

  factory TestReport_Action1.fromJson(Map<String, dynamic> json) => _$TestReport_Action1FromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_Action1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Teardown {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The teardown action will only contain an operation.
List<TestReport_Action2> action;

TestReport_Teardown(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    });

  factory TestReport_Teardown.fromJson(Map<String, dynamic> json) => _$TestReport_TeardownFromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_TeardownToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestReport_Action2 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An operation would involve a REST request to a server.
TestReport_Operation operation;

TestReport_Action2(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    });

  factory TestReport_Action2.fromJson(Map<String, dynamic> json) => _$TestReport_Action2FromJson(json);
  Map<String, dynamic> toJson() => _$TestReport_Action2ToJson(this);
}

part 'testScript.g.dart';

@JsonSerializable(explicitToJson: true)
class TestScript {

//  This is a TestScript resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this test script when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this test script is (or will be) published. This URL can be the
// target of a canonical reference. It SHALL remain the same when the test
// script is stored on different servers.
String url;

//  A formal identifier that is used to identify this test script when it
// is represented in other formats, or referenced in a specification,
// model, design or an instance.
Identifier identifier;

//  The identifier that is used to identify this version of the test
// script when it is referenced in a specification, model, design or
// instance. This is an arbitrary value managed by the test script author
// and is not expected to be globally unique. For example, it might be a
// timestamp (e.g. yyyymmdd) if a managed version is not available. There
// is also no expectation that versions can be placed in a lexicographical
// sequence.
String version;

//  A natural language name identifying the test script. This name should
// be usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the test script.
String title;

//  The status of this test script. Enables tracking the life-cycle of the
// content.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this test script is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date  (and optionally time) when the test script was published.
// The date must change when the business version changes and it must
// change if the status code changes. In addition, it should change when
// the substantive content of the test script changes.
DateTime date;

//  The name of the organization or individual that published the test
// script.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the test script from a
// consumer's perspective.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate test script instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the test script is intended to
// be used.
List<CodeableConcept> jurisdiction;

//  Explanation of why this test script is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the test script and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the test script.
String copyright;

//  An abstract server used in operations within this test script in the
// origin element.
List<TestScript_Origin> origin;

//  An abstract server used in operations within this test script in the
// destination element.
List<TestScript_Destination> destination;

//  The required capability must exist and are assumed to function
// correctly on the FHIR server being tested.
TestScript_Metadata metadata;

//  Fixture in the test script - by reference (uri). All fixtures are
// required for the test script to execute.
List<TestScript_Fixture> fixture;

//  Reference to the profile to be used for validation.
List<Reference> profile;

//  Variable is set based either on element value in response body or on
// header field value in the response headers.
List<TestScript_Variable> variable;

//  A series of required setup operations before tests are executed.
TestScript_Setup setup;

//  A test in this script.
List<TestScript_Test> test;

//  A series of operations required to clean up after all the tests are
// executed (successfully or otherwise).
TestScript_Teardown teardown;

TestScript(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.purpose,
    this.copyright,
    this.origin,
    this.destination,
    this.metadata,
    this.fixture,
    this.profile,
    this.variable,
    this.setup,
    this.test,
    this.teardown,
    });

  factory TestScript.fromJson(Map<String, dynamic> json) => _$TestScriptFromJson(json);
  Map<String, dynamic> toJson() => _$TestScriptToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Origin {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Abstract name given to an origin server in this test script.  The name
// is provided as a number starting at 1.
int index;

//  The type of origin profile the test system supports.
Coding profile;

TestScript_Origin(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.index,
    this.profile,
    });

  factory TestScript_Origin.fromJson(Map<String, dynamic> json) => _$TestScript_OriginFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_OriginToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Destination {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Abstract name given to a destination server in this test script.  The
// name is provided as a number starting at 1.
int index;

//  The type of destination profile the test system supports.
Coding profile;

TestScript_Destination(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.index,
    this.profile,
    });

  factory TestScript_Destination.fromJson(Map<String, dynamic> json) => _$TestScript_DestinationFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_DestinationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Metadata {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A link to the FHIR specification that this test is covering.
List<TestScript_Link> link;

//  Capabilities that must exist and are assumed to function correctly on
// the FHIR server being tested.
List<TestScript_Capability> capability;

TestScript_Metadata(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.link,
    this.capability,
    });

  factory TestScript_Metadata.fromJson(Map<String, dynamic> json) => _$TestScript_MetadataFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_MetadataToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Link {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  URL to a particular requirement or feature within the FHIR
// specification.
String url;

//  Short description of the link.
String description;

TestScript_Link(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.url,
    this.description,
    });

  factory TestScript_Link.fromJson(Map<String, dynamic> json) => _$TestScript_LinkFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_LinkToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Capability {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether or not the test execution will require the given capabilities
// of the server in order for this test script to execute.
bool required;

//  Whether or not the test execution will validate the given capabilities
// of the server in order for this test script to execute.
bool validated;

//  Description of the capabilities that this test script is requiring the
// server to support.
String description;

//  Which origin server these requirements apply to.
List<int> origin;

//  Which server these requirements apply to.
int destination;

//  Links to the FHIR specification that describes this interaction and
// the resources involved in more detail.
List<String> link;

//  Minimum capabilities required of server for test script to execute
// successfully.   If server does not meet at a minimum the referenced
// capability statement, then all tests in this script are skipped.
String capabilities;

TestScript_Capability(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.required,
    this.validated,
    this.description,
    this.origin,
    this.destination,
    this.link,
    this.capabilities,
    });

  factory TestScript_Capability.fromJson(Map<String, dynamic> json) => _$TestScript_CapabilityFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_CapabilityToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Fixture {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Whether or not to implicitly create the fixture during setup. If true,
// the fixture is automatically created on each server being tested during
// setup, therefore no create operation is required for this fixture in
// the TestScript.setup section.
bool autocreate;

//  Whether or not to implicitly delete the fixture during teardown. If
// true, the fixture is automatically deleted on each server being tested
// during teardown, therefore no delete operation is required for this
// fixture in the TestScript.teardown section.
bool autodelete;

//  Reference to the resource (containing the contents of the resource
// needed for operations).
Reference resource;

TestScript_Fixture(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.autocreate,
    this.autodelete,
    this.resource,
    });

  factory TestScript_Fixture.fromJson(Map<String, dynamic> json) => _$TestScript_FixtureFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_FixtureToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Variable {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Descriptive name for this variable.
String name;

//  A default, hard-coded, or user-defined value for this variable.
String defaultValue;

//  A free text natural language description of the variable and its
// purpose.
String description;

//  The FHIRPath expression to evaluate against the fixture body. When
// variables are defined, only one of either expression, headerField or
// path must be specified.
String expression;

//  Will be used to grab the HTTP header field value from the headers that
// sourceId is pointing to.
String headerField;

//  Displayable text string with hint help information to the user when
// entering a default value.
String hint;

//  XPath or JSONPath to evaluate against the fixture body.  When
// variables are defined, only one of either expression, headerField or
// path must be specified.
String path;

//  Fixture to evaluate the XPath/JSONPath expression or the headerField 
// against within this variable.
String sourceId;

TestScript_Variable(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.defaultValue,
    this.description,
    this.expression,
    this.headerField,
    this.hint,
    this.path,
    this.sourceId,
    });

  factory TestScript_Variable.fromJson(Map<String, dynamic> json) => _$TestScript_VariableFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_VariableToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Setup {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Action would contain either an operation or an assertion.
List<TestScript_Action> action;

TestScript_Setup(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    });

  factory TestScript_Setup.fromJson(Map<String, dynamic> json) => _$TestScript_SetupFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_SetupToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Action {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The operation to perform.
TestScript_Operation operation;

//  Evaluates the results of previous operations to determine if the
// server under test behaves appropriately.
TestScript_Assert assert;

TestScript_Action(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    this.assert,
    });

  factory TestScript_Action.fromJson(Map<String, dynamic> json) => _$TestScript_ActionFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_ActionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Operation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Server interaction or operation type.
Coding type;

//  The type of the resource.  See
// http://build.fhir.org/resourcelist.html.
String resource;

//  The label would be used for tracking/logging purposes by test engines.
String label;

//  The description would be used by test engines for tracking and
// reporting purposes.
String description;

//  The mime-type to use for RESTful operation in the 'Accept' header.
String accept;

//  The mime-type to use for RESTful operation in the 'Content-Type'
// header.
String contentType;

//  The server where the request message is destined for.  Must be one of
// the server numbers listed in TestScript.destination section.
int destination;

//  Whether or not to implicitly send the request url in encoded format.
// The default is true to match the standard RESTful client behavior. Set
// to false when communicating with a server that does not support encoded
// url paths.
bool encodeRequestUrl;

//  The HTTP method the test engine MUST use for this operation regardless
// of any other operation details.
String method; // <code> enum: delete/get/options/patch/post/put/head;

//  The server where the request message originates from.  Must be one of
// the server numbers listed in TestScript.origin section.
int origin;

//  Path plus parameters after [type].  Used to set parts of the request
// URL explicitly.
String params;

//  Header elements would be used to set HTTP headers.
List<TestScript_RequestHeader> requestHeader;

//  The fixture id (maybe new) to map to the request.
String requestId;

//  The fixture id (maybe new) to map to the response.
String responseId;

//  The id of the fixture used as the body of a PUT or POST request.
String sourceId;

//  Id of fixture used for extracting the [id],  [type], and [vid] for GET
// requests.
String targetId;

//  Complete request URL.
String url;

TestScript_Operation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.type,
    this.resource,
    this.label,
    this.description,
    this.accept,
    this.contentType,
    this.destination,
    this.encodeRequestUrl,
    this.method,
    this.origin,
    this.params,
    this.requestHeader,
    this.requestId,
    this.responseId,
    this.sourceId,
    this.targetId,
    this.url,
    });

  factory TestScript_Operation.fromJson(Map<String, dynamic> json) => _$TestScript_OperationFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_OperationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_RequestHeader {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The HTTP header field e.g. "Accept".
String field;

//  The value of the header e.g. "application/fhir+xml".
String value;

TestScript_RequestHeader(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.field,
    this.value,
    });

  factory TestScript_RequestHeader.fromJson(Map<String, dynamic> json) => _$TestScript_RequestHeaderFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_RequestHeaderToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Assert {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The label would be used for tracking/logging purposes by test engines.
String label;

//  The description would be used by test engines for tracking and
// reporting purposes.
String description;

//  The direction to use for the assertion.
String direction; // <code> enum: response/request;

//  Id of the source fixture used as the contents to be evaluated by
// either the "source/expression" or "sourceId/path" definition.
String compareToSourceId;

//  The FHIRPath expression to evaluate against the source fixture. When
// compareToSourceId is defined, either compareToSourceExpression or
// compareToSourcePath must be defined, but not both.
String compareToSourceExpression;

//  XPath or JSONPath expression to evaluate against the source fixture.
// When compareToSourceId is defined, either compareToSourceExpression or
// compareToSourcePath must be defined, but not both.
String compareToSourcePath;

//  The mime-type contents to compare against the request or response
// message 'Content-Type' header.
String contentType;

//  The FHIRPath expression to be evaluated against the request or
// response message contents - HTTP headers and payload.
String expression;

//  The HTTP header field name e.g. 'Location'.
String headerField;

//  The ID of a fixture.  Asserts that the response contains at a minimum
// the fixture specified by minimumId.
String minimumId;

//  Whether or not the test execution performs validation on the bundle
// navigation links.
bool navigationLinks;

//  The operator type defines the conditional behavior of the assert. If
// not defined, the default is equals.
String operator; // <code> enum: equals/notEquals/in/notIn/greaterThan/lessThan/empty/notEmpty/contains/notContains/eval;

//  The XPath or JSONPath expression to be evaluated against the fixture
// representing the response received from server.
String path;

//  The request method or HTTP operation code to compare against that used
// by the client system under test.
String requestMethod; // <code> enum: delete/get/options/patch/post/put/head;

//  The value to use in a comparison against the request URL path string.
String requestURL;

//  The type of the resource.  See
// http://build.fhir.org/resourcelist.html.
String resource;

//  okay | created | noContent | notModified | bad | forbidden | notFound
// | methodNotAllowed | conflict | gone | preconditionFailed |
// unprocessable.
String response; // <code> enum: okay/created/noContent/notModified/bad/forbidden/notFound/methodNotAllowed/conflict/gone/preconditionFailed/unprocessable;

//  The value of the HTTP response code to be tested.
String responseCode;

//  Fixture to evaluate the XPath/JSONPath expression or the headerField 
// against.
String sourceId;

//  The ID of the Profile to validate against.
String validateProfileId;

//  The value to compare to.
String value;

//  Whether or not the test execution will produce a warning only on error
// for this assert.
bool warningOnly;

TestScript_Assert(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.label,
    this.description,
    this.direction,
    this.compareToSourceId,
    this.compareToSourceExpression,
    this.compareToSourcePath,
    this.contentType,
    this.expression,
    this.headerField,
    this.minimumId,
    this.navigationLinks,
    this.operator,
    this.path,
    this.requestMethod,
    this.requestURL,
    this.resource,
    this.response,
    this.responseCode,
    this.sourceId,
    this.validateProfileId,
    this.value,
    this.warningOnly,
    });

  factory TestScript_Assert.fromJson(Map<String, dynamic> json) => _$TestScript_AssertFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_AssertToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Test {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The name of this test used for tracking/logging purposes by test
// engines.
String name;

//  A short description of the test used by test engines for tracking and
// reporting purposes.
String description;

//  Action would contain either an operation or an assertion.
List<TestScript_Action1> action;

TestScript_Test(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.description,
    this.action,
    });

  factory TestScript_Test.fromJson(Map<String, dynamic> json) => _$TestScript_TestFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_TestToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Action1 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An operation would involve a REST request to a server.
TestScript_Operation operation;

//  Evaluates the results of previous operations to determine if the
// server under test behaves appropriately.
TestScript_Assert assert;

TestScript_Action1(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    this.assert,
    });

  factory TestScript_Action1.fromJson(Map<String, dynamic> json) => _$TestScript_Action1FromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_Action1ToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Teardown {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The teardown action will only contain an operation.
List<TestScript_Action2> action;

TestScript_Teardown(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.action,
    });

  factory TestScript_Teardown.fromJson(Map<String, dynamic> json) => _$TestScript_TeardownFromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_TeardownToJson(this);
}

@JsonSerializable(explicitToJson: true)
class TestScript_Action2 {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An operation would involve a REST request to a server.
TestScript_Operation operation;

TestScript_Action2(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.operation,
    });

  factory TestScript_Action2.fromJson(Map<String, dynamic> json) => _$TestScript_Action2FromJson(json);
  Map<String, dynamic> toJson() => _$TestScript_Action2ToJson(this);
}

part 'valueSet.g.dart';

@JsonSerializable(explicitToJson: true)
class ValueSet {

//  This is a ValueSet resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI that is used to identify this value set when it is
// referenced in a specification, model, design or an instance; also
// called its canonical identifier. This SHOULD be globally unique and
// SHOULD be a literal address at which at which an authoritative instance
// of this value set is (or will be) published. This URL can be the target
// of a canonical reference. It SHALL remain the same when the value set
// is stored on different servers.
String url;

//  A formal identifier that is used to identify this value set when it is
// represented in other formats, or referenced in a specification, model,
// design or an instance.
List<Identifier> identifier;

//  The identifier that is used to identify this version of the value set
// when it is referenced in a specification, model, design or instance.
// This is an arbitrary value managed by the value set author and is not
// expected to be globally unique. For example, it might be a timestamp
// (e.g. yyyymmdd) if a managed version is not available. There is also no
// expectation that versions can be placed in a lexicographical sequence.
String version;

//  A natural language name identifying the value set. This name should be
// usable as an identifier for the module by machine processing
// applications such as code generation.
String name;

//  A short, descriptive, user-friendly title for the value set.
String title;

//  The status of this value set. Enables tracking the life-cycle of the
// content. The status of the value set applies to the value set
// definition (ValueSet.compose) and the associated ValueSet metadata.
// Expansions do not have a state.
String status; // <code> enum: draft/active/retired/unknown;

//  A Boolean value to indicate that this value set is authored for
// testing purposes (or education/evaluation/marketing) and is not
// intended to be used for genuine usage.
bool experimental;

//  The date (and optionally time) when the value set was created or
// revised (e.g. the 'content logical definition').
DateTime date;

//  The name of the organization or individual that published the value
// set.
String publisher;

//  Contact details to assist a user in finding and communicating with the
// publisher.
List<ContactDetail> contact;

//  A free text natural language description of the value set from a
// consumer's perspective. The textual description specifies the span of
// meanings for concepts to be included within the Value Set Expansion,
// and also may specify the intended use and limitations of the Value Set.
String description;

//  The content was developed with a focus and intent of supporting the
// contexts that are listed. These contexts may be general categories
// (gender, age, ...) or may be references to specific programs (insurance
// plans, studies, ...) and may be used to assist with indexing and
// searching for appropriate value set instances.
List<UsageContext> useContext;

//  A legal or geographic region in which the value set is intended to be
// used.
List<CodeableConcept> jurisdiction;

//  If this is set to 'true', then no new versions of the content logical
// definition can be created.  Note: Other metadata might still change.
bool immutable;

//  Explanation of why this value set is needed and why it has been
// designed as it has.
String purpose;

//  A copyright statement relating to the value set and/or its contents.
// Copyright statements are generally legal restrictions on the use and
// publishing of the value set.
String copyright;

//  A set of criteria that define the contents of the value set by
// including or excluding codes selected from the specified code system(s)
// that the value set draws from. This is also known as the Content
// Logical Definition (CLD).
ValueSet_Compose compose;

//  A value set can also be "expanded", where the value set is turned into
// a simple collection of enumerated codes. This element holds the
// expansion, if it has been performed.
ValueSet_Expansion expansion;

ValueSet(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.url,
    this.identifier,
    this.version,
    this.name,
    this.title,
    this.status,
    this.experimental,
    this.date,
    this.publisher,
    this.contact,
    this.description,
    this.useContext,
    this.jurisdiction,
    this.immutable,
    this.purpose,
    this.copyright,
    this.compose,
    this.expansion,
    });

  factory ValueSet.fromJson(Map<String, dynamic> json) => _$ValueSetFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSetToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Compose {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The Locked Date is  the effective date that is used to determine the
// version of all referenced Code Systems and Value Set Definitions
// included in the compose that are not already tied to a specific
// version.
String lockedDate;

//  Whether inactive codes - codes that are not approved for current use -
// are in the value set. If inactive = true, inactive codes are to be
// included in the expansion, if inactive = false, the inactive codes will
// not be included in the expansion. If absent, the behavior is determined
// by the implementation, or by the applicable $expand parameters (but
// generally, inactive codes would be expected to be included).
bool inactive;

//  Include one or more codes from a code system or other value set(s).
List<ValueSet_Include> include;

//  Exclude one or more codes from the value set based on code system
// filters and/or other value sets.
List<ValueSet_Include> exclude;

ValueSet_Compose(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.lockedDate,
    this.inactive,
    this.include,
    this.exclude,
    });

  factory ValueSet_Compose.fromJson(Map<String, dynamic> json) => _$ValueSet_ComposeFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_ComposeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Include {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI which is the code system from which the selected codes
// come from.
String system;

//  The version of the code system that the codes are selected from, or
// the special version '*' for all versions.
String version;

//  Specifies a concept to be included or excluded.
List<ValueSet_Concept> concept;

//  Select concepts by specify a matching criterion based on the
// properties (including relationships) defined by the system, or on
// filters defined by the system. If multiple filters are specified, they
// SHALL all be true.
List<ValueSet_Filter> filter;

//  Selects the concepts found in this value set (based on its value set
// definition). This is an absolute URI that is a reference to
// ValueSet.url.  If multiple value sets are specified this includes the
// union of the contents of all of the referenced value sets.
List<String> valueSet;

ValueSet_Include(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.system,
    this.version,
    this.concept,
    this.filter,
    this.valueSet,
    });

  factory ValueSet_Include.fromJson(Map<String, dynamic> json) => _$ValueSet_IncludeFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_IncludeToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Concept {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Specifies a code for the concept to be included or excluded.
String code;

//  The text to display to the user for this concept in the context of
// this valueset. If no display is provided, then applications using the
// value set use the display specified for the code by the system.
String display;

//  Additional representations for this concept when used in this value
// set - other languages, aliases, specialized purposes, used for
// particular purposes, etc.
List<ValueSet_Designation> designation;

ValueSet_Concept(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.code,
    this.display,
    this.designation,
    });

  factory ValueSet_Concept.fromJson(Map<String, dynamic> json) => _$ValueSet_ConceptFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_ConceptToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Designation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The language this designation is defined for.
String language;

//  A code that represents types of uses of designations.
Coding use;

//  The text value for this designation.
String value;

ValueSet_Designation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.language,
    this.use,
    this.value,
    });

  factory ValueSet_Designation.fromJson(Map<String, dynamic> json) => _$ValueSet_DesignationFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_DesignationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Filter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  A code that identifies a property or a filter defined in the code
// system.
String property;

//  The kind of operation to perform as a part of the filter criteria.
String op; // <code> enum: =/is-a/descendent-of/is-not-a/regex/in/not-in/generalizes/exists;

//  The match value may be either a code defined by the system, or a
// string value, which is a regex match on the literal string of the
// property value  (if the filter represents a property defined in
// CodeSystem) or of the system filter value (if the filter represents a
// filter defined in CodeSystem) when the operation is 'regex', or one of
// the values (true and false), when the operation is 'exists'.
String value;

ValueSet_Filter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.property,
    this.op,
    this.value,
    });

  factory ValueSet_Filter.fromJson(Map<String, dynamic> json) => _$ValueSet_FilterFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_FilterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Expansion {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An identifier that uniquely identifies this expansion of the valueset,
// based on a unique combination of the provided parameters, the system
// default parameters, and the underlying system code system versions etc.
// Systems may re-use the same identifier as long as those factors remain
// the same, and the expansion is the same, but are not required to do so.
// This is a business identifier.
String identifier;

//  The time at which the expansion was produced by the expanding system.
DateTime timestamp;

//  The total number of concepts in the expansion. If the number of
// concept nodes in this resource is less than the stated number, then the
// server can return more using the offset parameter.
int total;

//  If paging is being used, the offset at which this resource starts. 
// I.e. this resource is a partial view into the expansion. If paging is
// not being used, this element SHALL NOT be present.
int offset;

//  A parameter that controlled the expansion process. These parameters
// may be used by users of expanded value sets to check whether the
// expansion is suitable for a particular purpose, or to pick the correct
// expansion.
List<ValueSet_Parameter> parameter;

//  The codes that are contained in the value set expansion.
List<ValueSet_Contains> contains;

ValueSet_Expansion(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.timestamp,
    this.total,
    this.offset,
    this.parameter,
    this.contains,
    });

  factory ValueSet_Expansion.fromJson(Map<String, dynamic> json) => _$ValueSet_ExpansionFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_ExpansionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Parameter {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Name of the input parameter to the $expand operation; may be a
// server-assigned name for additional default or other server-supplied
// parameters used to control the expansion process.
String name;

//  The value of the parameter.
String valueString; //  pattern: ^[ \r\n\t\S]+$

//  The value of the parameter.
bool valueBoolean; //  pattern: ^true|false$

//  The value of the parameter.
int valueInteger; //  pattern: ^-?([0]|([1-9][0-9]*))$

//  The value of the parameter.
double valueDecimal; //  pattern: ^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?$

//  The value of the parameter.
String valueUri; //  pattern: ^\S*$

//  The value of the parameter.
String valueCode; //  pattern: ^[^\s]+(\s[^\s]+)*$

//  The value of the parameter.
String valueDateTime; //  pattern: ^([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?$

ValueSet_Parameter(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.name,
    this.valueString,
    this.valueBoolean,
    this.valueInteger,
    this.valueDecimal,
    this.valueUri,
    this.valueCode,
    this.valueDateTime,
    });

  factory ValueSet_Parameter.fromJson(Map<String, dynamic> json) => _$ValueSet_ParameterFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_ParameterToJson(this);
}

@JsonSerializable(explicitToJson: true)
class ValueSet_Contains {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  An absolute URI which is the code system in which the code for this
// item in the expansion is defined.
String system;

//  If true, this entry is included in the expansion for navigational
// purposes, and the user cannot select the code directly as a proper
// value.
bool abstract;

//  If the concept is inactive in the code system that defines it.
// Inactive codes are those that are no longer to be used, but are
// maintained by the code system for understanding legacy data. It might
// not be known or specified whether an concept is inactive (and it may
// depend on the context of use).
bool inactive;

//  The version of the code system from this code was taken. Note that a
// well-maintained code system does not need the version reported, because
// the meaning of codes is consistent across versions. However this cannot
// consistently be assured, and when the meaning is not guaranteed to be
// consistent, the version SHOULD be exchanged.
String version;

//  The code for this item in the expansion hierarchy. If this code is
// missing the entry in the hierarchy is a place holder (abstract) and
// does not represent a valid code in the value set.
String code;

//  The recommended display for this item in the expansion.
String display;

//  Additional representations for this item - other languages, aliases,
// specialized purposes, used for particular purposes, etc. These are
// relevant when the conditions of the expansion do not fix to a single
// correct representation.
List<ValueSet_Designation> designation;

//  Other codes and entries contained under this entry in the hierarchy.
List<ValueSet_Contains> contains;

ValueSet_Contains(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.system,
    this.abstract,
    this.inactive,
    this.version,
    this.code,
    this.display,
    this.designation,
    this.contains,
    });

  factory ValueSet_Contains.fromJson(Map<String, dynamic> json) => _$ValueSet_ContainsFromJson(json);
  Map<String, dynamic> toJson() => _$ValueSet_ContainsToJson(this);
}

part 'verificationResult.g.dart';

@JsonSerializable(explicitToJson: true)
class VerificationResult {

//  This is a VerificationResult resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A resource that was validated.
List<Reference> target;

//  The fhirpath location(s) within the resource that was validated.
List<String> targetLocation;

//  The frequency with which the target must be validated (none; initial;
// periodic).
CodeableConcept need;

//  The validation status of the target (attested; validated; in process;
// requires revalidation; validation failed; revalidation failed).
String status;

//  When the validation status was updated.
DateTime statusDate;

//  What the target is validated against (nothing; primary source;
// multiple sources).
CodeableConcept validationType;

//  The primary process by which the target is validated (edit check;
// value set; primary source; multiple sources; standalone; in context).
List<CodeableConcept> validationProcess;

//  Frequency of revalidation.
Timing frequency;

//  The date/time validation was last completed (including failed
// validations).
DateTime lastPerformed;

//  The date when target is next validated, if appropriate.
String nextScheduled;

//  The result if validation fails (fatal; warning; record only; none).
CodeableConcept failureAction;

//  Information about the primary source(s) involved in validation.
List<VerificationResult_PrimarySource> primarySource;

//  Information about the entity attesting to information.
VerificationResult_Attestation attestation;

//  Information about the entity validating information.
List<VerificationResult_Validator> validator;

VerificationResult(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.target,
    this.targetLocation,
    this.need,
    this.status,
    this.statusDate,
    this.validationType,
    this.validationProcess,
    this.frequency,
    this.lastPerformed,
    this.nextScheduled,
    this.failureAction,
    this.primarySource,
    this.attestation,
    this.validator,
    });

  factory VerificationResult.fromJson(Map<String, dynamic> json) => _$VerificationResultFromJson(json);
  Map<String, dynamic> toJson() => _$VerificationResultToJson(this);
}

@JsonSerializable(explicitToJson: true)
class VerificationResult_PrimarySource {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reference to the primary source.
Reference who;

//  Type of primary source (License Board; Primary Education; Continuing
// Education; Postal Service; Relationship owner; Registration Authority;
// legal source; issuing source; authoritative source).
List<CodeableConcept> type;

//  Method for communicating with the primary source (manual; API; Push).
List<CodeableConcept> communicationMethod;

//  Status of the validation of the target against the primary source
// (successful; failed; unknown).
CodeableConcept validationStatus;

//  When the target was validated against the primary source.
DateTime validationDate;

//  Ability of the primary source to push updates/alerts (yes; no;
// undetermined).
CodeableConcept canPushUpdates;

//  Type of alerts/updates the primary source can send (specific requested
// changes; any changes; as defined by source).
List<CodeableConcept> pushTypeAvailable;

VerificationResult_PrimarySource(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.who,
    this.type,
    this.communicationMethod,
    this.validationStatus,
    this.validationDate,
    this.canPushUpdates,
    this.pushTypeAvailable,
    });

  factory VerificationResult_PrimarySource.fromJson(Map<String, dynamic> json) => _$VerificationResult_PrimarySourceFromJson(json);
  Map<String, dynamic> toJson() => _$VerificationResult_PrimarySourceToJson(this);
}

@JsonSerializable(explicitToJson: true)
class VerificationResult_Attestation {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  The individual or organization attesting to information.
Reference who;

//  When the who is asserting on behalf of another (organization or
// individual).
Reference onBehalfOf;

//  The method by which attested information was submitted/retrieved
// (manual; API; Push).
CodeableConcept communicationMethod;

//  The date the information was attested to.
String date;

//  A digital identity certificate associated with the attestation source.
String sourceIdentityCertificate;

//  A digital identity certificate associated with the proxy entity
// submitting attested information on behalf of the attestation source.
String proxyIdentityCertificate;

//  Signed assertion by the proxy entity indicating that they have the
// right to submit attested information on behalf of the attestation
// source.
Signature proxySignature;

//  Signed assertion by the attestation source that they have attested to
// the information.
Signature sourceSignature;

VerificationResult_Attestation(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.who,
    this.onBehalfOf,
    this.communicationMethod,
    this.date,
    this.sourceIdentityCertificate,
    this.proxyIdentityCertificate,
    this.proxySignature,
    this.sourceSignature,
    });

  factory VerificationResult_Attestation.fromJson(Map<String, dynamic> json) => _$VerificationResult_AttestationFromJson(json);
  Map<String, dynamic> toJson() => _$VerificationResult_AttestationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class VerificationResult_Validator {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Reference to the organization validating information.
Reference organization;

//  A digital identity certificate associated with the validator.
String identityCertificate;

//  Signed assertion by the validator that they have validated the
// information.
Signature attestationSignature;

VerificationResult_Validator(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.organization,
    this.identityCertificate,
    this.attestationSignature,
    });

  factory VerificationResult_Validator.fromJson(Map<String, dynamic> json) => _$VerificationResult_ValidatorFromJson(json);
  Map<String, dynamic> toJson() => _$VerificationResult_ValidatorToJson(this);
}

part 'visionPrescription.g.dart';

@JsonSerializable(explicitToJson: true)
class VisionPrescription {

//  This is a VisionPrescription resource
String resourceType;

//  The logical id of the resource, as used in the URL for the resource.
// Once assigned, this value never changes.
String id;

//  The metadata about the resource. This is content that is maintained by
// the infrastructure. Changes to the content might not always be
// associated with version changes to the resource.
Meta meta;

//  A reference to a set of rules that were followed when the resource was
// constructed, and which must be understood when processing the content.
// Often, this is a reference to an implementation guide that defines the
// special rules along with other profiles etc.
String implicitRules;

//  The base language in which the resource is written.
String language;

//  A human-readable narrative that contains a summary of the resource and
// can be used to represent the content of the resource to a human. The
// narrative need not encode all the structured data, but is required to
// contain sufficient detail to make it "clinically safe" for a human to
// just read the narrative. Resource definitions may define what content
// should be represented in the narrative to ensure clinical safety.
Narrative text;

//  These resources do not have an independent existence apart from the
// resource that contains them - they cannot be identified independently,
// and nor can they have their own independent transaction scope.
List<ResourceList> contained;

//  May be used to represent additional information that is not part of
// the basic definition of the resource. To make the use of extensions
// safe and manageable, there is a strict set of governance  applied to
// the definition and use of extensions. Though any implementer can define
// an extension, there is a set of requirements that SHALL be met as part
// of the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the resource and that modifies the
// understanding of the element that contains it and/or the understanding
// of the containing element's descendants. Usually modifier elements
// provide negation or qualification. To make the use of extensions safe
// and manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer is allowed to
// define an extension, there is a set of requirements that SHALL be met
// as part of the definition of the extension. Applications processing a
// resource are required to check for modifier extensions. Modifier
// extensions SHALL NOT change the meaning of any elements on Resource or
// DomainResource (including cannot change the meaning of
// modifierExtension itself).
List<Extension> modifierExtension;

//  A unique identifier assigned to this vision prescription.
List<Identifier> identifier;

//  The status of the resource instance.
String status;

//  The date this resource was created.
DateTime created;

//  A resource reference to the person to whom the vision prescription
// applies.
Reference patient;

//  A reference to a resource that identifies the particular occurrence of
// contact between patient and health care provider during which the
// prescription was issued.
Reference encounter;

//  The date (and perhaps time) when the prescription was written.
DateTime dateWritten;

//  The healthcare professional responsible for authorizing the
// prescription.
Reference prescriber;

//  Contain the details of  the individual lens specifications and serves
// as the authorization for the fullfillment by certified professionals.
List<VisionPrescription_LensSpecification> lensSpecification;

VisionPrescription(
  {this.resourceType,
    this.id,
    this.meta,
    this.implicitRules,
    this.language,
    this.text,
    this.contained,
    this.extension,
    this.modifierExtension,
    this.identifier,
    this.status,
    this.created,
    this.patient,
    this.encounter,
    this.dateWritten,
    this.prescriber,
    this.lensSpecification,
    });

  factory VisionPrescription.fromJson(Map<String, dynamic> json) => _$VisionPrescriptionFromJson(json);
  Map<String, dynamic> toJson() => _$VisionPrescriptionToJson(this);
}

@JsonSerializable(explicitToJson: true)
class VisionPrescription_LensSpecification {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Identifies the type of vision correction product which is required for
// the patient.
CodeableConcept product;

//  The eye for which the lens specification applies.
String eye; // <code> enum: right/left;

//  Lens power measured in dioptres (0.25 units).
double sphere;

//  Power adjustment for astigmatism measured in dioptres (0.25 units).
double cylinder;

//  Adjustment for astigmatism measured in integer degrees.
int axis;

//  Allows for adjustment on two axis.
List<VisionPrescription_Prism> prism;

//  Power adjustment for multifocal lenses measured in dioptres (0.25
// units).
double add;

//  Contact lens power measured in dioptres (0.25 units).
double power;

//  Back curvature measured in millimetres.
double backCurve;

//  Contact lens diameter measured in millimetres.
double diameter;

//  The recommended maximum wear period for the lens.
Quantity duration;

//  Special color or pattern.
String color;

//  Brand recommendations or restrictions.
String brand;

//  Notes for special requirements such as coatings and lens materials.
List<Annotation> note;

VisionPrescription_LensSpecification(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.product,
    this.eye,
    this.sphere,
    this.cylinder,
    this.axis,
    this.prism,
    this.add,
    this.power,
    this.backCurve,
    this.diameter,
    this.duration,
    this.color,
    this.brand,
    this.note,
    });

  factory VisionPrescription_LensSpecification.fromJson(Map<String, dynamic> json) => _$VisionPrescription_LensSpecificationFromJson(json);
  Map<String, dynamic> toJson() => _$VisionPrescription_LensSpecificationToJson(this);
}

@JsonSerializable(explicitToJson: true)
class VisionPrescription_Prism {

//  Unique id for the element within a resource (for internal references).
// This may be any string value that does not contain spaces.
String id;

//  May be used to represent additional information that is not part of
// the basic definition of the element. To make the use of extensions safe
// and manageable, there is a strict set of governance  applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension.
List<Extension> extension;

//  May be used to represent additional information that is not part of
// the basic definition of the element and that modifies the understanding
// of the element in which it is contained and/or the understanding of the
// containing element's descendants. Usually modifier elements provide
// negation or qualification. To make the use of extensions safe and
// manageable, there is a strict set of governance applied to the
// definition and use of extensions. Though any implementer can define an
// extension, there is a set of requirements that SHALL be met as part of
// the definition of the extension. Applications processing a resource are
// required to check for modifier extensions. Modifier extensions SHALL
// NOT change the meaning of any elements on Resource or DomainResource
// (including cannot change the meaning of modifierExtension itself).
List<Extension> modifierExtension;

//  Amount of prism to compensate for eye alignment in fractional units.
double amount;

//  The relative base, or reference lens edge, for the prism.
String base; // <code> enum: up/down/in/out;

VisionPrescription_Prism(
  {this.id,
    this.extension,
    this.modifierExtension,
    this.amount,
    this.base,
    });

  factory VisionPrescription_Prism.fromJson(Map<String, dynamic> json) => _$VisionPrescription_PrismFromJson(json);
  Map<String, dynamic> toJson() => _$VisionPrescription_PrismToJson(this);
}

